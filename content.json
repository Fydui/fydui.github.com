[{"title":"C++笔记-Vector","date":"2017-03-28T13:34:47.000Z","path":"2017/03/28/C++笔记-Vector/","text":"画师P站ID:61403923 标准库模板 STL提供了一组表示,容器,迭代器,算法,函数对象的模板.容器是一个与数组类似的单元,可以储存若干个类型相同的值.算法用来完成特定任务(如对数组进行排序)的处方;迭代器用来遍历容器里的对象,与能够遍历数组的指针类似,是广义的指针.函数对象是类似于函数的对象,可以是类对象或函数指针. 模板类Vector 可以创建vector对象; 将一个vector对象赋值给另一个,或者使用[]运算符来访问vector中的元素.头文件vector中定义了vector模板举个书上的栗子,输入书名和评分:123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int NUM = 5;int main()&#123; vector&lt;int&gt; vi(NUM); vector&lt;string&gt; vs(NUM); cout &lt;&lt; &quot;请输入&quot; &lt;&lt; NUM &lt;&lt; &quot;个书名和你的评分&quot; &lt;&lt; endl; int i = 0; for(;i &lt; NUM;i++) &#123; cout &lt;&lt; &quot;#第&quot; &lt;&lt; i+1 &lt;&lt; &quot;本:&quot;; getline(cin,vs[i]); cout &lt;&lt; &quot;\\n 请输入评分:&quot;; cin &gt;&gt; vi[i]; cin.get(); &#125; for(i = 0; i &lt; NUM; i++) &#123; cout &lt;&lt; &quot;名字: &quot; &lt;&lt; vs[i] &lt;&lt; &quot; 评分:&quot; vi[i] &lt;&lt; endl; &#125; return 0;&#125; 对vector的操作 size(): 返回容器中的元素数目; swap(): 交换两个容器的内存; begin(): 返回一个指向容器中第一个元素的迭代器; end(): 返回一个表示超过容器尾的迭代器; 什么是迭代器? 他是一个广义的指针(恩没错就是指针),可以对其执行类似指针的操作比如解引用,递增;每个容器都定义了适合的迭代器,一般是名为iterator的typedef,其作用域为整个类.比如声明一个vector的迭代器可以这样做:1234567891011vector&lt;double&gt;::iterator pd; //pd是一个迭代器vector&lt;double&gt; sum;//sum是一个vector对象pd = sum.begin(); //将pd指向sum的第一个元素*pd = 22.3; //对pd解引用,把22.3赋值给pd所指向的元素(也就是sum的第一个元素);++pd; //使pd指向下一个元素//另外可以不这么写: vector&lt;double&gt;::iterator pd = sum.begin();//而是这样做:auto pd = sum.begin(); //C++11 前面说过超过容器尾的迭代器,那么什么是超过结尾呢(past-the-end)?它是一种迭代器,指向容器最后一个元素后面的那个元素的指针.end()成员函数表示超过结尾的位置,如果将迭代器设为容器的第一个元素,然后自加.则最终可将它到达容器结尾,从而遍历整个容器.12for(pd=sum.begin(); pd != sum.end(); pd++)cout &lt;&lt; *pd &lt;&lt; endl; push_back()是一个方便的方法,他讲元素添加到矢量末尾,这样他讲负责管理内存,增加矢量的长♂度,使之容纳下新成员:12345vector&lt;double&gt; sco;double temp;while(cin &gt;&gt; temp &amp;&amp; temp &gt;= 0) sco.push_back(temp); //只要有足够的内存,程序可以根据需要增加sco的长度 cout&lt;&lt; &quot;你输入了:&quot; &lt;&lt; sco.size() &lt;&lt; &quot;个元素&quot;; erase()方法可以删除是两种给定区间的元素.他接受两个迭代器的参数,这俩参数定义了要删除的区间.第一个迭代器指向区间的起始处,第二个指向区间的末尾.例如下列代码删除了[sco.bgein(),sco.begin()+2)区间内的元素:1sco.erase(sco.begin(),sco.begin()+2); inster()方法的功能与erase()相反,他接受三个迭代器参数,第一个指向了新元素的插入位置,第二三个迭代器定义了被插入区间,这个区间通常是另一个容器对象的一部分;就是把A容器的一部分复制出来,插入到B容器的某一位置;列入下列代码将new_v中的除了第一个元素之外所有的元素查到old_v矢量的第一个元素前面:1234vector&lt;int&gt; old_v;vector&lt;int&gt; new_v;old_v.inster(old_v.begin(),new_v.begin()+1,new_v.end());","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-智能指针","date":"2017-03-26T14:45:49.000Z","path":"2017/03/26/C++笔记-智能指针/","text":"封面来源 使用智能指针 C++有三个智能指针模板(auto_ptr,unique_ptr,shared_ptr),都定义了类似于指针的对象,可以将new获得的地址赋值给这种对象.(其中auto_ptr是C++98提供的解决方案,C++11已经摒弃,不建议使用).当智能指针过期时,其析构函数将使用delete来释放内存.另外share_ptr和unique_ptr的行为与auto_ptr相同. 要使用智能指针首先包含头文件memory.1auto_ptr&lt;double&gt; pd(new double); new double是new返回的指针,指向新分配的内存块.他是构造函数auto_ptr&lt;double&gt;的参数.即对应于原型中的形参p的实参.同样new double也是构造函数的实参.其他两种智能指针的写法:12unique_ptr&lt;double&gt; pdu(new double);shared_ptr&lt;string&gt; pss(new string); 下列代码举例了全部三种智能指针:123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Report&#123;private: string str;public: Report(const string s) : str(s) &#123;cout &lt;&lt; &quot;Objectt created:&quot; &lt;&lt; endl;&#125; ~Report() &#123;cout &lt;&lt; &quot;Object deleted&quot; &lt;&lt; endl;&#125; void comment() const &#123;cout &lt;&lt; str &lt;&lt; endl;&#125;&#125;;int main()&#123; &#123; auto_ptr&lt;Report&gt; ps(new Report(&quot;auto_ptr&quot;)); ps-&gt;comment(); &#125; &#123; shared_ptr&lt;Report&gt; ps(new Report(&quot;shared_ptr&quot;)); ps-&gt;comment(); &#125; &#123; unique_ptr&lt;Report&gt; ps(new Report(&quot;unique_ptr&quot;)); ps-&gt;comment(); &#125; return 0;&#125; 智能指针很多地方和正常指针类似,可以对他进行解引用操作( *p),用它来访问成员(p-&gt;fun),将他赋值给指向相同类型的常规指针,或者赋值给另一个同类型的只能指针; unique_ptr为何优于auto_ptrauto:123auto_ptr&lt;string&gt; p1(new string(&quot;auto&quot;));auto_ptr&lt;string&gt; p2;p2 = p1; 在第三句,p2接管string对象所有权后,p1的所有权被剥夺,但如果程序随后视图使用p1,则是件坏事因为p1已经不再指向有效的数据;unique_ptr:123unique_ptr&lt;string&gt; p3(new string(&quot;auto&quot;));unique_ptr&lt;string&gt; p4;p4 = p3; 编译器认为第三句非法,避免了p3不再指向有效数据的问题; 但有时候将一个智能指针赋值给另一个不会出现悬挂指针的危险:12345678unique_ptr&lt;string&gt; demo(const char * s)&#123;unique_ptr&lt;string&gt; temp(new string);return temp;&#125;...unique_ptr&lt;string&gt;ps;ps = demo(&quot;2333333&quot;); demo()返回一个临时unique_ptr,然后ps接管了demo的临时返回值,ps拥有了string对象的所有权.因为demo返回的临时对象很快就会被销毁.所以没有机会使用它来访问无效的数据,所以编译器允许这种赋值.所以就是,如果源unique_ptr是个临时右值,编译器将允许赋值,但如果源unique_ptr将存在一段时间,编译器将禁止这样做..….. 如果一定要写类似于p3p4那样的代码.要安全的使用指针的话,可以给他赋新值,C++有个标准库函数std::move(),能够让你将一个unique_ptr赋给另一个.:12345using namespace std;unique_ptr&lt;string&gt; ps1, ps2;ps1 = demo(&quot;23333&quot;);ps2 = move(ps1);cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; unique_ptr还可以当数组用:1unique_ptr&lt;double[]&gt;pda(new double(5)); 为啥unique_ptr能知道安全和不安全的用法呢? 因为它使用了C++11的移动构造函数和右值引用…. 选择智能指针 如果程序要使用多个指向同一个对象的指针,应选择shared_ptr,必去有个指针数组,并使用一些辅助指针来标示特定的元素(比如最大值最小值);比如两个对象都指向第三个对象的指针; stl容器;这些操作都可以使用shared_ptr;但不能用unique_ptr和auto_ptr; 如果程序不需要多个指向同一个对象的指针,则可以使用unique_ptr.如果函数使用new分配内存并返回指向该内存的指针.则其返回类型声明为unique_ptr是个不错的选择;这样所有权将转让给接受返回值的unique_ptr,而该智能指针将负责调用delete;12345678910111213141516unique_ptr&lt;int&gt; make_int(int n)&#123; return unique_ptr&lt;int&gt; (new int (n)); &#125;void show(unique_ptr&lt;int&gt; &amp; pi)&#123; cout &lt;&lt; *a &lt;&lt; &quot; &quot;;&#125;int main()&#123; vector&lt;unique_ptr&lt;int&gt;&gt; vp(size); for(jint i = 0; i &lt; vp.size(); i++) vp[i] = make_int(rand() % 1000); vp.push_back(make_int (rand() % 1000)); for_each(vp.begin(),vp.end(),show());&#125; 其中的push_back()调用没毛病,因为他返回一个临时的unique_ptr对象.另外如果安置而不是按引用给show()传递对象,则for_each()将会非法,因为这将导致使用一个来自vp的非临时unique_ptr初始化pi,前面说过,这是不行的. 在unique_ptr为右值的时候,可将其赋值给shared_ptr,要求和赋值给另一个unique_ptr一样:123unique_ptr&lt;int&gt; pup(make_int(rand%1000)); //假设make_int返回类型是unique_ptrshared_ptr&lt;int&gt; spp(pup);shared_ptr&lt;int&gt; spr(make_int(rand() % 1000)); //假设make_int返回类型是unique_ptr 模板shared_ptr有个显示构造函数,可将右值的unique_ptr转化为shared_ptr.shared_ptr将接管原来的unique_ptr所有的对象;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-string类","date":"2017-03-25T14:51:53.000Z","path":"2017/03/25/C++笔记-string类/","text":"string类的构造函数:size_type是一个依赖于实现的整形在头文件string中定义的.string类将string::npos定义为字符串的最大长度,通常为unsigned int的最大值.NBTS(null-terminated-string)来表示空字符结束的字符串.12345678910111213141516string(const char *s); //将string对象初始化为s指向的NBTSstring(size_type n, char c) //创建一个包含n个元素的string对象,其中每个都被初始化为cstring(const string &amp;str) //将一个string对象初始化为string对象str(复制构造函数)string() //创建一个长度为0的默认string对象string(const char * s,size_type n) //创建一个裁剪了s的前n个字符串的对象.template&lt;class Iter&gt;string(Iter begin, Iter end) //将一个string对象初始化为区间[begin,end)内的字符串,begin和end就像指针,用于指定位置string(const string &amp; str, string size_type pos = 0, size_type n = npos)//将一个string对象初始化为对象str中从位置pos开始到结尾的字符,或从pos的位置到第n个字符串;string(string &amp;&amp; str) noexcept//C++11新增,将一个string对象初始化为string对象str,并且可能修改str(移动构造函数)string(initializer_list&lt;char&gt;il) //C++11新增,将一个string对象初始化为列表il中的字符 第五个构造函数将一个C-风格字符串和一个整数作为参数,其中的整数参数来表示要复制多少个字符串(如果20被改成40则将会继续复制字符串..将导致十五个无用的字符串被复制到five的结尾处):12char alls[] = &quot;All&apos;s well that ends well&quot;;string five(alls,20);//这里只是用了前二十个字符来初始化five对象. 第六个构造函数有一个模板参数:1template&lt;class Iter&gt;string(Iter begin,Iter end); begin和end想指针那样指向内存中的两个位置,构造函数将使用begin和end之间的值对string对象初始化.1string six(alls+6,alls+10) //six被初始化为well; 在这里数组名相当于指针,所以alls+6和alls+10的类型都是char,因此类型char将替换Iter.第一个参数指向数组(从零开始)alls中的第六个字符串(w),第二个参数指向alls的第十个(well后面的空格); 现在假设要用该构造函数将对象初始化为另一个string对象(假设为five)的一部分内容,则下面这句不管用:1string seven(five+6,five+10); 原因在于对象名并不是数组名,所以five不是个指针,但five[6]是一个char值,&amp;five[6]则是个地址,因此可以被用作该构造函数的一个参数:1string seven(&amp;five[6],&amp;five[10]); 第七个构造函数将一个string对象的部分复制到构造的对象中:1string eight(four,7,16);//从four的第八个字符开始将16个字符复制到eight中 C++11新增的构造函数: 构造函数string(string &amp;&amp; str)类似于复制构造函数,导致新的string为str的副本,但跟复制构造函数不一样的是,他不保证将str视为const.这种构造函数被称为移动构造函数(move constructor). 构造函数string(initialzer_list)使得下面的声明是合法的:12string p = &#123;&apos;L&apos;,&apos;U&apos;,&apos;C&apos;,&apos;K&apos;&#125;;string c&#123;&apos;L&apos;,&apos;U&apos;,&apos;C&apos;,&apos;K&apos;&#125;; string类输入: 对于string有两种输入方式:123456string stuff;cin &gt;&gt; stuff;getline(cin,stuff);//getline有个可选参数,用于指定使用哪个字符串来确定输入的边界:getline(stuff,&apos;:&apos;); //string的getline会自动调整大小使得正好容得下输入的字符串&apos; 虽然string的getline能自动调节大小,但是有一些限制,如过想要读取一个文本,那么string对象所允许的最大长度(大小为unsigned int的值)可能不够. string的getlin从输入中读取字符串并将其储存到目标string中,直到发生下面三种情况之一: 到达文件尾. 遇到分界字符(如 \\n) 读取的字符数达到最大值; 使用字符串 可以比较字符串.string类对于全部六个关系运算符都进行了重载.如果在机器排列序列中,一个对象位于另一个对象的前面,则前者小于后者.如果机器排列序列为ASCII码,则数字江小鱼大写字符,大写字符小于小写字符.12345678910string str1 = &quot;cobra&quot;;string str2 = &quot;coral&quot;;string str3[20] = &quot;anaconda&quot;;if(str1 &lt; str2) ...if(str1 == str3) ...if(str3 != str2) ...//可以确定字符串的长度.size()和length()成员函数都返回字符串中的字符数:if(str1.length() == str2.size()) ... 可以以多种方式在字符串中搜索给定的字符串或字符.重载的find方法:12345678size_type find(const string &amp; str, size_type pos = 0) const;//从字符串的pos位置开始,查找字符串str,找到了则返回该字符串首次出现时其首字符的索引,没有就返回string::npossize_type find(const char* s,size_type pos = 0) const; //同上size_type find(char ch, size_type pos = 0)const; //同上size_type find(const char* s,size_type pos = 0, size_type n);//从字符串的pos开始,查找s的前n个字符串组成的子字符串.找到则返回子字符串首次出现的首字符的索引,否则返回string::npos 除此之外还有: rfind()方法查找子字符串或字符串最后一次出现的位置; find_first_of()方法在字符串中查找参数中任何一个字符串首次出现的位置; find_last_of()方法用法相同,查找的是最后一次出现的位置 find_first_not_of()方法在字符串中查找第一个不包含在参数中的字符串","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-类型转换运算符&友元,异常の总结","date":"2017-03-23T14:51:04.000Z","path":"2017/03/23/C++笔记-类型转换运算符&友元,异常的总结/","text":"图片来源 类型转换运算符 C++对于类型转换采取更严格的限制.并添加了四个类型转换运算符: dynamic_cast const_cast static_cast reinterpret_cast; dynamic_cast运算符前面介绍过.假设有俩类High和Low,而ph和pl的类型分别为High和Low,则仅当Low是High的可访问基类(直接或者间接)时,下述语句才能将Low*指针赋给pl:1pl = dynamic_cast&lt;Low*&gt;ph; 该运算符的作用是能够在类层次结构中进行向上类型转换. const_cast运算符只有一种用途的类型转换,即改变值为const或volatile(去掉/增加const/volatile特性):1const_cast&lt;type-name&gt;(expression) 如果类型的其他地方也被修改则上述类型将出错.除了cosnt或volatile特征(有或无)可以不同外,type_name和expression的类型必须相同.再次假设High和Low:12345High bar;const High * pbar = &amp;bar;...High * pb = const_cast&lt;High*&gt;(pbar); //没毛病,将删除pbar的const标签const Low * pl = const_cast&lt;const Low*&gt;(pbar);//不行,因为他尝试将const High*改为const Low* 然而其实也可以不用const_cast:12345High bar;const High * pbar = &amp;bar;...High * pb = (High *)(pbar);Low * pl = (Low *)(pbar); 但修改const值的结果可能是不确定的,请看示例:123456789101112131415161718void change(const int * pt, int n)&#123; int *pc; pc = const_cast&lt;int * &gt;(pt); *pc += n;&#125;int main()&#123; int popl = 38383; const int pop2 = 2000; cout &lt;&lt; &quot;pop1,pop2: &quot; &lt;&lt; pop1 &lt;&lt; &quot;,&quot; &lt;&lt; pop2 &lt;&lt; endl; change(&amp;pop1,-103); change(&amp;pop2,-103); cout&lt;&lt; &quot;pop1,pop2&quot;&lt;&lt; pop1 &lt;&lt; &quot;,&quot; &lt;&lt; pop2 &lt;&lt; endl; return 0;&#125; 调用change()时修改了pop1,但没有修改pop2.在change()中,虽然指针pt被声明为const int ,但const_cast去掉了pt的const标签,并赋给了pc,所以pc能修改pop1的值.但仅当指针指向的值不是const时才可行,所以pc不能修改pop2的值. *static_cast语法:1static_cast&lt;type-name&gt;(expression) 仅当typename能被隐式的转换成expression所属类型或expression能被隐式的转换成typename所属的类型的时候,上述转换才是合法的.假设Low是High的基类,而P是一个无关的类,则从High转换到Low,或者从Low转换到High的时候是合法的,而从Low转到p则是非法的.123456High bar;Low blow; High * pb = static_cast&lt;High*&gt;(&amp;blow); //可以 Low * pl = static_cast&lt;Low *&gt;(&amp;bar); //可以 P * pmer = static_cast&lt;Pond *&gt;(&amp;blow) //不行 reinterprete_cast几乎能资呲所有的类型转换,比如可以将指针类型转化为能存下这个指针的整形,但不能将指针转化为更小的整形或浮点型.并且不能讲函数指针转化为数据指针,且不能去掉const标签;语法:1reinterpret_cast&lt;type-name&gt;(expression); 示例:1234struct dat(short a, short b);long value = 0xA224B118;dat * pd = reinterpret_cast&lt;dat *&gt;(&amp;value);cout &lt;&lt; hex &lt;&lt; pd-&gt;a;//显示 前两个字节的值 友元,异常总结 类可以将其它函数,其他类的程序作为自己的友元.在一些情况下需要使用向前声明.并需要注意正确的组合类和方法的顺序; 嵌套类是声明在其他类中的类,但不比是其公有接口的组成部分. 当异常触发时,程序将控制权转交给匹配的catch块,catch块里面的是解决异常或终止程序的代码,在catch块之前的是try块,直接或间接导致异常的函数调用必须放在try块中. RTTI可以检测对象的类型.dynamic_cast运算符可以用于将派生类指针转化为基类指针,其可以安全的调用虚函数.typeid运算符返回一个type_info对象.可以对两个typeid的返回值进行比较看看是不是特定的类型.而type_info对象可用于获得关于对象的信息 而dynamic_cast,static_cast,const_cast,和retinterpret_cast提供了安全的明确的类型转换.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-RTTI(运行阶段类型识别:Runtime Type Identification)","date":"2017-03-20T14:53:04.000Z","path":"2017/03/20/C++笔记-RTTI/","text":"霞之丘诗羽 RTTI这个听上去银瓶乍破水浆迸铁骑突出刀枪鸣的名字正是我大C艹的运行阶段类型识别(Runtime Type Identification)的简称 RTTI可以通过基类的指针和引用来检测这些指针和引用所指向的派生类对象的具体类型. 假设有一个类层次结构,其中的类都是从一个基类派生而来的,则可以让基类指针指向其中的任何一个类的对象.在处理一些信息之后,选则一个类,并创建这种类型对象,然后返回这个对象的地址,而这个地址可以赋值给基类指针,那么如何确定这个对象的类型? 只有知道了类型,才可能调用类方法的正确版本,如果在这个类结构层次中,所有的成员都拥有虚函数,在这个时候就不需要知道对象的类型.但派生类可能包含一些新的方法,在这种情况下只有某些类型可以使用该方法.这时候就可以使用RTTI提供解决方案. dynamic_cast 运算符: 这个运算符可以检测是否可以安全的将对象的地址赋值给特定的类型指针. 假设有下列类层次结构:12345678910111213class Grand&#123;&#125;;class Superb: public Grand()&#123;&#125;class Magn : public Superb()&#123;&#125;//假设有下列指针:Grand * pg = new Grand;Grand * ps = new Superb;Grand * pm = new Magn;//假设有下列类型转换,那么谁是比较安全的?:Magn * p1 = (Magn *) pm; //安全,因为相同类型的指针指向了相同类型的对象.Magn * p2 = (Magn *) pg; //不安全,因为派生类指向基类,而派生类可能有些方法是基类没有的.Superb * p3 = (Magn *) pm;//安全,因为基类指向派生类. 所以,问题”指针指向的是那种类型”和”类型转换是否安全”,类型是否安全更通用点.原因在于:要调用类方法.类型并不一定要完全匹配,儿科一是定义了方法的与你版本的基类类型. dynamic_cast语法:12 Superb * pm = dynamic_cast&lt;Superb *&gt;(pg); //指针pg的类型如果可以被安全的转换为Superb*则运算符将返回对象的地址,否则返回一个空指针 下列代码演示了这种处理,首先他定义了三个类.Grand类定义了一个虚函数Speak(),并且其他类都重定义了这个虚函数,Superb类定义了一个虚函数Say(),而Magn也重定义了他.程序定义了GetOne()函数用来随机创建这三种类中的某种类对象,并对其初始化,然后将地址作为Grand*指针返回并赋给pg.然后使用pg调用Speak().因为这个函数是虚的随意代码能够正确的调用指向的对象的Speak()版本.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Grand&#123;private: int hold;public: Grand(int h = 0) : hold(h)&#123;&#125; virtual void Speak() const&#123;cout &lt;&lt; &quot;Grand&quot; &lt;&lt; endl;&#125; virtual int Value() const&#123;return hold;&#125;&#125;;class Superb : public Grand&#123;public: Superb(int h = 0) : Grand(h)&#123;&#125; void Speak() const &#123;cout &lt;&lt; &quot;Superb&quot; &lt;&lt; endl;&#125; virtual void Say() const&#123;cout &lt;&lt; &quot;superb value of &quot; &lt;&lt; Value() &lt;&lt; endl;&#125;&#125;;class Magn : public Superb&#123;private: char ch;public: Magn(int h = 0,char c = &apos;A&apos;) : Superb(h),ch(c)&#123;&#125; void Speak() const &#123;cout &lt;&lt; &quot;Magn&quot; &lt;&lt; endl;&#125; void Say() const&#123;cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; endl;&#125;&#125;;Grand * GetOne()&#123; Grand * p; switch(std::rand() % 3) &#123; case 0 : p = new Grand(std::rand() % 100); break; case 1 : p = new Superb(std::rand() % 100); break; case 2 : p = new Magn(std::rand() % 100,&apos;A&apos; + std::rand() % 26); break; &#125; return p;&#125;int main()&#123; std::srand(std::time(0)); Grand * pg; Superb * ps; for(int i = 0; i &lt; 5; i++) &#123; pg = GetOne(); pg-&gt;Speak(); if(ps = dynamic_cast&lt;Superb *&gt;(pg)) //如果类型转换成功,则ps为非零.失败则返回空指针0. ps-&gt;Say(); &#125; return 0;&#125; typeid运算符和type_info类 typeid运算符使得能够确定两个对象是否为同种类型.他接受两种参数: 类名 结果为对象的表达式 typeid运算符返回一个对type_info对象的引用,其中type_info是在头文件typeinfo中定义的一个类.这个类重载了==和!=运算符,以便可以使用这些运算符来对类型进行比较.1typeid(Magn) == typeid(*pg); //如果pg指向的是一个Magn对象,则表达式结果为bool值.true,否则为false. 如果pg是一个空指针,则程序将引发bad_tyoeid异常.type_info包含了一个name()方法,该函数返回一个随着实现而异的字符串…通常是类名.1 cout&lt;&lt; &quot;Class Name:&quot; &lt;&lt; tyoeid(*pg).name() &lt;&lt; endl; 有瑕疵的RTTI例子: 不讨论大家对RTTI的争论,介绍一个应该避免的编程方式:123456789 Grand * pg;Superb * ps;for(int i = 0; i &lt; 5; i++)&#123; pg = GetOne(); pg-&gt;Speak(); if(ps = dynamic_cast&lt;Superb *&gt;(pg)) //如果类型转换成功,则ps为非零.失败则返回空指针0. ps-&gt;Say();&#125; 通过不使用dynamic_cast和虚函数,而使用typeid(),可将上述代码重写为:1234567891011121314151617181920Grand * pg;Superb * ps;for(int i = 0; i &lt; 5; i++)&#123; pg = GetOne(); if(typeid(Magn) == typeid(*pg)) &#123; pm = (Magn*) pg; pm-&gt;Speak(); pm-&gt;Say(); &#125; else if(typeid(Superb) == typeid(*pg)) &#123; pm = (Superb*) pg; pm-&gt;Speak(); pm-&gt;Say(); &#125; else pg-&gt;Speak();&#125; 上述代码不仅sb而且还有毛病..如果从Magn类派生出一个Insu的类,而后者需要重新定义Speak()和Say().则必须修改for循环,添加一个else if.但下面的语句适合所有从Grand派生出的类:1234pg-&gt;Speak();//下面语句适合所有从Superb派生而来的类:if(ps = dynamic_cast&lt;Superb *&gt;(pg))ps-&gt;Say(); 所以说如果发现ifelse中使用了typeid,则应该考虑是否使用虚函数和dynamic_cast","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-异常(3)","date":"2017-03-19T14:51:16.000Z","path":"2017/03/19/C++笔记-异常(3)/","text":"图片来源 异常何时会迷失方向异常被引发之后,有两种情况会导致问题: 意外异常(unexpected exception): 如果异常是在带异常规范的函数中引发的,则必须与规范列表中的某种异常匹配(在继承层次结构中,类类型与这个类机器派生类的对象匹配)就是得有个catch块能跟你写的异常符合/能接受你那异常,否则则成为意外异常.(C++11已经摒弃这东西了,然而有的代码还在用它) 举个正确的栗子: 通过给函数制定异常规范,可以让函数的用户知道要捕获那些异常.放屁,真水1234567891011 double Argh(doouble,double) throw(out_of_bounds) &#123; ... try&#123; x = Argh(a,b); &#125; catch(out_of_bounds &amp; ex)&#123; ... &#125; .. &#125; 未捕获异常(uncaught exception): 如果异常不是在函数中引发,则必须捕获他.如果没有捕获(在没有try块或没有catch块时,将出现) 在默认情况下,出现上述情况程序将被终止,然而可以修改程序对上述异常的反应…未捕获异常不会导致程序立刻停止,首先会调用terminate()函数,terminate()会调用abort()函数,但可以修改terminate()调用的函数(不让他调用abort()).可以使用set_terminate()函数来修改.(在#include中):12345typedef void (*terminate_handler)();terminate_handler set_terminate(terminate_handler f) throw(); //C++ 98terminate_handler set_terminate(terminate_handler f) noexcept; //C++ 11void terminate(); //C++ 98void terminate() noexcept; // C++ 11 typedef使得terminate_handler成为一个指向没有参数和返回值的函数的指针.set_terminate()将这个不带任何参数且返回类型为void的函数的名字(地址)作为参数,并且返回这个函数的地址,如果set_terminate()被多次调用,则terminate()将调用最后一次set_terminate调用设置的函数. 举个栗子:一个未被捕获的异常导致程序打印一条消息,然后调用exit()函数.12345678910111213#include&lt;exception&gt;using namespace std;void myQuit()&#123; cout &lt;&lt; &quot;由于出现未捕获异常,程序终止&quot;; exit(5);&#125;int main&#123; set_terminate(fun);//如果出现未捕获异常,将终止操作指定为调用fun(); throw; //触发未捕获异常&#125; 现在如果程序引发未捕获异常,则将调用terminate(),而terminate()将会调用myQuit(). 原则上,异常规范应该包含函数调用的其他函数所引发的异常.比如A()调用了B(),而B()可能引发retor对象异常,则A(),B()的异常规范中都应该包含retort. 如果函数引发了其异常规范中没有的异常呢?这样处理起来就比较繁琐,所以C++11也将其摒弃.所以说这玩意咋看都像是坑 那么在这种情况下,行为与未捕获异常极其相似,程序将调用unexpected().这函数将调用terminate(),后者在默认情况下调用Abort().跟terminate()一样,有一个可以修改其行为的set_terminate()一样,也有一个用于修改unexpected()的set_unexpected():12345typedef void (*unexpected_handler)();unexpected_handler set_unexpected(unexpected_handler f) throw(); //C++98unexpected_handler set_unexpected(unexpected_handler f) noexcept; //C++11void unexpected(); //C++98void unexpected() noexcept;//C++0x 然而set_unexpected()比set_terminate()更加严格,unexpected_handler函数可以: 通过调用terminate()(默认行为).abort(),exit()等来终止程序 引发异常 如果新引发的异常原来的相匹配,则程序将开始寻找引发新异常的函数规范; 如果新引发的异常跟原来的不一样,且异常规范中没包括sed::bad_exception则将调用terminate(). 如果新引发的异常跟原来的不一样,且异常规范中包括了sed::bad_exception则不匹配的异常会被sed::bad_exception异常取代. 有关异常的注意事项 使用异常会降低程序运行速度.(废话 异常规范不适用于模板. 因为模板函数引发的异常随特定的具体化而异. 异常和动态内存分配并非总能协同工作 动态内存分配和异常:正常:1234567void fun()&#123; string mesg(&quot;Boy Next Door&quot;); ... if(..) throw exception(); ... return;&#125; 当函数结束时,将为mesg调用string的析构函数,虽然throw过早的终止了函数,但因为栈解退的存在使得析构函数仍然被调用完成清理. 有瑕疵:12345678void fun(int n)&#123; string * mesg = new string[n]; ... if(..) throw exception(); ... delete [] mesg; return;&#125; 这里有个瑕疵: 当栈解退时,将删除栈中的变量mesg,但函数过早的终止意味着句尾的delete [] mesg;被忽略.指针虽然没了,但内存还没被释放且不可访问…这就容易造成一些问题.. 修改版:123456789101112131415void fun(int n)&#123; string * mesg = new string[n]; ... try&#123; if(..) throw exception(); //捕获异常 &#125; catch(exception &amp; e)&#123; delete [] mesg; //清理 throw; //重新引发 &#125; ... delete [] mesg; return;&#125; 然而可以用智能指针解决该问题","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-异常(2)","date":"2017-03-14T14:46:57.000Z","path":"2017/03/14/C++笔记-异常(2)/","text":"封面来源 其他异常特型(一些碎碎念 虽然throw-catch机制类似于函数参数和返回机制,但还是有所不同. 其一便是函数中的返回语句是将控制权返回到调用函数的函数,但throw语句将向上寻找,并将控制权返回给一个能够捕获相应异常的try-catch组合. 另一个不同便是,引发异常是编译器总是创建一个临时拷贝.举个栗子:123456789101112131415class problem&#123;...&#125;void fun() throw (problem) // 表示函数只能抛出problem类型的异常.更简单的写法: throw problem()&#123; if(...)&#123; problem opps; throw oops; &#125;&#125;...try&#123; super();&#125;catch(problem &amp;p)&#123; // 这里的p指向的是oops的副本而不是其本身,因为函数执行完毕之后 oops当不复存在; ....&#125; 对于接在函数名后面的throw(something): void fun() throw(); //表示fun函数不允许抛出任何异常，即fun函数是异常安全的 void fun() throw(…); //表示fun函数可以抛出任何形式的异常 void fun() throw(exceptionType); // 表示fun函数只能抛出exceptionType类型的异常 使用引用传递参数更重要的原因是,基类可以使用派生类对象.现在假设有个异常类层次结构,冰妖分别处理不同的异常类型,则使用基类引用能够捕获任何异常对象;而使用派生类对象则只能捕获他所属类以及他的派生类的对象. 因为基类可以使会用派生类对象,而且引发异常的对象将被第一个与之匹配的catch块捕获,那么所以catch块的排列顺序应该与派生类顺序相反:这又是一个一不留神就会留下bug的功能123456789101112131415161718class bad_1&#123;...&#125;;class bad_2 : public bad_1&#123;..&#125;;class bad_3 : public bad_2&#123;...&#125;...void duper()&#123; ... if(...) throw bad_1(); if(...) throw bad_2(); if(...) throw bad_3();&#125;...try &#123; duper();&#125;catch (bad_3 &amp; b3)&#123;...&#125;catch (bad_2 &amp; b2)&#123;...&#125;catch (bad_1 &amp; b1)&#123;...&#125; 如果将catch(bad_1 &amp; b1)放在最前面,他将捕获 bad_1,bad_2,bad_3, 只能通过相反的顺序排列,bad_3才会被bad_3处理程序所捕获. 所以说,如果有一个异常类继承层次结构,应该这样排列catch块: 将捕获位于层次结构最下面的异常类的catch语句放在最前面,将捕获基类异常的catch语句放在最后面;也就是倒着写 exception类 exception头文件定义了exception类,C++可以把它用作于其他异常类的基类.使代码可以引发exception异常,他有一个名曰what()的虚方法,因为是个虚方法所以你可以根据你的实现重定义他. 12345678910111213#include &lt;exception&gt;class bad_hmean : public std:: exception&#123; public: const char * what() &#123;return &quot;不要总想搞个大新闻&quot;;&#125;&#125;//如果不想以不同的方式处理这些派生类的异常,可以在同一个基类中捕获他们:try&#123; ...&#125;catch(std::exception &amp; e)&#123; cout &lt;&lt; e.what() &lt;&lt; endl;&#125; 当然你也可以分开捕获他们,去吧大师球 1.stdexcept异常类 头文件sedexcept定义了几个异常类.比如logic_error和runtime_error类,他们都是以公有集成的方式从exception类继承过来的:12345678910class logic_error: public exception&#123; public: except logic_error(const string &amp; what_arg);&#125;class runtime_error: public exception&#123; public: except runtime_error(const string &amp; what_arg);&#125;//注意 这些类的构造函数都接受一个string对象作为参数,他们提供了what()方法并且返回C-风格字符串 这两个新的类又被作为两个派生类系列的基类,其中logic_error类描述了典型的逻辑错误,这些逻辑错误是可以通过合理编程避免的,但还是可能发生.下面每个类的名称指出了他们用于报告的错误类型: logic_error类: domain_error: invalid_argument: length_error out_of_bounds: doormain_error: 数学函数值域(range)和定义域(domain),定义域由函数可能的参数组成,值域由函数可能的返回值组成,函数在输入参数或返回值不在制定范围的情况下将会引发domain_error异常; incalid_argument: 异常incalid_argument指出了给函数传递了一个意料之外的值.这个和定义域(domain)都有点不一样.例如如果希望输入的每个字符串要么是0要么是1,那么当输入的字符串中包含其他字符的时候,incalid_argument会被触发. length_error: 异常length_error指出了由于没有足够的空间类执行所需操作.比如string类的append()方法在合并得到的字符串长度超了的时候; out_of_bounds: 异常out_of_bounds通常用于指示索引错误,比如定义了个数组类,其operator()[]在使用的索引无效时引发out_of_bounds异常 runtime_error类这个类描述了可能在运行期间发生的难以预料的错误: range_error: overflow_error: underflow_error: 下溢(underflow) 存在浮点类型可以表示的最小非零值,当计算结果小于这个值的时候,将导致下溢错误.上溢(overflow) 存在计算结果超过了某种类型能够表示的最大数值时,将导致上溢.对于计算结果可能不在函数允许范围之内,但没有发生上下溢的时候可以用range_error异常; 继承关系可以使程序员一起处理他们(如果你愿意的话): 下面代码分别处理每种异常,先单独捕获out_of_bounds,然后统一不过其他logic_error系列异常,最后统一不过exception异常,runtime_error,以及其他从exception派生而来的异常: 1234567try&#123;...&#125;catch(out_of_bounds &amp; oe)&#123;...&#125;//捕获out_of_boundscatch(logic_error &amp; oe)&#123;...&#125;//捕获logic_error类catch(exception &amp; oe)&#123;...&#125;//捕获runtime_error,exception,和其他从exception派生而来的异常//↑↑如果你很不爽这么做的话可以给runtime_error,exception派生出来俩异常类,使异常类可以归入同一个继承层次中. bad_alloc异常和new 对于使用new导致的内存分配问题,C++比较新的处理方式是让new引发bad_alloc异常,头文件new包含bad_alloc的声明.他是从exception类公有派生而来,但在以前当无法分配请求的内存量时new返回一个空指针. 举个栗子:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;cstdlib&gt;using namespace std;struct Big&#123; double stuff[20000];&#125;;int main()&#123; Big* pb; try&#123; cout &lt;&lt; &quot;试着申请一大块儿内存&quot; &lt;&lt; endl; pb = new Big[100000]; /*pb = new (std::nothrow) Big[10000]; //这样在内存请求失败的时候会返回空指针 if()&#123; cout &lt;&lt; &quot;请求失败&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125;*/ cout &lt;&lt; &quot;请求通过&quot; &lt;&lt; endl; &#125; catch(bad_alloc &amp; ba)&#123; cout &lt;&lt; &quot;捕捉到异常&quot; &lt;&lt; endl; cout &lt;&lt; ba.what() &lt;&lt; endl; exit(EXIT_FAILURE); &#125; cout &lt;&lt; &quot;成功分配内存&quot; &lt;&lt; endl; pb[0].stuff[0] = 4; cout &lt;&lt; pb[0].stuff[0] &lt;&lt; endl; delete [] pb; return 0;&#125; 如果内存申请失败了则方法what()将会返回字符串std::bad_alloc.(在我的MinGW5.5下返回std::bad_array_new_length)如果你的程序没触发异常清加大请求分配内存量 另外还有一种是在new处理失败时返回空指针的:12int *p = new(std::nothrow) int;int *b = new (std::nowthrow) int[500];","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-异常","date":"2017-03-07T15:14:32.000Z","path":"2017/03/07/C++笔记-异常/","text":"图片来源: 不好意思本智障找不到了.请在p站搜雪染ちさ.. 在(keng)神(te)奇(duo)的C++中, 本智障经常写出一些正常的代码导致我的bug编译不过去. 举个书上的栗子,计算两个数的调和平均数的定义为: 两个数字倒数的平均数, 表达式: 2.0 * x * y / (x + y) 这样的话如果xy互为相反数的情况下岂不是很尴尬? abort() 对于这种问题,处理方式之一是如果检查到xy互为相反数则调用 abort() 函数(abort处于 cstdlib.h ).他会想标准错误流发送 abnormal program termination (程序异常终止),而且返回一个由时间决定的值,告诉操作系统处理失败..当然也可以用exit(),只不过不显示消息而已; 1234567891011121314151617181920212223242526 #include &lt;iostream&gt;#include &lt;cstdlib&gt;double hmean(double a,double b)&#123; if(a == -b) &#123; std::cout &lt;&lt; &quot;这俩数有毛病...&quot; &lt;&lt; std::endl; //在MinGW 5.3.0 32bit 下不使用abort的情况输入10和-10,调和平均数是 -inf std::abort(); //运行到这儿直接退出 所以不会显示下面bye的那句 &#125; return 2.0 * a * b / (a+b);&#125;int main()&#123; std::cout&lt;&lt; &quot;输入俩数以计算调和平均数:&quot;; double x, y, z; while(std::cin &gt;&gt;x &gt;&gt; y) &#123; z = hmean(x,y); std::cout&lt;&lt; x &lt;&lt;&quot; 和 &quot;&lt;&lt; y &lt;&lt; &quot; 的调和平均数是 &quot; &lt;&lt; z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;输入任意按回车退出&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;bye 再次按回车退出.&quot;; return 0;&#125; 异常机制对于异常的处理有三个部分: 引发异常(throw) 使用处理程序捕获异常(catch) 使用 try 块(try) throw关键字表示引发异常,紧随其后的值(如字符串或对象)指出异常的特征;catch关键字表示使用异常处理程序(exception handler)捕获异常,括号内的表示异常要处理的类型,花括号内的表示遇到异常所采取的措施,虽然catch长的像个自带定义的函数,然而他并不是.try关键字表示其中的代码可能会出现异常,他后面一般跟着一个或多个catch. 如码所示:1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;double hmean(double a, double b)&#123; if(a == -b) throw &quot;异常:这俩数有毛病&quot;; //异常被触发 return 2.0 * a * b /(a + b);&#125;int main()&#123; double x , y, z; cout &lt;&lt; &quot;请输入俩数: &quot;; while(cin &gt;&gt; x &gt;&gt; y) &#123; try &#123; z = hmean(x,y); //try块里的表示需要注意这些代码可能触发异常 &#125; catch (const char * s)&#123; //捕捉到异常 程序跳到这儿 发现char类型与 throw后面的字符串匹配 cout &lt;&lt; s &lt;&lt; endl; //匹配之后执行代码块内的代码处理异常 cout &lt;&lt; &quot;请重试: &quot;; continue; &#125; cout &lt;&lt; x &lt;&lt; &quot; 和 &quot; &lt;&lt; y &lt;&lt; &quot; 这俩数的调和平均数是: &quot; &lt;&lt; z &lt;&lt; endl; cout &lt;&lt; &quot;输入任意字符串退出: &quot;; &#125; cout &lt;&lt; &quot;bye,再按回车退出&quot; &lt;&lt; endl;&#125; 现在假设异常被触发,hmean()引发异常,被引发的异常是常量字符串:”异常:这俩数有毛病”,于是throw终止函数hmean()的执行,沿着函数调用序列往后查找,发现hmean()函数是从main()中的try块中调用的,于是throw把控制权返回给main函数,程序将在main里寻找与引发的异常类型所匹配的异常类型处理程序(说白了就是找参数类型跟throw后面的类型一样的catch块),程序找到唯一匹配的参数为char* 的catch块:类似下面的12345catch (const char * s)&#123; //捕捉到异常 程序跳到这儿 发现char类型与 throw后面的字符串匹配 cout &lt;&lt; s &lt;&lt; endl; //匹配之后执行代码块内的代码处理异常 cout &lt;&lt; &quot;请重试: &quot;; continue;&#125; 于是,程序吧字符串:”异常:这俩数有毛病”赋值给s,然后执行catch(const char* s)内的代码.如果函数引发了异常而没有try块或没有匹配的catch时程序将调用abort()函数 将对象作用异常类型通常,引发异常的函数将传递一个对象,这就可以通过不同的异常类型来区分不同的函数在不同的情况下引发的异常,另外对象可以携带信息,同时catch块可以根据这些信息来决定采取什么样的措施.请查看具体代码举个栗子:12345678910111213void hmean(int a, int b) &#123; if(...) throw _Error(a,b); //你就假装_Error是个构造函数并且异常被触发,此时调用构造函数初始化对象并存储参数;&#125;try&#123; hmean(2,3); //这是个可能触发异常的函数&#125;catch (_Error &amp; e)&#123; e.mesg(); //你就假装这里是调用了_Error类的消息输出方法并告诉你代码有毛病了;&#125; 异常规范和C++11C++98新增了一种不受待见(最好别用这玩意)的异常规范(exception specification),他长这样:12double harm(double a) throw(bad_thing); //可能会抛出bad_thing异常double marm(double) throw(); //不会抛出异常 throw()部分就是异常规范,他可能出现在函数原型和函数定义中,他可以包含类型列表.这玩意的作用之一是告诉用户可能需要使用try块(然而直接写注释更方便),另一作用是让编译器添加执行运行阶段的代码,使劲检测是否违反了异常. C++11资呲一种特殊的异常规范,使用noexcept指出函数不会引发异常,不过对于这个还是存在争议的:1double marn() noexcept; //marn() 不会抛出异常 栈解退其实一张图就可以解释栈解退不过我还是要哔(chao)哔(xi)两句 假设try块没有直接调用引发异常的函数,而是调用了对引发异常函数进行调用的函数,则程序将从引发异常的函数直接跳到包含try块的函数. C++是如何处理函数的调用和返回的? 程序将调用函数的指令的地址(返回地址)放到栈中.当被调用的函数执行完毕之后程序将通过地址来确定从哪里开始继续执行.函数调用将函数参数也放到了栈中,他们被视为自由变量,如果被调用的函数又调用了另一个函数,那么后者的信息也会被添加到栈中,以此类推.当函数结束时,程序流程将跳到调用函数时储存的地址处(也就是返回到调用他的那个函数里),同时栈顶元素被释放,以此类推.并在结束时释放自由变量,如果自动变量是类对象,那么他的析构函数将被调用(如果有析构函数的话). 现在假设异常被触发(程序终止),则程序也将释放栈中的内存,但不会在释放栈的第一个返回地址后停止,而是继续释放栈,直到找到一个位于try块中的返回地址才停止.随后控制权将转到块尾的catch里,而不是调用函数后面的第一条语句,这个个过程被称为栈解退. 然而栈解退有个和函数返回一样的特征. 对于栈中的自动类型对象,类的析构函数将被调用.不同的是,函数返回仅仅处理放在栈中的对象,而throw则是处理try块和throw之间整个函数调用序列放在栈中的对象. 如果没有栈解退这种特性,则引发异常后,对于中间函数调用放在栈中的对象,他们的析构函数不会被调用. (现在上图: throw 与 return","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-友元类","date":"2017-03-05T15:07:46.000Z","path":"2017/03/05/C++笔记-友元类/","text":"类并非只能拥有友元函数还可以将类作为友元,友元被赋予从类外访问类的私有部分的权限,在这种情况下,友元类的所有方法都可以访问原始类的公有/私有/保护成员,也能指定特定的成员函数为一个类的友元. 什么时候希望一个类成为另一个类的友元? 书上举得一个栗子:完整代码 假设编写一个模拟遥控器和电视机的程序,决定有TV和Remote类表示电视机和遥控器,显然这两个类存在着某种关系(净说废话).但电视机不是遥控器,反之亦然,所以正常的公有继承is-a关系并不适用.遥控器并非电视机的一部分.所以,包含私有和保护集成的has-a关系也不适用.但众所周知遥控器可以改变电视机的状态.这说明遥控器应该是电视机类的一个友元. 友元的声明:友元声明可以位于公有,私有或者保护部分,所在其位置无关紧要.但由于Remote类提到了TV类所以必须先定义Tv类,或者使用前向声明.这样来声明一个友元类:1friend class Remote; 1234567891011121314151617181920212223242526272829303132333435363738394041class Tv&#123;public: friend class Remote; enum&#123;off,on&#125;; enum&#123;MinVal,MaxVal = 20&#125;; enum&#123;Antenna,cable&#125;; enum&#123;tv,dvd&#125;; Tv(int s = off,int mc = 125):state(s),volume(5), maxchannel(mc),channel(2),mode(cable),input(tv)&#123;&#125; void onoff()&#123;state = (state == tv) ? off: on;&#125; bool ison() const &#123;return state == on;&#125; bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode()&#123;mode = (mode = Antenna) ? cable: Antenna;&#125; void set_input()&#123;input = (input = tv) ? dvd : tv;&#125; void settings() const;private: int state; int volume; int maxchannel; int channel; int mode; int input;&#125;;class Remote&#123;private: int mode;public: Remote(int m = Tv::tv):mode(m)&#123;&#125; bool volup(Tv &amp; t)&#123;return t.volup();&#125; bool voldown(Tv &amp;t)&#123;return t.voldown();&#125; void onoff(Tv &amp; t)&#123;t.onoff();&#125; void chanup(Tv &amp;t)&#123;return t.chanup();&#125; void chandown(Tv &amp;t)&#123;return t.chandown();&#125; void set_mode(Tv &amp;t)&#123;return t.set_mode();&#125; void set_input(Tv &amp;t)&#123;return t.set_input();&#125; void set_chan(Tv &amp;t, int c)&#123;t.channel = c;&#125;&#125;; 从上面的从书中摘抄的毫无诚意的代码中可以看出,所有的Remote方法都是Tv类的友元,似乎Remote类除了构造函数都使用了Tv类的公有接口,但是事上唯一直接访问了Tv类成员的Remote类方法是Remote::set_chan(),那么就可以选择仅特定的类成员成为另一个类的友元.但这样就要小心的排列声明和各种定义;让Remote::set_chan()成为Tv类的友元的方法是,在Tv类声明中将其定义为友元: 123class Tv&#123; friend void Remote::set_chan();&#125; 就酱,但是吧……编译器要处理这句话首先得知道Remote的定义,不然编译器不知道Remote是个类,所以这就要把Remote类的声明挪到Tv类声明前面,但Remote类用了Tv对象..这就又得把Tv类定义挪到Remote类定义前面去.咦等等.那Remote咋办他需要在Tv类的前面啊.这..这就很尴尬了,呐,避免这种死循环的方法是使用 前向声明(forward declaration):123class Tv ; //前向声明class Remote&#123;...&#125;class Tv&#123;...&#125;; 那能不能这样?:123class Remote;class Tv&#123;...&#125;;class Remote&#123;...&#125;; 这是不行的,在编译器在Tv类中的声明中看到Remote类的一个方法称为Tv类的友元之前,该先让编译器看到Remote类的声明和Remote::set_chan()函数的声明. 好了,但在Remote类中可以看到,有些方法包含了内联代码,例如: void onoff(Tv &amp; t){t.onoff();}由于它使用了一个Tv的方法,所以在此之前编译器必须看到Tv类声明,但是Tv类在Remote类后面声明..解决方法就是把函数定义放在Tv类之后就成.. 吼,现在只有一个Remote方法是Tv类的友元了; 编译器一开始通过前向类型得知了Tv是个类,在读取声明并编译了这些方法之后,使用lnline关键字仍然可以使Remote类未定义的函数称为内联方法.完整代码 其他友元关系遥控器能影响电视.现在你想通过电视对遥控器产生某种影响,这可以让类彼此成为对方的友元来实现; 需要记住的是对于使用Remote类对象的Tv方法,其 函数原型 可以在Remote类声明之前声明,但必须在Remote类之后定义,这样编译器才有足够的信息来编译该方法.12345678910111213class TV&#123;friend class Remote;public: void buzz(Remote &amp; r); ...&#125;;class Remote&#123; friend class Tv; public: void bool volup(Tv $ r)&#123;t.volup();&#125;&#125;;inline void Tv::buzz(Remote &amp; r)&#123;...&#125; 由于Remote声明在Tv后面,所以可以在类声明中定义volup();buzz()可以再Tv中声明,但必须在Remote后面定义; 共同友元函数需要访问两个类的私有数据,函数可以是一个类的成员,另一个类的友元; 也可以是两个类的友元:12345678910111213class A; //前向声明class B &#123; friend void fun(A &amp; a,const B &amp; b); //编译器发现前向类型A 得知A是一个类型 friend void fun(B &amp; b,const A &amp; a);&#125;class A&#123; friend void fun(A &amp; a,const B &amp; b); friend void fun(B &amp; b,const A &amp; a);&#125;//定义友元函数inline void fun(A &amp; a,const B &amp; b)&#123;...&#125;inline void fun(B &amp; b,const A &amp; a)&#123;...&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-嵌套类","date":"2017-03-04T15:04:38.000Z","path":"2017/03/04/C++笔记-嵌套类/","text":"封面来源 在(quan)神(shi)奇(keng)的C++中,放在另一个类中声明的类被称为嵌套类(nested class),它通过提供新的类型类作用域来避免名称混乱.包含类的成员和函数可以创建和使用被包含类的对象; 仅当嵌套类声明位于包含类的公有部分时,才可以在包含类外通过作用域解析运算符使用嵌套类; 不不不,这个和包含不一样,包含是将一个类的类对象作为另一个类的类成员; 而嵌套类则是定义了一种类型且仅在包含嵌套类声明的类中有效 12345678910//在包含类的私有部分声明了个嵌套类class Queue&#123;private: class Node &#123; public: Node(); &#125;&#125; 使用两次作用域解析运算符就可以定义Node()辣:1Queue::Node::Node()&#123;...&#125; 嵌套类和访问权限如果嵌套类是在另一个类的私有部分声明的,则只有包含他的类知道他的存在,且对于从包含类派生出来的类来讲,因为派生类不能直接访问基类私有部分,所以嵌套类也是不可见的. 如果嵌套类是在另一个类的保护部分声明的,则对于包含他的类来说是可见的,而对于外部来讲嵌套类是不可见的,但后者的派生类可以直接创建这种类对象. 如果嵌套类是在另一个类的公有部分声明的,因为他是公有的,则对于包含他的类,对与包含他的类的派生类以及外部世界都可以使用它. 访问控制在Queue类中声明Node类并没有赋予Queue类任何访问权限,Node也没有赋予Queue任何访问权限,所以Queue只能显示的访问Node成员,所有我将Noede类所有成员声明为公有,不过没关系,虽然Queue的方法可以直接访问Node类,但被Queue声明为私有的Node对于外部来讲是不可见的. 模板类中的嵌套(并不会发生什么奇怪的问题; 完整代码","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-成员模板&将模板用作于参数","date":"2017-01-08T15:43:01.000Z","path":"2017/01/08/C++笔记-成员模板&将模板用作参数/","text":"模板成员:模板类将另一个模板类和模板函数作为其成员1234567891011121314151617181920212223template &lt;typename T&gt;class beta&#123;private: template&lt;typename V&gt; class miao &#123; private: V val; public: miao(V v = 0) : val(v)&#123;&#125; void show() const &#123;cout &lt;&lt; val &lt;&lt; endl;&#125; V value() const &#123;return val;&#125; &#125;; miao&lt;T&gt; q; miao&lt;int&gt; n;public: beta(T t, int i) : q(t),n(i) &#123;&#125; template &lt;typename U&gt; U blab(U u,T t) &#123;return ((n.value() + q.value()) * u/t);&#125; void bshow() const &#123;q.show(); n.show();&#125;&#125;; 12hold&lt;T&gt; q;hold&lt;int&gt; n; n 是基于int 类型的hold 对象,q 的基于T 类型的hold 对象,下述声明使得T表示的是double,因此q 的类型是 hold&lt; double&gt;:1beat&lt;double&gt; guy(10,2.5); blab() 方法的U 类型由该方法被调用时的参数决定,T 类型由对象的实例化决定,下述例子中,guy 的声明将T 类型设置为double,U 的类型则为int.1cout&lt;&lt;guy.blab(10,2.5); 虽然混合类型所引起的自动类型转换导致blab() 函数中的计算以double 类型进行,但返回值的类型为U (即int),因此上述输被截断为28. 如果使用guy.blab()时,使用10.0代替10,那么U 的类型将会设置为double ,使得返回值也为double,因此输出为28.2608. 将模板类用作参数模板类可以包含类型参数(如 typename T )和非类型参数(如 int ),还可以包含本身就是模板的参数. 举个书上的栗子:12345678910111213141516171819202122232425262728293031template&lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;private: Thing&lt;int&gt; s1; Thing&lt;double&gt; s2;public: Crab()&#123;&#125; bool push(int a,double x)&#123; return s1.push(a) &amp;&amp; s2.push(x);&#125; bool pop(int &amp; a,double &amp; x)&#123;return s1.pop(a) &amp;&amp; s2.pop(x);&#125;&#125;;int main()&#123; Crab&lt;Stack&gt; cs; int ni; double nd; cout &lt;&lt; &quot;Enter int double pairs,such as 4 3.5(0 0 to end):&quot; &lt;&lt; endl; while (cin &gt;&gt; ni &gt;&gt;nd &amp;&amp; ni &gt; 0 &amp;&amp; nd &gt; 0) &#123; if(!cs.push(ni,nd)) break; &#125; while(cs.pop(ni,nd)) cout &lt;&lt; ni &lt;&lt; &quot; , &quot; &lt;&lt; nd &lt;&lt; endl; cout &lt;&lt; &quot;DONE&quot; &lt;&lt;endl; return 0;&#125; 12template &lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;&#125; 如上, 上述模板参数类型为template &lt; typename T&gt; class Thing,其中Thing 为参数. 这意味着为了使 Crab&lt; King&gt; legs 被接受,模板类参数King 必须是个模板类:12template &lt;typename K&gt; class King&#123;...&#125; legs 声明将用King&lt; int&gt; 替换 Thing&lt; int&gt; ,用 King&lt; double&gt; 替换 Thing&lt; double&gt;,但是在下面的代码中就有所不同. 在Crab 类中,有两行代码声明了两个类对象:12Thing&lt;int&gt; s1;Thing&lt;double&gt; s2; 而mian 函数中包含以下声明,因此,Thing&lt; int&gt; 将被实例化为 Stack&lt; int&gt; ,而Thing&lt; double&gt;将被实例化为Stack&lt; double&gt;.总之,模板参数Thing 将被替换为声明Crab 对象时被用作模板参数的模板类型.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-模板的具体化","date":"2017-01-06T11:32:50.000Z","path":"2017/01/06/C++笔记-模板的具体化/","text":"隐式实例化:编译器在需要对象之前,不会生成类的隐式实例化12ArrayTp&lt;int,100&gt; * pt; //不生成实例pt = new ArrayTp&lt;int,100&gt;;//现在生成实例 显式实例化:使用关键字template并指出所需类型来声明类的时候,编译器将生成类声明的显式实例化:1template class ArrayTp&lt;string,100&gt;; 在这种情况下,虽然没有创建类对象,编译器也将生成类,包括方法定义. 显式具体化:(显式具体化==特型)在需要特殊要求的时候对模板进行修改,使其行为不同,这时可以创建显式具体化. 书上举的栗子:假设现在定义一个表示排序后数组的类:1template &lt;typename T&gt; class SortedArray&#123;...&#125; 假设模板使用&gt;运算符来对值进行比较,对于数字来说没毛病,对于类型T,只要定义了T::operator&gt;(),也没毛病,但是T如果是个const char **的字符串就不行了,因为这需要使用strcmp(),而不是&gt;*.这种情况下可以提供一个现实模板具体化.格式如下:1template &lt;&gt; class Classname &lt;specialized-type-name&gt;&#123;...&#125; 当具体化模板和通用模板都与实例化请求匹配时,编译器将使用具体化模板. 所以说要使用const char 类型的SortedArray*模板可以这么写:1template &lt;&gt; class SortedArray&lt;const char *&gt; &#123;...&#125; 这样在使用const char **类型的SortedArray*模板时将使用上述专用定义而不是用通用模板定义. 部分具体化:部分具体化可以给类型参数制定具体的类型:12template &lt;class T1, class T2&gt; class Pair&#123;...&#125;;template &lt;class T1&gt; class Pari&lt;class T1,int&gt;&#123;...&#125;; template后面的是没有被具体化的类型参数.上述T2被具体化为int,但T1不变. 部分具体化特型使得能够设置各种限制,例如:12345678//一般模板template&lt;typename T1,typename T2,typename T3&gt;class Trio&#123;...&#125;//对T3具体化的模板template&lt;typename T1,T2&gt; class Trio&lt;T1,T2,T3&gt;&#123;...&#125;//对T2,T3具体化的模板template&lt;typename T1&gt; class Trio&lt;T1,T2*,T3*&gt;&#123;...&#125; template 后面的是没有被具体化的类型参数 给出上述定义编译器将作出如下选择:123Trio&lt;int,double,string*&gt; T1; //使用一般模板Trio&lt;int,short&gt; T2; //使用对T3具体化的模板Trio&lt;string,string*,char*&gt;;//使用对T2,T3具体化的模板","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-多重继承","date":"2016-12-30T11:31:05.000Z","path":"2016/12/30/C++笔记-多重继承/","text":"必须使用关键字来限定每一个基类,不然编译器会默认成私有派生:1class mylove : public string, valarray&lt;double&gt; //valarray为私有继承 其实你不用看这仨奇葩类的123456789101112131415161718192021222324252627282930313233343536373839404142class Worker&#123;public: Worker() : name(&quot;NULL&quot;),id(0L)&#123;&#125; Worker(const string &amp; s,long n) : name(s),id(n)&#123;&#125; virtual ~Worker() = 0; virtual void Set(); virtual void Show() const;private: string name; long id;&#125;;class Waiter : public Worker&#123;public: Waiter() : Worker(),panache(0)&#123;&#125; Waiter(const string &amp; s, long n, int p = 0) : Worker(s,n),panache(p)&#123;&#125; Waiter(const Worker &amp; w, int p) : Worker(w),panache(p)&#123;&#125; void Set(); void Show() const;private: int panache;&#125;;class Singer : public Worker&#123;public: Singer() : Worker(),voice(other)&#123;&#125; Singer(const string &amp; s, long n, int v = other) : Worker(s,n),voice(v)&#123;&#125; Singer(const Worker &amp; w, int v =other) : Worker(w),voice(v)&#123;&#125; void Set(); void Show() const;protected: enum&#123;other,alto,contralto,soprano,bass,baritone,tenor&#125;; enum&#123;Vtypes = 7&#125;;private: static char* pv[Vtypes]; int voice;&#125;; Worker?从Singer和Waiter共有派生出SingingWaiter:1class SingingWaiter : public Singing, public Waiter&#123;...&#125; 但这将出现二义性,因为Singing和Waiter都继承了一个Worker:12SingingWaiter sw;Worker* pw = sw; //二义性,鬼知道这时候用哪个worker so..应该使用类型转换来指定对象:123Worker* pw = (Singing*) &amp;sw;Worker* pw2 = (Waiter*) &amp;sw;//不过下面还有更简(ma)单(fan)的虚基类可以解决该问题 虚基类虚基类使得从多个类(他们基类相同)派生出的对象只继承一个基类对象.例如:在类声明中使用关键字virtual,可以使Worker被作用Singer和Waiter的虚基类:12class Singer : virtual public Worker&#123;...&#125;class Waiter : public virtual Worker&#123;...&#125; //这么写也行 然后 SingingWaiter可以定义为:1class SingingWaiter : public Singer,public Waiter&#123;...&#125; 现在SingingWaiter类只有一个Worker对象副本了,Singer和worker共享一个Worker对象,所以现在可以使用多态了. 新的构造函数规则使用虚基类时,构造函数需要使用一种新的方法,这是因为C++在基类是虚的时,禁止信息通过中间自动传递给基类,编译器在这时会使用基类的默认构造函数. 12345678910111213//通过中间类自动传递:class A&#123; int a; A(int n = 0) : a(n);&#125;class B :public A&#123; int b; B(int a = 0, int bm = 0) : A(a),b(bm);&#125;class C : public B&#123; int c; C(int a = 0, int b = 0, int cm = 0) : B(a,b),c(cm);&#125; 使用虚基类时我们必须显示调用构造函数:1234567SingingWaiter(const Worker &amp; wk,int p = 0,int v = Singer::other) :Worker(wk),Waiter(wk,p),Singer(wk,v)&#123;&#125; //显示使用worker SingingWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other) :Waiter(wk,p),Singer(wk,v)&#123;&#125; //错误的示范,会调用Worker的默认构造函数 对于非虚基类,显示调用Worker(const Worker&amp;)是非法的 哪个方法?那么问题来了,我们打算在SingingWaiter中重定义Show方法,并用SingingWaiter对象调用继承的Show方法:12345//所以我傻不愣登的写下了如下代码:SingingWaiter aha(&quot;喵喵&quot;,2017,1,soprano);aha.Show(); //二义性,Worker和Singer都有Show() 鬼知道这个是哪个?aha.Singer::Show(); //然而可以用作用域解析运算符来确定 最好是使用模块化:12345678910111213141516171819Woeker::Data() const &#123; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name; cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id;&#125;Waiter::Data() const&#123; cout &lt;&lt; &quot;panache: &quot; &lt;&lt; panache &lt;&lt; endl;&#125;Singer::Data() const&#123; cout &lt;&lt; &quot;rating: &quot; &lt;&lt; pv[voice] &lt;&lt; endl;&#125;SingingWaiter::Data() const&#123; Worker::Data(); Singer::Data();&#125;SingingWaiter::Show() const&#123; Worker::Data(); Data();&#125;//就是.........有点麻烦...","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"Hello World!!","date":"2016-12-27T13:49:34.066Z","path":"2016/12/27/hello-world/","text":"喵喵喵 本人的渣渣博客 以后就在这里撒欢辣 写的比较傻逼~ 大神轻喷呐 如有错误还劳驾指出哦~ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"C++笔记-私有继承","date":"2016-12-23T16:17:20.000Z","path":"2016/12/24/C++笔记-私有继承/","text":"使用私有继承,基类的共有成员以及保护成员都将成为派生类的私有成员派生类不继承基类的接口,但能在派生类的成员函数中使用它们,私有继承特征与包含相同:不继承接口,继承实现.所以它可以用来实现has-a关系. 示例:123456class player : private string,private valarray&lt;double&gt;//使用多个基类:多重继承&#123; public: ...&#125; 在这里新版本的构造函数将使用初始化成员列表,使用类名而不是使用成员名来标识构造函数: 12player::player(const char* str,const double* p,int i) : string(str),valarray&lt;double&gt;(p,i)&#123; &#125; 保护继承1class player : protected string,protected valarray&lt;double&gt;&#123;...&#125; 保护继承时,基类的公有成员和保护成员都将成为派生类的保护成员.使用私有继承时,第三代类将不能使用基类的接口,这是因为基类的公有方法在派生类中将变成私有方法.使用保护继承时,基类的公有方法将在二代类中变成受保护的,所以第三代类可以使用它们. 使用using重定义访问权限使用保护派生或者私有派生时,基类的公有继承将成为保护或者私有成员,如果想让基类方法在类外使用可以定义一个使用该基类方法的派生类方法.1234//派生类player希望使用基类valarray类的sum方法double player::sum() const &#123; return valarry&lt;double&gt;::sum();&#125; 或者可以使用using声明:123456class player : private valarray&lt;double&gt;&#123; public: using valarray&lt;double&gt;::min; using valarray&lt;double&gt;::max;&#125; 他们就像player类的共有方法一样:1cout &lt;&lt; &quot;high score:&quot; &lt;&lt; a[i].max &lt;&lt; endl; 注意 using声明只使用成员名,没有特征标,圆括号,返回类型,例如要在player]类中使用valarray类的operator[]方法,只需包含:1using::valarray::operator[]; 通常使用包含来建立has-a关系;如果新类需要访问原有类的保护成员,或需要重新定义虚函数应使用私有继承","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-包含类对象的成员","date":"2016-12-23T14:19:08.000Z","path":"2016/12/23/C++笔记-包含类对象的成员/","text":"接口和实现 使用公有继承时,类可以继承接口,可能还有实现(基类的纯虚函数提供接口,但不提供实现),获得接口是is-a的关系组成部分.而是用组合,类可以获得实现不继承接口是has-a的关系组成部分. 错误的示范:1234567891011121314class player&#123;private: string name; valarray&lt;double&gt; source; ostream &amp; arr_out(ostream &amp; os) const;public: player():name(&quot;NULL&quot;),source()&#123;&#125; explicit player(const string &amp; s) :name(s),source()&#123;&#125; explicit player(int n) :name(&quot;NULL&quot;),source(n)&#123;&#125; player(const string&amp; na, int n) :name(na),source(n)&#123;&#125;&#125;; 12player mylove(&quot;YSY&quot;,10);mylove = 5; //喵喵喵??重置ArrayD为五个空值的元素? mylove = 5;这里应该是:mylove[5] = 5才对.如果没有写explicit,编译器将调用转换构造函数player(5),name 的默认值将是NULL,并且编译器将会生成一个临时对象,并用临时对象替换mylove原有的值,这并不是我们想要的.如果加了explicit,编译器会报错这对我们debug很有利.毕竟在编译期出错优于在运行期出错.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-类设计总结","date":"2016-12-21T14:57:57.000Z","path":"2016/12/21/C++笔记-类设计总结/","text":"默认构造函数:默认构造函数要么没有参数,要么所有参数都有默认值.在派生类构造函数初始化列表中记得显示调用基类构造函数,否则编译器将会使用基类的默认构造函数,这可能会出现错误. 复制构造函数:1classname(const classname &amp;) 在按值传递,安置返回对象,编译器生产临时对象,将新对象初始化为一个同类对象的时候,将调用复制构造函数. 赋值运算符: 1classname &amp; operator=(const classname &amp;) 用于处理同类对象间的赋值,如果希望处理string类与classname类的赋值可以写成:1classname &amp; operator=(const string &amp;) 析构函数:当对象过期时,析构函数负责清理工作(如释放内存),对于基类应该提供一个虚析构函数,即使他不需要. 转换构造函数:1classname(const schar *) 使用一个参数的构造函数他定义了从参数类型到类类型的转换(话说这个中文名跟转换函数就差了两个字,但不一样容易弄混). 123Star(const char*);Star a = Star(&quot;233&quot;);a = &quot;233&quot;; 第二/三句话将会调用Star::operator(const Star &amp;)并使用Star(const char)生成一个对象,该对象将作用于赋值运算符函数的参数. 使用转换构造函数时候时建议使用explicit禁止隐式转换* 按值传递对象与传递引用通常在编写以对象作为参数的函数时,应该按引用,不应该使用按值传递参数,一是为了效率,二是因为在继承使用虚函数时,基类使用引用参数的函数可以接受派生类. 返回对象与返回引用如果函数返回的是通过引用或指针传递给他的对象,则应该按引用返回对象.返回引用可以节约内存和时间,与按引用传递相似,调用与被调用函数使用同一个对象进行操作.但不总是可以返回引用,比如函数不能返回一个在函数中创建的临时变量的引用,因为当函数结束时临时变量将会消失,这时候应该返回对象. const123456789classname::classname(const char * s) //确保方法不修改参数classname::show() const; //确保方法不修改调用他的对象,这里的const表示const classname * this,this指向调用的对象const classname&amp; classname::fun(const classname &amp; cn) const&#123; if(s.total &gt; total) return s; else return *this;&#125;;//该方法返回cn/this的引用,但因为cn/this是const,所以方法不能对cn/this进行修改,这意味着返回类型也必须为const 共有继承要考虑的因素:is-a关系is-a为”是一个”的意思,如果派生类不是某种特殊的基类则不要使用,比如从大脑类派生出程序员类.is-a关系的标志之一是:无需进行显示转换即可将积累指针或引用指向或引用派生类对象(向上强制类型转换).反之是可能出现错误的. 赋值运算符将派生类赋值给基类对象:123456class ZheXue &#123;...&#125;//基类-哲♂学class GaoBiLi : public ZheXue&#123;...&#125;//派生类-搞♂比♂利ZheXue bili;GaoBiLi fuc;bili = fuc; 1bili = fuc; 这将转化为: bili.operator=(fuc)他将调用 ZheXue::operator=(const ZheXue &amp;); 那如果将基类赋值给派生类对象呢:1fuc = bili; 这将转化为fuc.operator=(bili) ; 他将调用 GaoBiLi::operator=(const GaoBiLi &amp;);然而,派生类引用不能自动引用基类对象.除非我们定义转换构造函数:GaoBiLi(const ZheXue &amp;) ;转换构造函数可以有一个类型为基类的参数和其他参数,但其他参数必须有默认值: 1GaoBiLi(const ZheXue &amp; zx,string &amp; na = &quot;比♂利♂王&quot;,string &amp; ty = &quot;森之♂妖精&quot;); 这样转换构造函数会根据bili来创建一个临时对象,然后把它作为赋值运算符的参数.然而还可以直接写个参数为ZheXue的赋值运算符函数….: 1GaoBiLi::operator=(const ZheXue &amp;)&#123;......&#125;; 私有成员与保护成员对于外界来说,只能用共有成员来访问二者,对于派生类来说,可以直接访问基类的保护成员,而私有成员仍要通过基类的成员函数来访问. 虚方法如果要在派生类中重定义基类的方法则应该使用virtual. 析构函数基类的析构函数应当是虚的.这样在使用指针或者引用删除派生对象时,程序会先调用派生类的析构函数然后调用基类的,而不会只调用基类的析构函数 友元函数友元函数并非类成员因此不能继承,如果希望派生类函数能使用基类的友元函数,可以使派生类指针或引用强制转换为基类的指针或引用,然后使用转换后的指针或引用来调用友元函数. 123456ostream &amp; GaoBiLi::operator&lt;&lt;(ostream &amp; os, GaoBiLi &amp; gbl)&#123; os &lt;&lt; (const ZheXue &amp;)gbl; os &lt;&lt; &quot;name:&quot; &lt;&lt; gbl.name &lt;&lt; endl; return os;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-继承和动态内存分配","date":"2016-12-15T14:01:19.000Z","path":"2016/12/15/C++笔记-继承和动态内存分配/","text":"如果基类使用动态内存分配，派生类不使用1234567891011121314151617class player&#123; privatec: string * name; bool sex; public： player(const string &amp; na = &quot;NULL&quot;,bool a = 0); player(const player &amp; p); virtual ~player(); player &amp; operator=(const player &amp; p);&#125;class ship : public player&#123; private: int age; public: ...&#125; 那么是否要为ship类定义显示析构函数,复制构造函数,重载赋值运算符呢? 不需要. 析构函数: 对于ship类,我们没有对他进行任何特殊的操作,所以默认的析构函数是合适的 复制构造函数:首先我们知道的是,默认复制构造函数是执行成员复制,因为player使用了动态内存分配,所以,默认复制构造函数不适用于player类,但对于ship类是适合的.当复制继承的组件获或者成员时,则使用他的复制构造函数.所以当ship的默认复制构造函数会使用player的默认复制构造函数来复制ship里的player对象.所以默认复制构造函数对于他们来说是合适的. 赋值运算符: ship默认的赋值运算符也会使用player的赋值运算符来对player成员进行赋值,所以是合适的. 如果基类和派生类都使用动态内存分配123456class ship : public player&#123; private: string * type; public: ...&#125; 在这种情况下必须显示定义派生类的显示析构函数,复制构造函数,重载赋值运算符. 析构函数: 派生类的析构函数先释放type所管理的内存,然后基类析构函数释放name所管理的内存. 复制构造函数:派生类的复制构造函数只能访问派生类的数据,所以他必须调用父类的复制构造函数.ship::ship(const ship &amp; p) : player(p) , 因为player类因为复制构造函数有一个player&amp;参数,而基类可以指向派生类型,因此player的复制构造函数将使用ship参数的player部分来构造新对象的player部分. 赋值运算符:因为派生类采用动态内存分配,所以他需要一个显示赋值运算符.ship的赋值运算符只能直接访问ship类的数据,但他却要负责所继承的基类对象的赋值,这个时候可以显示调用基类的赋值运算符方法.然后在处理派生类的赋值.1234567ship &amp; ship::operator=(const player &amp; p)&#123; if(this == p) return *this; player::operator=(p);//显示调用基类赋值运算符 delete type; type = new string; type = p.type;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-抽象基类(Abstract-Base-Class,ABC)","date":"2016-12-14T15:46:31.000Z","path":"2016/12/14/C++笔记-抽象基类(Abstract-Base-Class,ABC)/","text":"啥时候使用抽象基类?在下理解的是:你有一个基类和一个该基类的派生类,但是基类里有一些你派生类根本用不上的方法,使用了派生类就会导致一些信息冗余.然而不继承基类单独写个类你发现效率也不高,而且你发现你的基类和你的派生类之前还是有共同点的..这个时候就要上抽象基类了….把其共同点放到抽象基类里,然后分别从抽象基类派生刚才的”基类”与”派生类”. 啥是抽象基类 就是类里定义了纯虚函数的类………然而定义了纯虚函数就只能作为基类了.23333 纯虚函数纯虚函数:virtual 返回类型 函数名(形参) =0;在虚函数声明后面加个 =0 就是纯虚函数了,当类声明中包含纯虚函数的时候,则不能创建该类对象.所以包含纯虚函数的类只能作为基类,在原型中使用 =0 指出类是一个抽象基类,在类中可以不定义该函数.12345678class player&#123; private: int age; string name; pbulic: ... virtual void show() = 0;&#125; 总之: ABC描述的是至少使用一个纯虚函数的接口,从ABC派生出的类将根据派生类的具体特征使用常规虚函数来实现这种接口.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-访问控制protected","date":"2016-12-13T15:22:36.000Z","path":"2016/12/13/C++笔记-访问控制protected/","text":"protected关键字protected的意思是保护,和private有点相似,在类外只能通过共有类成员来访问protected中的成员.但他与private的区别体现在:在派生类中,派生类的成员可以直接访问基类的protected成员,但不能直接访问基类的private成员.举个栗子:12345678910111213141516class player&#123; ... public: void R18(int a)&#123; if(a&lt;18)cout &lt;&lt; &quot;禁止入内&quot;; else &#123;cout &lt;&lt; &quot;欢♂迎&quot;; &#125; protected: int age;&#125;class ship : public player&#123; ... public: void showshipage(int m)&#123; age = m; cout &lt;&lt; age &lt;&lt; &quot;欢♂迎&quot;;&#125;//通过派生类公有成员直接访问基类protected成员 ...&#125; 但是这样做是有点小问题的age成员被设置为只能通过player::R18()来访问,但是有了ship::showshipage()将会忽略player::R18()的禁止入内措施,这使得age变成了一个公有变量…….然而对于成员函数来,保护控制很有用,他可以让派生类访问一些公众不能访问的内部函数.so..你问我滋补滋磁,我是滋次的.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-静态联编和动态联编","date":"2016-12-11T15:38:53.000Z","path":"2016/12/11/C++笔记-静态联编和动态联编/","text":"一些理解性概念 啥是联编将源代码中的程序调用解释为执行特定的函数代码块被称为函数名联编在编译过程中的联编被称为静态联编在程序运行时的联编被称为静态连编 ##指针和引用类型的兼容性将派生类指针或引用转为基类指针或者引用被称为向上强制转换,如果是共有继承则不需要进行显式类型转换,任何对基类对象做的操作都适合派生类对象.相反,将基类指针或者引用转换为派生类指针或者引用被称为向下强制转换,需要显示类型转换,但是派生类可以新增成员函数,由于基类没有这些函数,这使得使用新增成员函数的类成员函数不能作用于基类.123456789101112131415161718192021222324class player&#123; pubilc: player(string &amp; na)&#123;name = na;&#125; void showname()const &#123;cout &lt;&lt; name;&#125; private: string name;&#125;class ship : pubilc player&#123; public: ... void shouage(int age); private: int age;&#125;player lex(&quot;lexington&quot;); ship * t =(ship*)&amp;lex; //将基类指针转化为派生类指针,必须显示类型转换,向下强制转换ship sar(&quot;saratoga&quot;);player* v = &amp;sar; //将派生类指针转化为基类指针,向上强制转换t-&gt;showage(20); //不安全的操作 showage不是player的成员v-&gt;showname(); //安全的 现在我们有个虚方法1234567891011121314``` void fr(player &amp; r) //r.sizhai(); void fp(player * p) //p-&gt;sizhai(); void fv(player v) //v.sizhai(); fun()&#123; player p(&quot;LEX&quot;); ship s(&quot;sar&quot;); fr(p); // player::sizhai(); fr(s); // ship::sizhai(); fp(p); // player::sizhai(); fp(s); // ship::sizhai(); fv(p); // player::sizhai(); fv(s); // player::sizhai(); &#125; 由于按值传递ship对象的player部分被传递给函数fv().但是引用和指针发生的向上强制转换分别为player对象和ship对象使用了不同的函数(virtual).隐式向上强制类型转换使得基类对象可以指向基类对象或派生类对象,因此需要动态联编. 虚函数和动态联编概念理解:虚函数工作原理通常,编译器处理虚函数的原理是:给每个对象添加一个隐藏成员,这个隐藏成员保存了一个指向函数地址数组的指针.它被称为虚函数表,虚函数表保存了类对象的虚函数地址.列如,基类对象包含一个指针,它指向基类中所有虚函数的地址表.派生类对象将指向一个独立地址表的指针,如果派生类里提供了虚函数的定义,那么这个独立的地址表将会保存新函数的地址,如果没提供,该表将使用原始版本的地址.如果派生类定义了新的虚函数,那么该函数的地址也会被添加到表中. 注意:无论类中有多少个虚函数,都只在对象中添加一个地址成员,只是大小有所差别 虚函数总结: 构造函数不能是虚函数; 析构函数应该是虚函数(除非不作为基类); 友元不能是虚函数,因为友元函数不是类成员; 如果基类声明被重载,则应在派生类中重定义所有的基类重载版本; 重定义不是重载,如果重定义继承的方法,应该确保与原型完全一致;注意:如果原返回类型是指向基类的指针或者引用,可以改成指向派生类的指针和引用,这被成为返回类型协变","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-一个简单的基类","date":"2016-12-08T13:58:54.000Z","path":"2016/12/08/C++笔记-一个简单的基类/","text":"从一个类派生出另一个类,原始类被称为基类,继承类被称为派生类例:1234567891011121314151617181920class player&#123; public: player(const string &amp; na,bool se = 1); void Name() const&#123;cout &lt;&lt; name &lt;&lt; endl;&#125; bool sex &#123;return sex;&#125; privat: string name; bool sex;&#125; class Ship : public player //继承了player类 公有派生&#123; public://派生类需要自己的构造函数并且必须使用基类的构造函数 Ship(bool mw = 0,int ag, const string &amp; na, bool se = 1); Ship(bool mw = 0,int ag,player &amp; p); int ShowAge() &#123;cout &lt;&lt; age; return age;&#125; private: bool myWife; int age;&#125; 冒号说明了Ship的基类是player,public表示了这个基类是公有基类,这被成为公有派生.使用公有基类,基类的公有成员将成为派生类的公有成员,基类的私有成员也将成为派生类的一部分但是不能直接访问,需要通过继承的基类的公有方法来间接访问.创建派生类对象的时候,首先创造基类对象,C艹使用成员列表初始化完成该工作:12345678910//在此声明成员列表初始化只能用于构造函数 Ship::Ship(bool mw, int ag,const string &amp; na,bool se) : player(na,se)&#123; mw = 1; ag = 18; &#125; Ship::Ship(bool mw,int ag,player &amp; p) : player(p)&#123; mw = 0; ag = 14; &#125; 在第二个构造函数中 由于基类类型为 player &amp; ,因此将会调用基类的复制构造函数,由于基类没有该函数,则编译器将会自动生成一个~基类对象首先被创建.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数 派生类和基类之间的特殊关系基类指针或引用可以在不进行显式类型转换的情况下,指向或引用派生类对象或引用.然而基类指针和引用只能用于调用基类方法.所以不能用它们来调用派生类方法,如果将基类对象和地址赋值给派生类引用和指针.因为派生类引用可以为基类对象调用派生类方法,但是基类没有派生类的成员所以这么做是没意义的.可以这么写:123456789Ship sp1(1,17,&quot;Lexington&quot;,0);player *a = &amp;sp1; //OKplayer &amp;b = sp1; //OKa.Name();b-&gt;Name();player sp2(&quot;Saratoga&quot;,0);Ship *c = &amp;sp2; //不能这么写Ship &amp;d = sp2; //也不能这么写 但是如果基类引用和指针可以指向派生类对象呢?12345678void Show(const player &amp; p)&#123; //OK p.Name();&#125;player temp1(&quot;LEX&quot;,0);Ship temp2(1,17&quot;SAG&quot;,0);Show(temp1); //OKShow(temp2); //OK 函数Show的形参为一个基类引用,他可以指向基类对象或者派生类对象,并且该函数使用了基类的一个方法,所以Show可以使用player参数或者Ship参数.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-多态公有继承","date":"2016-12-07T15:35:20.000Z","path":"2016/12/07/C++笔记-多态公有继承/","text":"虚方法:virtual该声明之处方法在派生类版本的行为不同.12345678910111213141516171819class You&#123;public: You(const string&amp; Na)&#123;Name = na;&#125; virtual string Show()&#123;return Name;&#125; ~You()&#123;&#125;private: string Name;&#125;class YouName : public You&#123;public:YouName()&#123;&#125;~YouName()&#123;&#125;virtual void Show()&#123;cout &lt;&lt; &quot;your name is &quot;; Name();&#125;&#125;You A(&quot;YSY&quot;); YouName B(&quot;YES&quot;);A.Name(); //You::Name()B.Name(); //YouNAme::Name(); 基类版本限定名为You::Show(),派生类限定名为YouName::Show()程序会根据使用对象类型来确定使用哪个版本. 需要注意的是如果方法是通过指针或引用调用的呢?程序将使用哪种方法? 如果没有使用关键字virtual,程序将根据引用类型或者指针类型来选择方法,如果使用了关键字virtual,程序将根据引用或指针指向的对象的类型来确定方法~","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-类和动态内存分配","date":"2016-12-07T13:59:20.000Z","path":"2016/12/07/C++笔记-类和动态内存分配/","text":"对于类中的非静态const数据成员,必须在执行到构造函数体前,级创建对象时进行初始化.他叫做成员列表初始化:123456789101112131415161718class FUN&#123; public: struct Node&#123;Item item;struct Node* next;&#125; Node* fornt; Node* rear; int items; const int qsize;&#125;FUN::FUN(int qs) : qsize(qs)&#123; front = rear = nullptr; items = 0;&#125;//然而这种方法不局限于常量 所以也可以这么写FUN::FUN(int qs):qsize(qs),rear(nullptr),front(nullptr),items(0)&#123;...&#125; 注意只有构造函数才可以使用这种方法,另外对于被引用的类成员也必须这么写: 123456class A&#123;...&#125;;class B&#123;private: A &amp; hello;&#125;B::B(A &amp; h) : hello(h)&#123;....&#125; 关于C++11的内存初始化直接这么写就行(那我们为啥要用第一种方法啊魂淡(｡•ˇ‸ˇ•｡)):1234class Classy&#123; int meml = 10; const int mem2 = 20;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"QML与C++交互","date":"2016-12-05T14:38:29.000Z","path":"2016/12/05/QT-QML与C++交互/","text":"图片作者为:Bison仓鼠终于搞定了gayhub的博客,以后就在这里写一些自己想写的东西好了 ╰(´︶`)╯ 前几天用QT的QML与C++交互,基于QMediaPlayer类撸了一个baka音乐播放器 因为是第一次用QML撸 再加上我幼儿园水平的代码 写的一团糟..代码请用鼠标♂插 这里 这个坑爹的QML与C++交互折腾了我好久 (╬▔▽▔)凸 以我这辣鸡播放器为例(大神请绕道orz) 那么问题来了如何使用C艹来控制QML?假设我们的qml是酱紫写的 1234567891011121314151617181920212223Rectangle &#123; id: head y: 0 width: parent.width height: 40 color: \"#222225\" opacity: 0.95 Layout.maximumHeight: 45 Layout.fillWidth: true Layout.fillHeight: false Text &#123; id: musicteitle x:5 y:5 width: parent.width height: 30 color: \"#C8C8C8\" font.family: \"microsoft yahei\" font.pixelSize: 23 text:\"正在播放: \" + myTITLE &#125; &#125; 让我们用这段代码来显示正在播放的某音乐的名字,细心的你可能发现了 你写这辣鸡玩意前面的我都能看懂 那个myTITLE是什么鬼?这里让我们隆重介绍一下QQmlContext这个神奇的类 : “QQmlContext类定义了一个QML引擎上下文引擎上下文允许将数据暴露给由QML引擎实例化的QML组件每个QQmlContext包含一组属性，与其QObject属性不同，它允许数据通过名称显式绑定到上下文。上下文属性通过调用QQmlContext :: setContextProperty（）来定义和更新” –power for 谷歌翻译 参照官网 于是我们可以酱紫来控制音乐的名字:123QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* title = view-&gt;rootContext();title-&gt;setContextProperty(\"myTITLE\",QVariant(NowMusicName)); 通过修改NowMusicName的值就可修改myTITLE的值 这俩东西是绑定的于是我们就可以通过C++来修改NowMusicName 从而修改QML中的myTITLE 进而达到显示出当前音乐名字的目的 那么 view是何方神圣? 官方文档: QQmlApplicationEngine QQmlApplicationEngine提供了从单个QML文件加载应用程序的方便方法。这个类结合了QQmlEngine和QQmlComponent来提供一个方便的方式来加载单个QML文件。它还向QML提供了一些中央应用程序功能，C++/QML混合应用程序通常会从C++控制 –power for 谷歌翻译 果冻,能不能给力点啊?(눈_눈) 你说的这么水 没人会看的好吧ಥ_ಥ 既然能从用C艹来艹QML 那自然也能用QML来艹C艹了 如何用QML来艹C艹?假设我们现在有个音乐类Music 我们想通过点击某个按钮来调用Music类的暂停函数 那么如何实现呢?这个就相对的比较简单了123456//main.cpp如下Music A;QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* context = view-&gt;rootContext();context-&gt;setContextProperty(&quot;myPlay&quot;,A); //先创建一个关于Music类的一个上下文 123456789101112131415161718192021222324//fun.qml如下MouseArea &#123; //设置鼠标点击区域 id: sta_pau x: 120 y: 8 width: 45 height: 45 Layout.maximumHeight: 40 Layout.maximumWidth: 70 Layout.fillHeight: true Layout.fillWidth: true onClicked: &#123; myPlay.pausePlay(); &#125; &#125; Image &#123; //把图片放到鼠标点击区域上去 这就是个按钮了 不要在意用没用button那个细节233 id: sta_pau_bg x: 120 y: 8 width: 45 height: 45 source: \"///img/我是一个萌萌的按钮图片.png\" &#125; 这样 一旦我们点击鼠标区域 就会触发与myPlay相之绑定的Music类对象A 从而调用A的暂停播放函数. 果冻,能不能再给力点啊?(눈_눈) 你说的这么水 等着挨喷吧 o(////▽////)q 既然你诚心诚意的发问了~那么,现在让我们结合起用C艹来艹QML与用QML来艹C艹,假设我们要撸一个音乐播放器的进度条.C艹负责处理歌曲总时长,当前播放进度,QML负责用花哨の特♂技显示出来这些. 机智的你一定想到了,这还不简单,QML中使用一个Text控件用于显示,C艹则用QQmlContext建立上下文把总时长与标记绑定,当总时长改变,标记的值也会随之改变,显示出来的总时长也会随之改变. 而当前播放进度则使用QML的进度条显示Slider 控件处理.Slider的value就是当前播放的进度,通过点击事件onPressedChanged来处理进度条的拖动~ 为了更精细的显示出当前播放进度,我们还需要一个用于显示当前播放秒数的Text~同理用C艹获得当前播放秒数,绑定上下文就成.这里只截出一部分 详情还劳烦各位去窝项目上的main.qml与music.cpp上瞅瞅 鬼畜级代码奉上(｡・`ω´･)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*QML*/ RowLayout &#123; id: progress x: 0 y: 20 width: 580 height: 60 spacing: 5 Layout.maximumWidth: 580 Text &#123; /*用于精确显示当前播放秒数*/ id: s_time y: 0 width: 40 height: 20 color: \"#C8C8C8\"; text: mySTIME /*秒数的上下文*/ font.pixelSize: 18 &#125; Slider &#123; id: bar x: 50 width: 450 height: 20 Layout.maximumWidth: 550 Layout.maximumHeight: 20 Layout.fillWidth: true maximumValue:myPlay.getEndtime();/*使用与Music类对象A绑定的上下文来获得当前音乐的总时长*/ value: setNOW /*用当前播放的值来设置进度条的当前进度*/ onPressedChanged: &#123; /*点击事件:当进度条拖动时改变音乐进度*/ myPlay.setNowMusicPos(value); &#125; &#125; Text &#123; id: e_time x: 515 y: 0 width: 40 height: 20 color: \"#C8C8C8\" text: myETIME /*总时长的上下文*/ font.pixelSize: 18 &#125; &#125; 12345678910111213141516/*C艹*/ QObject::connect(now, &amp;QMediaPlayer::positionChanged, [this](qint64 position)&#123; if(nowMusic-&gt;duration() != 0) /*QMediaPlayer* nowMusic */ this-&gt;setEndtime(this-&gt;now-&gt;duration()); //获取当前音乐的总时长 settime(position); /*Music类成员,用于获得当前播放的位置(就是当前播放到哪了 单位:毫秒)*/ QQmlContext* s_time =myView-&gt;rootContext(); //当前播放时长的上下文 s_time-&gt;setContextProperty(\"mySTIME\",QVariant(timeformat(position))); QQmlContext* now_progress = myView-&gt;rootContext();//进度条值的上下文 now_progress-&gt;setContextProperty(\"setNOW\",QVariant(position)); QQmlContext* e_time = myView-&gt;rootContext(); //总时长的上下文 e_time-&gt;setContextProperty(\"myETIME\",QVariant(timeformat(this-&gt;endtime))); &#125;); 在这里我们使用了一个QMediaPlayer类的一个信号,每当音乐播放进度改变时都会发射该信号从而调用与之对应的槽(在这段代码里槽为一个lambda).需要注意的是这个信号发射粒度(周期)为1s,据说可以修改发射粒度,找了半天无果,如果你知道怎么改,请务必联系我~阿里嘎多~每当音乐播放1s,positionchanged信号被发射,C++代码刷新各项数据,通过上下文引擎把数据暴露给QML.当进度条拖动的时候,QML的点击事件将触发改变音乐进度的函数来改变播放进度. 大概就酱 谢谢捧场 谢谢~ 欢迎讨论~欢迎纠错(逃","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"QML","slug":"QML","permalink":"http://yoursite.com/tags/QML/"}]}]