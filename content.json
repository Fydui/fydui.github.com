[{"title":"Qt在安卓上使用sqlite","date":"2017-12-11T12:39:40.000Z","path":"2017/12/11/Qt在安卓上使用sqlite/","text":"最近折腾上了用Qt写安卓, 恰好要在安卓上用sqlite, 一开始以为和桌面写法差不多,然而跨到了安卓之后死活打不开数据库,于是便开始了各种折腾, 首先要说一下, 我使用的是Qt自带的数据库操作库: 使用QSqlDatabase建立连接, 然后使用QSqlQuery操作sqlite. 还有一个要说明的是: 使用QSqlDatabase打开数据库吧,如果他发现没有这个数据库,他便会给你新建一个大小为0k的同名数据库….,这就会导致: 数据库明明能打开却找不到表这种坑爹情况… 我一开始就忽略了这个问题坑了好久…. 咳咳, 如果想通过qt在安卓上用sqlite据说有两种方法, 其一种是使用qrc,也就是qt那跨平台的资源机制,这东西我一直没搞懂怎么用, 一开始我照着qt使用在qrc里的qml文件一样去调用我在qrc里的db文件,然并卵,用它存些图片还好,但存上数据库我就…. 所以我用了另一种方法,大概思路是利用安卓的assets文件夹:把数据库丢到安卓构建目录下的assets文件夹下,这样在打包成APK时候Qt自己就会把数据库打包到APK里头.然后在程序运行的时候给他拷到安卓本地的目录里头,咱就能用辣~ 开始我十分傻逼的直接database文件丢到了assets文件夹下,然后我发现每次编译这个文件夹都会被qt删掉重新整一个….(目瞪口呆.jpg) 所以我需要一个特别的方法把数据库整进去.. 查了一圈问了几个大佬之后,得知你需要在pro文件里头写点东西: 123INSTALLS += resres.files += qrc/SQL.db #数据库文件所在的路径res.path = /assets/db #assets目录 这样就会把你代码目录下的qrc目录下的SQL.db文件拷贝到安卓构建目录assets文件夹下的db文件夹下 , 不知道我表述清楚没有, 我觉得这是一个能在编译的时候把你的文件当做成源文件的本身一部分的一种操作, 这样就会在变编译的时候帮你把你的文件复制到assets文件夹下.(但对于多个数据库来讲还有更好的方法吗?) 然后就是给他拷到安卓本地目录里头: 12345QFile file(&quot;assets:/db/SQL.db&quot;);//在assets里的文件通过&quot;&quot;assets:&quot;&quot;访问if(file.exists())&#123; //如果文件存在 file.copy(&quot;./SQL.db&quot;); //拷到安卓本地目录 QFile::setPermissions(&quot;./&quot;+path,QFile::WriteOwner | QFile::ReadOwner); //以读写的方式进行拷贝&#125; 在assets文件夹下的东西都要通过assets:来访问, (我试图用qrc:的方式来访问qrc里头的数据,然而我失败了,明明它自己的示例这么访问qml文件都好使), 注意copy函数会将数据库拷贝到安卓的:/data/data/你的工程名(默认是org.qtproject.example.你项目名)/files/下. 接下来就是打开数据库: 12QSqlDatabase sqldb = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;); //添加sqlite的驱动链接sqldb.setDatabaseName(&quot;./SQL.db&quot;); 顺带说一下数据库的操作, 用QSqlQuery类就成, 这个类有个exec()函数, 可以直接传递数据库操作命令给他:12345678QSqlQuery* mysql = new QSqlQuery;mysql-&gt;exec(&quot; CREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL );&quot;); //直接写数据库命令就成 比如这是一个建表... 再来个获得数据里的数据的例子:12345mysql-&gt;exe(&quot;select * from ONLY where level = 1;&quot;); //查找表名为ONLY的, level值为1的一条数据QString str;if(mysql-&gt;isSelect()) //如果是查询语句 while(mysql-&gt;next()) str = mysql-&gt;value(2).toString()//value是索引数,如果你要查询的索引是第二个, 那就填2 但是如果获取一些别的信息QSqlQuery可能就不成了,比如获得一个表里有几条数据, 需要使用QSqlQueryModel这个类:123QSqlQueryModel model;model.setQuery(&quot;SELECT * FROM ONLY&quot;); int column = model.rowCount(); //查询ONLY这个表一共有多少条数据 具体请参阅Qt文档与论坛 以及其他文献: Problem deploying sqlite database to my android device Platform and Compiler Notes-Android: http://doc.qt.io/qt-5/platform-notes-android.html QSqlQuery: http://doc.qt.io/qt-4.8/qsqlquery.html QSQLDatabase: http://doc.qt.io/qt-5/qsqldatabase.html QSqlQueryModel: http://doc.qt.io/qt-5/qsqlquerymodel.html 谢谢观看","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"}]},{"title":"胡德酱你快来解释一下啊","date":"2017-10-31T15:55:32.000Z","path":"2017/10/31/胡德酱你快来解释一下啊/","text":"胡德,舰装原型为一战时期英国皇家海军海军上将级战列巡洋舰胡德号…是一艘标准排水量41000多吨拥有着四座双联装381毫米主炮和31节航速的一战老兵…嗯…我闻了闻周围弥漫的茶香.. “好香啊..” 我在赞叹于红茶的芬芳与女仆的精湛的茶艺之时并将温热的被子送到嘴边… 细细想来, 我确实是对历史上的胡德了解的少之又少..似乎只局限在道听途说所知的那场闻名遐迩的战役中..我看着胡德的资料..这样想着..白色的蒸汽先像棉花糖似得慵懒的堵在杯口,片刻之后,几缕白烟从糖堆中探出,它在空中徘徊了一会儿..最终还是钻入了我的鼻子..所以说…忍不住茶香缠心的我还是贪婪的吸了一口杯中的红茶.. “唔…果..烫烫烫..死了…”. “呼…哈…呼..哈” 我将杯子放下, 急促的不停换气..试图让口中的温度降低些许… 白色的水蒸气不紧不慢的从杯口向上飘散..从什么时候开始的呢..胡德啊..我放下手中的资料, 嘎吱一声靠在座椅背上. 好像是..在声望来的之后不久吧..我闻着淡淡茶香回忆着往事..自从这位大不列颠少女来到之后.整个镇守府都好像被红茶的香气所萦绕,仓库中红茶的数量也和茶香一样日益渐增.. “指挥官阁下,您知道, 一天之中最美好的时候是何时吗?” 在胡德到来之后的某一天,她曾这样向我发问. “恩.对我来说..应该是早晨与傍晚..阳光,我喜欢他们的阳光”.我想了想这样说道.. 不值为何而起.也不知道从何而来, 我像是一见钟情似得突然喜欢上了早晨与傍晚的阳光..清晨,阳光也变得充满了生机..傍晚则总是让我回想起了… “恩,50分” 胡德说. 我回想着与胡德的对话 “你说什么? “ 我有点没反应过来 她没有直接回答我的问题. 而是平缓的将放在桌边的一套瓷质茶具拖了过去,瓷器之间微微碰撞发出独有的清脆之声.. “您知道吗? 对我来说” 她从随身携带的提包中掏出一个刻着精美花纹的圆柱形金属盒..随后又将手包放在腿上,左手从托盘中拣起了两只倒扣着的小茶杯, 右手提起瓷壶.一柱热气腾腾的沸水被倒入到一只杯中.两只精巧白皙的手指捏住了茶杯的边缘. 杯中的水随着他手腕的晃动而轻轻摇荡.源源不断的热气已经将茶杯完全占领.徐徐的冒着比之前更加浓厚的白气.但胡德并没有让白将军自在太久..他手腕一弯..将热水倒入了托盘中… 我一言不发,不想打破现在着微妙的气氛..不如说胡德的动作让我觉得有点赏心悦目..可能这就是..贵族气质吧..所以我也就饶有兴致的看着她又用同样的手法洗了另一个杯子.. 前一只杯子的热气尚未散尽,她轻轻拧开了之前的金属盒. 捏了两小撮茶叶.分别当如两只洗好的杯子中… 壶提起,水注入,白气生. 我闻到了一股突然绽放的清香, 诱人,但又清纯..我感觉到了两股本不应该相容但又和谐的极端… “对我来说,一天中最重要的是下午..” 终于胡德开口说 她笑着看着我… “下..下午茶么” 我嘟囔着 “当然.”“哦,这是您的” 她把手中的茶杯放在托盘上,将另一只茶杯推到了我这边. “请用..指挥官阁下” 她微笑着.. “谢谢” 我拿起面前的茶杯,清香无比, 我轻轻的吹了一下茶水,随后慢慢吸了一口..我就着喝茶的动作..看了看她的脸.此时的胡德正安静且从容的享受她这一天中最美妙的时光.. “恩..好喝..不错嘛..”我放下杯子,赞叹道,只是有点烫..她一副那是当然的表情得意的看着我..没有说话… “滴滴..滴滴..” 两声刺耳的电子音把我从回忆中惊醒..我习惯性的瞟了一眼时钟.. “都已经这个时候了啊..” 我自言自语道.. 胡德的改造与新舰装调试应该完成了吧..我站起身,用手抹了一把脸,随后将办公桌上的红茶一饮而尽.. “啧.凉了也很好喝嘛…” 味道丝毫没变 我放下杯子,向门口走去. 就当我正要握住门把手时,把手自己动了起来..自从这群丫头跟我混熟了之后就开始不敲门了..我急忙闪到一边,门被一只白皙的手推开了.. “指挥官..阁…” 我面前站着一位金发少女 “阁下,您怎么了?” 少女推了一下眼镜,疑惑的问我.. “胡..胡德啊..” 这…变化有点大啊,我受到了惊吓… “我正要去找你呢..正好..进来说吧” 胡德点了点头迈了进来..并反手关上了门..我和胡德坐在办公室的沙发上. “比我想的要快啊..改造完事感觉如何?” 问毕,我继续打量着面前这位少女.她好像变高了一点点..是我的错觉吗? “重点加强了装甲防护,放心吧阁下,这下应该没有问题了..” 她一边说着一边准备泡茶,而我则继续观察这面前这焕然一新的少女.呃头发变长了? 我看着这一头金发想到,,视线下移..胸..胸一定变大了. 哈..有种某明奇妙的欣慰感是怎么一回事啊..哎,这衣服也很赞啊,上身是一件蓝白相间的披肩.中间还镶了一块宝石. 我之前一致认为在衣服上镶宝石这种设计,如果稍有不注意,设计的有瑕疵的话,穿在身上会显得十分土气.但此时.我觉得这件披肩和她很般配,违和感全无.. 披肩内是一件有着礼服,军装以及衬衫元素融和的制服..下身则是普通的蓝白格子百褶裙. 以及白色过膝袜.. “咳咳..” 我从上到下打量了她一番,在赏心悦目之后,将目光聚集在她精致的俏脸上. “阁下?” 红色的椭圆形眼镜似乎没有换, 不过到底多少度呢..有机会我倒是想问问她. “咳..阁下..您离得好近..” “啊? “ 我一下子注意到了胡德有些不对, 原来我在不知不觉中已经贴的这么近了, 似乎连她的轻微吐息都能感觉到. “啊对不起, 胡德…” 我立刻直起了身子道了歉.. “真的很抱歉..” 我摸了摸发烫的脸颊, 不再好意思看向她. 索性向她身后的窗外望去..但不知为何,我的视线再一次和胡德的目光对了上去.她红着脸眼神四处飘散着,我知道这都是因为我所致.为了打破这尴尬的气氛,我觉得我得立即说点啥才好, 于是我清了下嗓子. “咳, 那个..胡德啊,你那眼镜究竟是多少度的? “ 糟了..话一出口我就立刻感到自己说错话了..提什么不好偏提眼镜啊..我回想到片刻之前我几乎块贴上她脸观察人家面容的犯规举动..得了,还是先道歉吧.. “嗯.大概七百多度.” 胡德思考了一下,回答我. 咦? 我看向她的脸,发现除了脸颊微红之外,她已经恢复了往日典雅的贵族气质.. “七百多度啊..话说..我还没见过胡德你摘下眼镜的样子呢.” 我笑着说着 “所以说我还不怎么了解胡德呢..哈哈” “哎, 你回到这个港口已经很久了吧,从那时起你也就一直为我效命.” “出身于传统贵族的你,不经意之前言行举止都流露一种..难以言表的感觉..” “可能….那是一种精神上的距离感吧….那时的我是这样想的” 我缓缓地吐露出一些平时内心所想.. “但, 这种念头没过多久就被我打消了..” “因为如果你想走, 不论到哪儿, 都有人敲锣打鼓的来欢迎..” “你从一开始就没有嫌弃一穷二白的我, 一穷二白的新港口. 还邀请我共进每天中对你来说最重要的下午茶..” “我甚至觉得吧. 这样咫尺天涯的高岭之花并不是我想的那样..难以接近啊..” “所以我也想, 想要多多的了解这样特别的胡德..” 她一言不发, 还是那样安静的坐着, 茶几上的茶水也渐渐凉了.. 我回过神… “啊, 不知不觉的好像向你说了一些比较沉重的东西, 不用往心里去哈 “ 我挠了挠头笑着说.. “呵呵…原来我在阁下的眼里是这样的啊..” 她似乎有些开心,笑着说道.. “现在已经改变了嘛..” “那么..阁下想更多的了解胡德么? “ 她看着我 “哎,没关系吗? “ 我挪了下身子, 向她靠了过去,胡德红着脸, 眼神盯着裙边..于是我伸出手..摘下他的眼镜.. 啧 我端详了一番 “还是这样漂亮啊..似乎没啥不同嘛..” 我嘟囔说 “哎? 让阁下失望了吗? “ 胡德歪着头看着我 “哪有啊,不过嘛, 摘下眼镜的胡德倒是多了一分邻家少女的味道啊” “哦是吗? 那么阁下更喜欢那个呢..” 胡德眨了眨眼睛 “我觉得胡德啥样都好看..” “咦? 提..提督..” 她瞬间涨红了脸 “啊对不起! 别误会,,我没别的意思” “我知道啦.” 胡德有些失措, 我看到她红着脸避开了我的目光..伸出手打算去拿茶几上的茶杯但手却停在了半空中, 她眯着眼睛迟疑了几次..啊对了..高度近视. 我这样想着,准备起身帮她拿. 不过看着这样因使不上力而涨红了脸的胡德, 不由得觉得和她平日里的形象有些反差.. 但我刚起身,眯着眼尴尬的不行的胡德突然向茶杯抓去.. “啪”.. 一声清脆的撞击声..毫无疑问的说,茶水洒了. 飞溅出去的茶水此时就像洪水一样漫过了茶几,向地板冲去.. “啊!”胡德一声惊叫 “阁下对不起!” 她有些不知所措的站在原地.. 但打翻的茶水可不像胡德那样不知所措. 它们已经在地面上开拓了一片疆土.. “我这就帮您擦擦!” 胡德突然起身. 但可能是没带眼镜的原因再加上起身过猛, 咚的一下子胡德的小腿撞到了茶几边上了.. “好痛..” “你小心点啊…我来擦吧..胡德! “ 我总觉得摘下眼镜的她有些不对劲.. “不行,那怎么好意思呢” 胡德准备去拿放在角落里的拖把.. “胡..” “哎??..” “哎啊啊啊啊~” “啪..” “德..小心地上有茶水…” 眼看着胡德快摔倒在地.在边上的我赶紧伸出胳膊..啪的一声我接住了向我扑来的她..但是然并卵, 失去平衡的胡德赶忙搂住了我的腰,冲击力将我们俩咚的一下子拍倒在地.. “胡德,,你没事吧..” 一阵疼痛过后我赶忙问胡德.. 她趴在我身上,一句话也没说.. “胡德?” 我继续问道… 她趴在我身上,上身微微颤抖..我好像听到了他的啜泣声..我..我把她弄哭了? 我试着安慰她一会儿..但胡德还是趴在我胸口上.. “那个..胡德? 胡德酱?” 她缓缓抬起头,蓝色的大眼睛中积满了泪水, 她气鼓鼓的嘟着涨红的脸.看上去可爱极了… “别哭啦..这里又没有别人嘛….” 胡德看了我一眼,把头埋了下去,小拳头一边锤着我胸口一边带着哭腔说.. “还不是有你嘛. 好丢脸啊..” “对不起啦..我保证..我今天啥也没看到..那个,,胡德酱..能..” 我本来想让她先起来再说,但话一出口,胡德酱锤的更厉害了.. “没事..没啥..”我赶忙改口说道.. 谁叫我突然抽风想摘人家眼镜呢..等她哭完应该会好吧..我一边这样想着,,一边这样安慰她..我本想抚摸一下她可爱的小脑瓜… “咚..咚..咚” 一阵敲门声.. “指挥官, 胡德的改造与测试报告我送来了哦~” 卧槽? 我一听这声音是药丸啊节奏啊..我的妈这是我的秘书舰..列克星敦啊… “胡德! 胡德快起来!..星敦来了..你这样很容易产生误…” 嘎吱一声..门开了..先不说胡德她打不打算起来..反正我猜摘了眼镜的她是起不来了…不过一切都完了..我的人生定格在此..一切终将变成灰暗的回忆.. “没事了..胡德酱…” 我僵硬的说道.. 刚推开门的星敦停在了门口..原本面带笑容的她突然怔住了.接着啪的一声.她手里的咖啡杯应声落下 ,陶瓷与地面亲密接触产生的清脆破裂声仿佛在宣告着我的末日.. “哎呀,那个指挥官呐..您..在..做..什么呀?” 列克星敦一字一字的把字从唇边挤出..她阴着脸,笑容逐渐僵硬.. “啊啦,我是不是阻止了某个人的暴行呢..” 暴行?! 什么鬼.. 完了 在这这样下去只会越来越糟.. “那个,星敦..” 突然胡德抬起了头..完了完了我心中想..你俩真不是串通好的? 四目相接..列克星敦看到哭的梨花带雨的胡德之后脸色更差了… “原来如此…” 列克星敦咬牙说道.. “你不要一副什么都了解了的样子啊喂! 不是你想的,,,” 我赶紧解释. 但为时已晚.我看到她深吸了一口气..突然间..我感到我的耳膜在颤抖.. “来人呐! 胡德酱被变态指挥官欺负啦!! “ 哎我的妈啊..他这一嗓子..估计全楼的人都能听见..我已经预料到了,很快, 我将被闻讯而来的人团团围住..接着应该是一顿声讨.. 我绝望的望着天花板.. 对..胡德她虽然停止了啜泣..但依旧没有要起来的意思..也是..毕竟列克星敦也在这..胡德应该很为难吧.. “咚..咚..咚..咚” 我听见一阵急促的跑步声.. 果不其然,不出十秒我就听到一阵急促的脚步声.一道人影从门口闪现,那是一位穿着女仆装留着金色齐肩短发的少女.. “声..” 我刚要和女仆打个招呼.. “胡德酱! 你没事吧!” 一声尖叫.. 声望的胸口上下起伏着..手中紧握这一把笤帚..一脸紧张的看着胡德..同时他也无视了我的问候,径直来到我身边.. “胡德酱..” 声望温柔的拉起胡德..胡德则抱着膝盖,蹲在茶几一边..她抬起一点点头..委屈的蓝眼睛透过缝隙泪汪汪的看着声望… 胡德已经起来了,我自然没理由继续躺着..于是我站了起来.. “胡德..还好么?”“胡德酱..还好么?” 我和声望异口同声的说着.. 这次声望没有故意无视我,声望紧握着笤帚..突然他那双独有的异色瞳紧盯着我的眼睛十分认真又心痛的对我说: “舰长! 您有压力我理解..按捺不住欲望可以来找我啊! 为什么..为什么要伤害胡德酱呢..难道我已经满足不了你了吗? “ 说完她挺了挺饱满的胸脯,然后又做出一副痛心疾首的样子.. “啥玩意啊! 这是个误会啊! “ “我是那样的人吗啊喂..我只是..” 我觉得我还能抢救一下,立马准备解释 “别只是了,事情我已经听星敦说了..” 谁..等…这声音…我一点一点扭头看向门口..除了冲我翻白眼的星敦之外… “大..啊不..威尔士! 你又啥时候来的啊..” 完了..这下真完了.. “刚刚..” 威尔士用复杂的眼神看着我 然后缓缓开口.. “我一直以为,虽然我们一穷二白,但是我们有一位有上进心的指挥官,,虽然我们实力弱小..但我们有着需要共同保卫的目标..” 说完威尔士指了指地面.. “这里..家..” 气氛突然严肃了起来 “没想到啊….先不说别的..您为什么在有了声望之后,,又把魔爪伸向了胡德酱?…” “我可没做对不起声望的事情啊! “我立马辩解.. “舰长..你胡说..上次战斗完您还背着受伤的我呢..最后…” 话没说完..声望握着笤帚..红着脸把头扭了过去… 卧槽? 还有这种操作? 你们这是…. “那只是…”我现在真是有口难辩… “就是就是..指挥官上次还和我在沙滩上…” 列克星敦利马插话道.. “我..”我已经放弃了辩解.. “原来你还是多线程的蛤? “ 威尔士瞪大了眼睛,随后她又说道: “看来有必要让反击离你远点了..” “大哥我是冤枉的啊!..” 我挣扎了一句,然并卵 边上的星敦还十分配合的面露嫌弃之色的往后退了一步… 喂喂,这可不是星敦你啊…我算是明白了..这群姑娘是坑定我了.. 真拿他们没辙啊…总不能扫了这群兴致正高的姑娘们的兴吧..那我就配合下他们吧..反正应该不会太过分…吧.. 于是我用求救的眼光看向胡德..不过胡德从刚才开始就一只没有吧眼镜戴上.. 她抬头看了我一眼,蓝色的美眸中啜泣的红色还没完全退去… 渐渐的房间中围观的群众越来越多..这真是看热闹不嫌事儿大啊…我看见列克星敦不断的在每个人的耳边说着什么,每告诉完一个人还一起瞪我一眼,然后大家仿佛有前所未有的默契一样..七嘴八舌的议论了起来.. “提督真是差劲啊..”“是啊是啊..真够花心的..”“哼..没想到还是个渣男,我还挺喜欢他的呢”“我..我想辞职..”“不过提督做饭还挺好吃的哦~”“哎呀威尔士好有气势哦..”“嗯嗯.好喜欢威尔士姐姐呐..” “辞职什么的太过分了吧..话说你们的声音小一点啊喂.我都听到了啊..”我无奈的说道..哎…这群姑娘一定是故意拿我开涮.. “咳咳..” 突然威尔士清了清嗓子.. “请大家安静一下” 说完她环视了一周.刚刚还兴致勃勃吐槽我的姑娘们瞬间安静了下来..她看了我一眼..好像再说: 没错这是最新的操作. 一样 还挺有威严的嘛..威尔士.如果有一天我突然不在了,她应该也能管理整个港湾吧..不知为何,我脑子中突然冒出了这样的想法.. “大家都已经看到了! 因为大家的及时赶到.我们可爱的胡德酱并没有遭到某人的侵犯..” 说完我便感到一阵刀子般视线向我投来…怎么有点冷呢.. “虽然说是指挥官, 但是像这样光天化日之下,欺负自己可爱的女下属怎么说都是非常过分的行为啊.. “ “所以说大家, 我们不能让这人渣白白占了胡德的便宜,必须,必须给他应有的惩罚! “ 威尔士的声音不断提高着..同时提高的还有那群看热闹不嫌事儿大的人的兴致.. “我真的什么都没做啊喂! “ 不行不行,当提督的男人决不能轻易认输, 我试图咸鱼翻身. 我看在蹲在一旁还有些没反应过来咋回事儿的胡德.. “胡德酱,你倒是解释下啊..” 我趁机向门口挪动.. 胡德站起身, 眼红已经消退但她依旧是一脸懵逼的样子.. “我没对你做什么,对..对吧..胡德酱…” 我摊了摊手笑的十分尴尬… 胡德稍加思考了一下.. “嗯….嗯..,只是刚刚阁下把人家的眼镜摘下来了而已..” 听上去好像没啥毛病, 她说的是事实..但是我总觉得有些不对的地方..尤其是在此情此景.. “原来如此..用花言巧语骗摘掉胡德的眼镜, 其实是为了方便你下手吧! “ 声望一脸认真的在一边分析道.. “不是那样的啊! 不要一脸认真啊! “ “然后..”胡德好像要说啥..但我觉得我得溜了… “然后..我听到当的一声” 胡德捏着裙边小脸微红渐起… 四周又开始叽叽喳喳起来..感觉周围有一群小麻雀似得..只不过她们都是分分钟能变成鹰的那种角色.. “啊..提督已经按耐不住欲望了么..我好兴奋啊..”“好差劲啊..居然连一点前戏也没有..”“我还是觉得提督做饭比较好次..”“那个..做饭..这和那个没关系吧..” “只是杯子倒了而已啊..”我无力的解释着..不过貌似并没有人听见.. “接下来..接下来,就听到了啪的一声..然后咚的一下子..我和提督就倒在了地上呐..” 胡德欠着身子小拳头在胸前攥着..一脸兴奋的说道.. 四周又是一片沉默..沉默..是今晚的长江大桥 “不可原谅..” 威尔士咬牙切齿的瞪了我一眼.. “一定要让他尝尝苦头!” 不知道是谁喊了一句..不过我猜..除了那个始作俑者之一的少女之外还有谁呢..不过现在最重要的是..溜! 突然我一个侧身, 凭闪电之势钻过层层人群,一个健步迈向门口..再见姑娘们,我可不会这么轻易的狗带! “不好! 人渣要跑!” 又是这声音… 于是我索性撒开腿就跑..转眼已经踏上了走廊的地板,向门口冲去..用不了多久,我就能飞奔出楼口.. “ 我记着是我滑了一下..指挥官为了扶我才…” 胡德一个人小声嘟哝.. “哎呀不管啦, 先去追提督~” 胡德迈出了门口和大家一起向某人围去.. 等等..前面走廊上有个人影…我放慢了撒欢奔跑的步伐.. “声望? “ 那是一个穿着女仆装的少女..我试探着问..但不对啊..声望刚才明明还在屋子里坑我这会儿咋能跑走廊里来呢… 女仆少女突然转身..这时我才发现她手里拿了一个拖把..此时那把拖把正用来被她当做拦住我的栏杆横在了半空中.. “反击啊…” 还好她拿的只是拖把….而不是大炮狙 “不对…为啥你也跟她们同流合污啊!..” 反击攥了攥拖把..有点难为情的样子, 乖巧的反击有着一副很有灵性的洋娃娃脸..和她姐姐声望除了性格不同之外..瞳色也是相反的.. “威尔士已经告诉我了….她….她说让我在这里等….” 她强行忍了忍难为情的表情….换上一副严肃的样子.. “等着阁下以备后患! “ 反击双手旋转了一下拖把..然而看着她那洋娃娃脸严肃中带着难为.难为中还有些不知所措的样子我… 看了看窗外明媚的阳光…对着反击说.. “反击小可爱..你知道吗? 一般来讲..我们的计划永远赶不上变化..所以说我们要学着随机应变..这样才能处理好” 我顿了顿… “不论是战斗..还是..抓舰长! “ 说完我没等反击反应过来..一手拉开了我边上的一扇窗子,幸好我腿长直接能踏上窗台..顺手脱了白色的军装外套..露出了里面的衬衫..丢给了反击.. “打扫房间辛苦啦..”我向反击说道.. 完事儿便抓住窗外紧贴着墙壁的排水管..还好这是二楼..问题应该不大..于是我直接两手半搂着排水管一只腿蜷缩的蹬在管道上..另一条腿紧贴着管道..滑了下去.. “嘭..”“啊啊啊…” 显然..我还是没能像想象中的那样帅气的着地..一不小心就扭到脚了..哎呀哎呀我的逃亡之旅可能就要结束了.. 这下没办法了啊..我试着站了起来..不过还好并没有我想象中的那么严重..我整理了一下衣服.. “这裤子又要洗了啊..这下不能好意思麻烦反击和声望了啊..自己洗吧.” 我无奈的笑着说道.. “还不是因为您..” 同样无奈的语气.. “谁?!” 我环顾四周..一位身着褐色旗袍的少女站在我不远处..盘起来的黑色的头发紫色的眼睛.一点黑色的泪痣..肩膀上还披着一件褐色长袖披肩.. 此人正是–逸仙 “您还真有精神啊”..逸仙眨了眨黑色的眼睛 “嘿..反正现在没啥要紧的任务嘛..” 我打了个响指..挠着头笑着说.. “不过逸仙为什么在这里啊? 散步吗?” 我问道.. “哎对啊..我为什么在这里呢..”逸仙的嘴角勾起了一丝微笑.. “那就是散步吧…您要一起吗?” 逸仙慢慢走到我身边.. “哎? 如果你不介意一堆人一起的话..”..我点了点头.. “是这样啊…哎…提督您呐.脚刚才扭了一下吧..” 逸仙侧着脸看了看我的脚..又看向了我的眼睛.. “逸仙..你该不会…” 我往后退了两步.. //这里可以有俩选项,选择陪逸仙散步即可进入逸仙线.. “现在想散步已经晚了哦..” 逸仙轻轻的笑了两声.. “大家~ 提督在这里呦~ “她声音不大..但我仿佛已经感到了地动山摇.. …… “嘭…” 门关上了,伴随门关还有一声..”好好反省吧! “ 这样的声音..接着就是一阵笑声..以及各种…庆祝声…. 这儿是一间通用仓库… 它是由一个闲置的宿舍楼改造而成..每个房间里都可以放些物资..有着良好的通风..平时主要放粮食..储备水源..以及少数弹药物资..还有的就是姑娘们的一些物品..以及一些家具之类的..我环顾了一下四周..地上积了一层薄灰…可是… “逸仙姐..你为什么跟我一起进来了?” “监视您啊..”逸仙一本正经的说 “不是吧….” 我看着端庄的逸仙..与胡德的那种端庄是完全不同的..逸仙..总是让我感觉那么的亲切…偶尔还会流露出…. “讨厌吗?”..逸仙稍稍有些吃惊的看着我.. “不是哪个意思啦~” 我走到窗边..向着外面宽阔的海面瞭望… “您的脚…” 逸仙解释道.. “嗨..那点小伤不碍事儿啦..我看她们玩的挺开心的..就是胡德貌似还不知情..” 我耸了耸肩..表示无所谓.. “折腾了这么半天..您还没吃饭呢吧..” 逸仙站在我身边..温柔的说道.. 被她这么一说..我确实感到肚子咕咕咕了… 逸仙晃了晃手中的包裹..笑着看着我 “你什么时…等等…合着小仙是计划好的啊! “ 逸仙笑了笑..没有说话..我觉得她这动作可能算是默认了我的问题…. 我俯下身..清理出来一块地方…讲道理陪她们折腾这么长时间, 我早就饿了, 不过看她们一脸认真的样子我也只好忍忍啦..我盘坐下来看向身边的逸仙, “提督? 您看窗外..” 逸仙没有理会的我的动作..眉头轻皱盯着窗外的海平面.. “恩? 我都饿了嘛..” 虽然我嘴上喊着饿了,但还是站起了身.. “窗外有什么东西吗? “ 我不以为然的望着外面, 明明什么都没有.. 我顺着逸仙的目光….傍晚的阳光铺在海上被波光粼粼的海面反射到我眼中.. “夕阳啊…我最喜欢夕阳了啊..尤其是海上的..”我望着窗外海平面 “提督您…” 逸仙紫色的眸子看着我..感觉要把我吸进去似得.. “这夕阳…总感觉..” 我觉得头有点痛…总感觉在哪儿见过…嘶..我突然感觉有什么东西要从我脑中钻出来一样.. “提督?” 逸仙的手在我面前晃了晃. “啊?” 我头有点迷糊..难道是刚才脱衣跳楼凉到了? 我体质没那么差吧.. “吃饭吧..” 逸仙转过身..背对着窗口..随即我俩坐在了刚刚清理好的地板上.. “可饿坏我了…” 一听吃饭我瞬间精神了.. 打开逸仙递给我的饭盒..十分惭愧, 自从逸仙来了之后我们的厨房就基本姓逸了,这些本来都应该是我的活..所以有的时候我也会去厨房帮帮忙啥的 但逸大才女好像并不需要我…我是说做饭… “色香味俱全啊..小仙的手艺一直这么好..” 我笑着夹了一口塞进嘴里.. “您过誉了” 她打开饭盒.. “哪有? 小仙做的东西一直很和我口嘛..” 我又爬了一大口饭 “慢点..别着急..我还做了些许汤” 逸仙从饭盒里加了块肉塞到了我饭盒里…然后打开了一个煲.. “唔…这味道总感觉在哪儿喝过似得…” 我也不知道为啥..就像这个世上总有很多我不知道为啥的事情..我不知道为啥我会突然头疼..就像我也不知道为啥逸仙的饭菜味道似曾相识… “提督您…” 逸仙看着吃的正欢的我欲言又止.. 吃完最后一口菜..我喝了口汤心满意足的说: “我吃完啦…谢谢小仙..” 我看着没怎么动饭菜的逸仙.. “如果我被小仙喂成了胖子..可不要嫌弃我啊” 我笑着打趣.. “当然不会..”逸仙看了我一眼..然后开始收拾东西.. “我来吧..” 我按住逸仙的手.. “如果不是小仙的话 我恐怕连晚饭都吃不上呢..” 我微笑着看着逸仙.. 我把碗筷收拾一下用最开始的布包裹好…然后站起身,倚在刚才的窗边..望着夕阳还未散去的海面.. “如果我现在出去一定会再被丢进来吧…” 我有点无奈的说着..几只海鸥从我面前的视界中飞过.. “您今晚恐怕要在这儿过夜了..” 逸仙补刀道.. “怎么? 小仙要陪我这个人渣过夜吗? “ 我耸了下肩..转过身子看着她.. “如果您需要的话..逸仙不介意..” “哎? 啊..哈哈..我开玩笑的啦..” “那么提督..小女子告辞了..” 逸仙拎起打包好的餐具.. “好好休息” 我看着逸仙的背影..轻轻的说道.. “您也是..” 逸仙侧过头…微微行礼..说完..留给我的就只有关门声和屋外海鸥时不时的鸣叫..以及从远处宿舍楼传来的只言片语..我一手搭在窗台上..继续倚着窗边..望向夜色渐起薄雾微浓的海面..似乎有点起风了啊..我感觉有点冷..于是乎抱住了自己的胳膊..海边的昼夜温差我似乎一直没有适应.. 她并没有直接回宿舍..因为他看上去是那么的正常..她在外面停顿了一会儿..面色似乎凝重了几分..紫色的眸子中流露出一丝难以置信的坚毅..“衣带渐宽终不悔..这一次..我一定要守护住您..” 逸仙迈动了腿..缓缓离去.. 我坐了下去..蜷着腿尽量让自己暖和点..看着窗外路灯投在地上的黄色灯光..透过窗子的灯光在地上印出了规则的几何形状..暗中有明.明中有暗..我不禁想到了庄周和他所想的那只蝴蝶…我晃了晃脑袋..避免让昏沉的脑袋思考过多的问题.. “恩..守护好我现在的就好..一直这样下去就好..” 大家的面容在我脑子里如同幻灯片似得一张张浮现..为什么我会想到这些? 可能..这些是我最重要的宝物吧…我感头脑渐渐迟钝了起来.. 哎? 幻灯片突然定格在了…一张熟悉的面孔上.. “身体好像有些热啊..真的感冒了?” 头脑昏昏沉沉的..似乎有点迷糊了..啊..睡吧..我靠着墙…放弃了思考… …… 霜月入户, 夜色渐深,阵阵海风裹挟着凉气向她吹去, 她站在一个仓库门口. “呀, 有点冷呢..” 胡德手中抱着一件外套, 她慢慢的推开了仓库的大门, 悄悄走进了房内,因为她知道此时的某人一定早就睡了… “指挥官阁下?” 胡德轻轻试问… 但里面毫无反应 她环顾昏暗的四周, 接着月色搜寻着什么, 周围尽是一些堆积的物资: 大号麻袋, 各种木箱, 还有几个类似集装箱的铁盒子.. 不过她很确定某人就在这里, 顺着月光她看向窗外,一轮弯月平静的躺在不远处的海面上,随着一阵阵暗流不停蠕动着.. 胡德缓缓的走向窗边, 这样夜深人静的看海,她还是第一次.. “咦..” 他看到窗沿下有什么东西 “阁下? “ 胡德看到某人此刻正安静的倚着墙壁,胸口平缓的起伏着.. “提督..” 胡德蹲下身,看着眼前在在白天被大家组队陷害的男人…然后将手中抱着的衣服展开…胡德贴到他身边..静静地看着披上一层月光的他的脸.. 胡德微笑着伸出一只手指打算挫一挫这张平凡但百看不厌的脸..但她很快就收回了手指, 轻轻地将上衣盖在他身上.. 胡德站起身, 准备转身离去, 刚走两步她觉得有些不放心, 于是再次来到某人身边, 将衣服往上提了一下.. “哎?” 胡德的手指碰到了某人的脖子,略高的温度使她突然紧张起来..他又将手贴在了某人的额头上.. “啊..有点烫啊..怎么办?” “对不起..” 胡德本是想将衣服盖上就转身离去的..但现在..情况有些不同.. 于是胡德走向刚才对方某物资的地方, 事到如今自己也有责任, 不不不,就算自己没有责任..她怎能丢下某人不管呢..虽然在最开始还是不是很懂发生了什么, 提督就被丢到了仓库中..不过事后, 胡德从作战胜利的大家那儿知道了事情的来龙去脉.. 原来提督阁下也会做出一些意料之外的事情啊, 这样放任下属对自己胡来, 可不是随便谁都能容忍的..胡德这样想.. 虽然平时总是一脸正经,又是还会唠唠叨叨不厌其烦的指出问题所在的他,有时工作到半夜才回去休息的他,做饭也百吃不厌的他,不经意间对自己流露心声的他,摘掉自己眼镜让自己不知所措的他, 原来…原来..是这么可爱的一个人啊..胡德一个人静静的看着夜色中的他..这下..就更舍不得叫醒他了啊..胡德的心跳有些加快..她抱着从集装箱中找到的被子, 别看只是普通的被子, 这可比那件上衣管用多了,而且..面积更大.. 胡德抱着被子轻飘飘的来到了某人面前, 她将盖在他身上的上衣揭下, 整齐叠好摆在一边, 又将手中的被子展开, 依偎在了某人的身边…胡德看着他的侧脸,倦意渐起… …… “不管怎么样..我会一直等待着您回来…我会..追随者您的步伐..” 逸仙整理了一下我的上衣.. 我看着逸仙紫色的眼睛.. “好啦好啦..只是个小头目而已..别搞成这样生离死别嘛..小仙在港等我回来做饭哦..” 我冲着逸仙摆出了一个”没问题”的手势.. 逸仙笑着看着我.. 随后往后退了一步.. “星敦..准备好了吗? “ 我扭头看向一位亚麻色头发的少女.. “好啦好啦…” 她有些兴奋的回答道.. 海..无尽的海..除了海还是海..仿佛和天交融了一般.. 突然..仿佛有一滴及其浓郁的染料滴入了这蔚蓝的海.. 血色从海里飞速扩散..海..变成了..血海 …… “嘶…啊..啊” 我的头脑逐渐恢复意识.. “好痛…啊…” 又是那种感觉..仿佛有什么东西要从脑中钻出一样…从大脑深处..突破脑仁,钻过脑壳.. “啊啊啊! “ 我突然睁开眼睛.. “哎? 咦…” 我这是…我才发现我已经坐了起来… “啊..” 我在仓库啊..已经早上了啊..我看了一眼窗外清晨的日光..刚才,头好痛,我好像做了什么不好的梦啊… 这….这是被子? 我看了一眼自己身上的纺织品..等等…哎? 这怎么有人? 我向那人看去 一副眼镜…和..一位少女… “胡德!?” 我不由自主的叫了声? 我有点没反应过来… “恩~…嗯~..提…督…” “再…睡一…会儿..” 我勉强从胡德嘴里听出来了几个字… 哎? 胡德昨晚给我送的被子吗? 我的头脑逐渐清醒起来..说来也奇怪, 那阵邪乎的头痛来的快去的也快…这丫头不放心我啊..我轻轻靠在墙上..看着边上还有些迷糊的胡德.. “提督..天..亮..了吗” 胡德捂着嘴打了一个哈欠.. “都快中午了哦…” 我笑着说.. “什..什..什嘛!?” 胡德一下子坐了起来.. “完了完了..这下没能及时回去..威尔士和声望问起来怎么解释啊啊..” 我看她手忙脚乱的样子..这和平时的胡德可一点也不一样啊… 胡德赶忙整理了一下头发..然后到处摸着眼镜… “在我这里哦..” 我一手拿着眼镜看着胡德.. 胡德红着脸气鼓鼓的看着我…好像再说让我快点还给她一样.. “还早着呢..别着急” 说完我把眼镜递给她.. “哼..” 胡德带上眼镜, 瞬间恢复到了平时高贵典雅的模样.. “提督阁下..下次请不要开这种玩笑..” 胡德一本正经的对我说.. “好啦.. 尊贵的胡德小姐..能不能麻烦你先起床呢..我要叠被咯..” 我看了一眼脸通红的胡德.. “再不起来..我就把你一起叠到储物柜哦~” 我笑着对她说.. “我知道啦..哼” 胡德一下子从被子中钻出来..整理了一下衣服.. “话说, 这样好么..半夜来给我这个被你们定义为人渣的人送被子..被人看到可不太好哦” 我看向站在一边的胡德 一边叠被子一边说..“搞不好我又要被关禁闭啦” 我笑着说.. “我认为没什么不好的” 胡德推了一下眼睛 “哦?” “闹过了一次之后..大家都自有分寸吧? 而且…始作俑者是..” 胡德微微低头,她看着我的眼睛,镜片闪过一片寒芒..她突然又恢复到了不好对付理性的模样,简称智商上线.. “我们的列克星敦小姐..” 我笑着说.. 看她进屋那样子就知道是早有心理准备..不然的话..以她的性格..见到我们躺在地上那一瞬间手中的茶杯就应该脱落才对.. “胡德笑了笑,” 看她的样子应该是确认过了..我们之间好像达成了某些共识..起码在只认凶手这件事儿上..” 恩..她说的没错..能直接锁定她的就是: “洒在地上的咖啡都是凉的..一点热气也没有..一看就是在外偷听多时了,咖啡都凉了你说说,这群姑娘真是太小瞧他们的指挥官了..” 我无奈的说道…然后自信的笑了笑 “很好, 合格, 那么下个问题…某人貌似和逸仙在这儿吃过晚饭呢..不怕被说闲话吗? “ “啊? 你看到了?” 我挠了挠头 把被子塞到了某个敞开的集装箱里.. “是啊..还一口一个小仙小仙的叫着..真应该再关你一段时间..” “什么? “ 我似乎听到了什么.. “怎么? 说谎可不像你..提督阁下” 胡德看向我 “小..小仙是谁?” “哎? 小仙不是逸仙吗? 我也是听你说才知道的, 怎么? 忘了?” 胡德有些疑惑的说 “逸…逸仙..我什么时候叫过她…” 我感觉头有点晕.. “我什么时候叫过她小仙?” 我强打起精神..一股莫名的危机感弥漫在我心头….是那种对陌生事物所产生的本能..危机感… “哎? “ 如果说刚才的疑惑只是轻微的不解..那现在的胡德一定是也觉得完全理解不能.. “不是提督自己叫的吗?” “小仙…逸仙..小仙..逸仙….” 我的头又有点疼… “逸仙..逸仙..逸仙就是小仙..” 我有点迷糊.. “小仙…” 昨晚的噩梦好像历历在目.. “啊…啊!!..啊..仙…” 我的头突然剧痛起来..整个颅骨仿佛都要从内而外的炸裂开一样.. 逸仙..星敦..蓝色..红色.. 昨夜的梦境片段不断在我脑中交织..我仿佛又看到了血色的海…漫天的硝烟.. …… “只望君平安” …… “啊!!!” 我突然意识模糊…脑中很痒… “提督阁下! “ 我迷迷糊糊的看到胡德向我冲来.. “提督阁下! 先去医务室..” 我感觉我被胡德架着一只胳膊..向医务室走去… 接着我就彻底失去了意识.. “胡德酱, 我也来帮忙吧..” 胡德抬头看着面前的异色瞳女仆少女.. 我睁开眼睛..这又是哪儿啊? 啊我刚才好像又头疼了..然后就…来到了这儿.. “医务室啊..” 我看了看周围洁白的布局.. “您醒了? “ 坐在床边的胡德一边吹着红茶一边看着我… “您晕倒了..我和声望带您来到这儿的” 胡德喝了一小口红茶.. “谢谢…” “请好好休息..您可能是着凉了之后又再仓库挨冻了半宿发了烧才会晕倒的..” 胡德看着我… “发烧..才会晕倒..么” 我嘟哝着.. 应该不是吧..我隐约感觉着..那片残缺的记忆.. “这些药,请您吃下..” “好好好…那个..不给我来点水吗? “我指了指胡德手中的红茶.. “啊..当然..这是您的…” 我坐了起来… “哎? 没关系吗? “ 胡德递给我她的茶杯… “没关系” “那好..” 苦涩的药片顺着甘甜的红茶进入口中..我一口咽了下去… “恩..真好喝呢…” 我看向胡德.. 她装作没有看见我视线的样子..红着脸又到了一杯红茶.. “阁下..您..还要吗?”","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"C#笔记-简单类型","date":"2017-08-26T15:17:53.000Z","path":"2017/08/26/CSharp笔记-简单类型/","text":"这一切都是和C++那么相似,但又那么不同 图片作者:Toshi 整数类型: 类 型 别 名 允许的值 sbyte System.SByte 介于 -128~128 之间的整数 byte System.Byte 介于 0~255 之间的整数 short System.Int16 介于 -32,768~32,767 之间的整数 ushort System.UInt16 介于 0~65,535 之间的整数 int System.Int32 介于 -2,147,483,648~2,147,483,648 之间的整数 uint System.UInt32 介于 0~4,294,967,295 之间的整数 long System.Int64 介于 -9,223,372,036,854,775,808~9,223,,372,036,854,775,807 之间的整数 ulong System.UInt64 介于 0~18,446,744,073,709,551,615 之间的整数 浮点类型: 类 型 别 名 近似的最小值 近似的最大值 float System.Single 1.5*10^-45 3.4*10^38 double System.Double 5.0*10^-324 1.7*10^308 decimal System.Decimal 1.0*10^-28 7.9*10^28 前两种可以用 +/-m*2^e 的形式来存储浮点数,m和e的值淫类型而异,decimal使用 +/-m*10^e形式; 文本和布尔类型: 类 型 别 名 允许的值 char System.Char 一个Unicode字符,存储0-65535之间的整数 bool System.Boolean 布尔值: true或false string System.String 一组字符","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"CSharp","slug":"CSharp","permalink":"http://yoursite.com/tags/CSharp/"}]},{"title":"笨蛋指挥官和不怎么笨的声望和....","date":"2017-06-25T07:44:55.000Z","path":"2017/06/25/随笔-笨蛋指挥官和不怎么笨的声望和..../","text":"“星敦! 战斗机先行起飞确保区域制空权.” “那鱼雷机呐?” “稍后起飞…” “好的提督,正在执行哦~” 啧.不得不说..在敌方投入航母进行作战的情况下,这片海域处理起来比较棘手. 虽说我之前也遇到过敌方航母并与其交手,不过那充其量也就是轻航级别. 所以凭借着列克星敦身为大型航母的优势–充足的载机量使她能在携带足够能确保制空权的战斗机前提下,又携带足够的攻击机和轰炸机以给予对方沉重打击.在基本夺取制空权之后,声望他们就能带着众大船安心的攻击对面. 但这次情况完全不同, 敌方正规航母的出现.. 意味着列克星敦从类型上所带来的优势急剧减少.再加上刚刚到来不久的列克星敦熟练度并不高,即使她携带着较为先进的飞机但也难以发挥出其全部威力.所以就算外围驱逐舰等在不断寻找对方的突破口, 我也不敢贸然指挥我后方的大杀器. 宁愿….是我分析错了,但空中胶着的战况明显的告诉了我现实的不爽. “指挥官! 三点钟方向, 空中侦察机发现敌方驱逐舰接近中..”列克星敦的声音从频道里传来.. “辛苦了…星敦” “说什么呢指挥官~ 这都是我应该做的哦~” 三点钟…么..? 那个方向是….我看向离我不远处的女仆装少女在频道里喊道:“声望小心..看上去这驱逐应该是冲你去的…” “安啦舰长,对付蛐蛐驱逐舰我可是完全没问题的.”听上去声望并不在意这小小的驱逐舰. 等等,这距离拉的有些远啊… 穿着女仆装的少女扛起一人多高的舰装,15英寸双联装巨炮像指针一样安静的转向,一步一步宣告着那艘徘徊于远处的驱逐舰的死期..不过她举了一会儿就又放下了舰装,并摇了摇头,表示距离过远.. 还是太远了啊..如果没有列克星敦的空中侦查,谁会注意自己侧面的一只小虫呢? 没等我先开口, 她便知道了我想说什么“十分微妙的距离, 将敌人至于自己射程之外, 自己却暴露在敌人射程之内”声望扭头冷静的向我说道. 我抬手摸了摸下巴,对面这船想干啥? 这种情况难免有些蛋疼,有这不痛不痒的距离隔着, 对面似乎干不了什么对我们有威胁的事情. 接着,星敦温柔的声音从频道中传来,不过不难听出其中所带的紧张色彩. “不能放任不管呀指挥官,如果她偷偷接近过来的话,可是很危险哦” 啊, 她也在担心吗? 不过直觉告诉我, 对面这驱逐应该不是以自身攻击为目的. 天空中乌云渐渐散去, 但天色依旧阴沉. 一种不安的感觉攀上我心头,在那弥漫. “躲得那么远,自己却迟迟不开火…” “提督提督~ 我们前线有大突破哦, 对面的重火力少了不少呢!” 这一听就知道是萤火虫的声音… !!! 不好, 那没跑了. 在这驱逐被我们发现了不久后 空中战事却依旧胶着,但前线的敌方重火力却莫名其妙变弱…对面不可能不攻击,至于为什么火力变弱,那只能说明他们寻找到了更有价值的目标,并且已经开始转换目标了……而且我猜, 这驱逐就是来侦查的 所以根本不用贴的那么近, 也压根不用使我们进入她的射程范围, 只要能看见就好了…当然也用不着什么开火, 因为一开火我们肯定会发现她, 那样我们一定会揣测这单只驱逐接近究竟是什么目的, 而且她生命也会有危险… “声望! 快走!” 这么长时间,他们的火力应该已经准备的差不多了…….而目标, 显然就是这位担任重火力输出的少女. 来不及了! 我跑向女仆装少女.. “干什么啊,舰长阁下? 难道您已经被小小驱逐舰吓破胆了吗? “ 声望一脸疑惑看向奔跑着的我,眼中还带着一丝嘲意..“虽然离得远点,速度快点,目标小点. 但我也能..” “闪啊! 我们暴露了啊!” 我扯着嗓子向她喊道. 来不及了! 我拉起她白皙的小手, 用力拽着她跟上我的步伐, 而那个驱逐, 像个幽灵一样在不远处的海域徘徊….徘徊着,接近着,等待着,狩猎猎物的最好时机.我仿佛已经听到了从自敌战舰巨炮之中喷射而出的炮弹划过天际而发出的呼啸声… 来不及了!只能是这样了… “我下次你可要听我话啊? “ 紧拉着声望的手臂顿时用力, 将原来一边被我拉着跑,一边打算再次举起舰装的她扯到了怀中.. “舰….” 接着双臂收回, 狠狠抵住她的肩膀,同时右脚向前迈出一步.. “痛….” 迈出的腿稍微弯曲, 抓着声望的身体向前倾.. 腰部带动着全身肌肉用力.. 我不知道这么做有没有用,或者说有多少用, 但这样或许是减小损失的最好办法…我试图将她推出去一段距离… “笨蛋舰长,我当然知道已经暴露了啊” 她笑着看向我, 推出, 确实是推出去了. 只不过被推出去的人被调换了… “痛…” 胸口感到一阵压迫感, 接着强烈的失重感是我确信被退出去的确实是我….时间在这一刻变慢了….为什么会这样啊? 我看向她, 不解, 疑问,诧异. 呼啸声越来越接近..不远处的驱逐依旧在徘徊着..但声望所传递给我的却是..在这之前,如果我没看错的话,那感觉就和某人当时望着我时的感觉一样…一种温柔… “小心..”我向她喊道… “放心吧..” 她回头看向我眨了下眼… 回眸一笑百媚生 接着眼前便是一阵模糊, 冰凉的针刺感蔓延全身. 显然, 被声望推出, 啊不准确的说是扔出去的我来不及调整姿态华丽丽的落水了…苦涩刺骨的海水就像这场战斗一样,将还沉浸在她温柔的眼神中的思绪拉回到了现实.,我努力睁开眼睛, 看向模糊的水面, 模糊的水面火光闪耀, 我知道那呼啸的炮弹已经抵达了它此行的终点.. 但我不知道的是, 她还好么? 他面对这雨点般的炮弹能安然无恙么? 她能像将我甩出去的那样潇洒的解决那只驱逐,以及,平安的出现在我眼前吗? 缺氧…声望的面孔在我眼前逐渐淡薄… 不要啊..声望..声望..声望!! “声…” 我红着眼睛挣扎出水面… 甩了甩满是海水的头发, 模糊的看见眼前的人影, 以右脚为轴,身体向右倾斜, 逆时针转过身体. 潇洒的躲开了弹雨中最后的一枚雨滴, 在倾斜的身体即将失衡的瞬间, 左脚向身后弯曲舰装稳稳的踩在水面上, 顿时已经失衡的身体以不可思议的姿势恢复了平衡. 与此同时,一人多高的舰装再次被举起.. “这下你在跑个试试! “ “DANG…DANG…” 随着两声巨响, 带着15英寸巨炮威力的舰装火光闪耀, 带着声望的愤怒, 再次爆发. 几枚炮弹划过硝烟弥漫的天空中划过一条优美的弧线, 伴随着一声凄惨的尖叫, 游荡与战场的幽灵终于场面于这片蔚蓝的火海… “指挥官,找到敌主力舰了, 两艘战列舰,一艘舰队航空母舰, 全部攻击机轰炸机已经起飞..先前起飞的鱼雷机中队正在赶往…” “啊..我知道了..”我攥着拳头, 尽量使自己声音比较和气… “您?” 没等星敦说完话,我咬着牙关掉了耳麦.. “我让你躲怎么不走啊! “ 我红着眼睛向女仆装少女吼到 原本以笑容对我的她突然征住了,笑容也随之凝固… “你是舰长我是舰长啊?!” 我继续向她嚷道 她低下头, 咬着嘴唇, 丢下舰装, 两只手紧紧抓着裙边… “刚才那几发! 如果你被击中! 你可能会死的啊!” 我手用力指着刚才雨点划过的天空, 又指刚才她潇洒表演的海域, 用尽最后的力气喊出了最后一句. 她好像决定了什么, 抓着裙边的手和咬着嘴唇的牙齿微微颤抖起来..随后整个身体也跟着微微颤抖起来..一直低着的头突然抬起, 我看到那双美丽的异色瞳已经噙满泪水, 憋的发红. “可是..舰长你怎么办啊..” 豆大的泪珠从她眼角掉下. “刚才那几发! 如果你被击中! 你一定会死的啊! “这次..换我愣住. 我确实没想过, 刚才如果我被击中会是怎么样..当时的我的心思, 可全都在面前这家伙身上.. “我….” 我不知道该说些什么.. //详细 “你到底知不知道啊! “ 声望皱起眉头.. “舰长有什么闪失….那不全完了吗!…” 她一只手抹着眼泪 “我….” 我完全没考虑我自己, “声望….对不起…” “道什么歉嘛…你刚刚不是挺潇洒的吗?” “真是的, 对自己的部下有点信心啊”. 这句话并没有让我多么放心她们,越是这样, 我就越担心. 我拖着湿淋淋的衣服,狼狈的站在海面上, 抬头笑着看向他, 她就像, 哦不, 她就是以胜利者的姿势站着, 右手插着腰, 左手扶着舰装的上半部分杵在海面上, 胸口激烈的上下起伏着. 是啊 ,刚才那一套动作, 潇洒的做下来, 不论是脑力上还是体力上都有着很大的消耗吧… 她笑着看着我, 异色瞳中再次绽放出别样的神采; “再怎么说, 我可是皇家海军的荣耀哦..” 频道中传出萤火虫喜悦的声音..“提督提督~成功了哦” “辛苦了, 大家都有受伤吗?” “没有啦,小擦小伤不碍事哒..” “唔…” “不管怎么说, 你们没事就好…” 我再一次看向声望, 但却在天空中看到了一些本不应该存在在这的东西, 一支鱼雷轰炸机编队从乌云中俯冲下来. 我考虑到了其一, 却忽略了其二……. “列克星敦! 战斗机拦截!” “正在准备….来不及了指挥官!” 死神吹着口哨, 鱼雷机已经拉起了, 现在..他们正在爬升… “附近空域的呢!?先撤回来一支战斗机编队再说! “ “明白! “ 几条白色的航迹已将这片蔚蓝的大海分割成了几份… “完了…….战斗机先跟着他们! “ “该死…声望!!! 快躲开啊! “ “舰….?…啊!!!!” 不行…太近了….对面的尺度拿捏的刚好, 这个距离内鱼雷引信肯定会启动……. 我看着已经动起身的声望…不行….这个密度.. 躲不开 我再一次迈起身, 准备扑向声望, 在胜利之时, 谁能接受, 谁能允许发生这种事情啊.. 但似乎总是事与愿违…我一个踉跄… “指挥官不要..” 毫无疑问..列克星敦拉住了我.. “星敦! 放手啊! “ “声望!” “啊!!!” 一声巨响伴随着声望的尖叫…鱼雷爆炸溅起了几米高的水幕, 夹杂着被阳光照照耀的金属碎片, 从天空中点点落下, 同时他被震起的身体也随之落入水中.. “声望!!.啊!!!” “指挥官, 你改变不了什么的..” 这次..你猜错了….我本来也没指望能改变什么…. 不知道是星敦放松了抓紧我的手, 还是被我自己所挣脱. 我冲向倒在水面的她, 残存不全的舰装还在忠心的提供着微乎其微的浮力..我蹲在她的身边.. “声望..醒醒,看向我啊!” 我看着声望毫无生气的异色瞳… 身边的海水逐渐被染红.. “声望, 振作一点啊! “ 我侥幸的想应该只是震了一下吧… 身上的衣服已经残破不堪.. “声望..别离开我啊…” 我再一次向她呼喊…身边的佳人已经… “指挥官..我方战斗机咬住他们了…” “不重要了….” 我红着眼睛… 抚摸这面前这张苍白的脸…期待的着她 “主…人?..” 期待着她的回应… “声望, 你怎样了?!” 我脑子里突然回想起武器装备学老师的话:“舰装设计之初…首先考虑的就是对使用人员的保护…其次是攻击力” 声望闭着眼睛眉头紧皱….“头…好痛” “没事…我这就扶你起来….”我安慰着她 “指挥官, 已发现敌方主力舰队! 他们在撤退! “ “好, 辛苦你了,星敦..” 我一边带着沙哑的嗓音说着,一边拉着声望白皙的手臂, 打算把她连人带舰装背了起来.. “指挥官, 我来帮你..” 星敦弯下腰从另一边帮我将声望背起. “主人…我自己…能…” “你伤的很重…” “大家准备一下,准备回港” 星敦站在一旁,她的声音从频道中传出.. “哎? 不乘胜追击, 把他们一网打尽吗?” “主人…你..” “不行, 声望受伤了,而且挺重…”我接着星敦回答了她打算回答的问题…也回答了另一个人… “星敦..空中留一队侦察机..走吧..” 我背着声望独自走在前面,该死…明知已经暴露了..想到了防范战列舰.怎么就把对面航母舰载机给忘了呢…而且..那群鱼雷机编队是怎么避开空中胶着的战况的? 难道是事先爬升到了一定高度? 避开了双方交战飞机? 不对啊..他们怎么知道我一定会出现在这里的? 我思索着刚才的细节….从云层上下来的..很意外…..而且…从他们迅速的俯冲下来到放雷爬升..动作一气呵成,丝毫不拖泥带水…不论是这套动作还是装备的性能…都是现在的星敦鞭长莫及的..从刚才空中胶着的战况来看, 如果对面航母有这技术…早就完爆星敦夺取制空权了啊..啧…想不通..难道是为了打我一个出其不意才故意扮猪的? 那也不对啊..直接打岂不更好? 难道这队早就来了, 只不过一直潜伏在乌云中? …嘶…应该不是这样, 因为驻留的舰载机油耗就是一个问题…而且除非对面有绝对的信心…并且如果真是这样,那驱逐舰还来干啥?我一条一条的想…一条一条的排除… “那个..指挥官..我来背一会儿吧” 星敦的声音打断了我的思绪… “不行, 还是我来吧..怎么能让你背呢?”毕竟,你也受伤了吧“毕竟,你也受伤了吧…” “啊, 我还好啦~” “之前就看你动作有些不自然, 伤的不轻吧?” 我看向星敦, 但她湛蓝的眸子并不像以往一样很自然的,充满愉悦的与我对视. “你躲什么啊? 伤哪儿了? 让我看看” “恩…不是, 有些不方便啦” 他摇了摇头红着脸和我对视道, 而眼中也恢复了往日的神采,. “唔.好吧..” 看他的神态, 我猜这伤,全港也只有我不方便看了… “那个, 我们等一等萤火虫他们吧..” 我背着声望,看着前面广阔的海面,虽说驱逐们的速度较快, 背着女仆的我又不敢走的太快. 所以,就算不等她们, 他们也应该很快就会赶上来才对.. 我感觉不太对于是在频道中喊道: “萤火虫? 萤火虫?” 但这却并没有得到萤火虫元气满满的回应. “嘶…” 有完没完了……海风逐渐萧瑟..随风漂流的乌云将仅存于这片海域的阳光严严实实的遮住. 身后声望的身体就显得比较温热..不过即使这样拖着湿淋淋的衣服的我还是不免觉得有些发冷.. “那个…指挥官…” “恩..怎么了?” 就连星敦的声音也变得弱里弱气的了… 我一回头.. “呃…” 她背向我,不如说此刻她就站在我身后. 纤细双臂环抱在一起,上衣已褪去了大半,亚麻色的过腰长发也被撩到身前,剩下几缕青丝顽抗的黏在她雪白有型的后背上.两边随风轻飘的黑色蕾丝肩带, 还有在其性感光滑的背上被这挑人之物勒出的淡淡红痕共同向我宣布着她最后的防线已经向我敞开,顺着细腻微红的红痕向前看去, 两条圆润的曲线被这最后之防线若隐若现的遮掩着. 这种犹抱琵琶的感觉正合我那恶趣味. 这丫头又没放过这个捉弄我的机会,即使她伤成了这样… 那猩红的伤口将她右肩胛骨到下方十多厘米的雪白玉脂毁坏殆尽, 而亲手破坏这天造之物的罪魁祸首整安静的插在星敦后面的舰装上…. 但此时的我呼吸确实愈发沉重,两道侵犯的实现真实无法离开那引人犯罪的身体.. 也许是她不想再让我难堪. 她扭过头侧着脸, 几缕碎发攀在俏丽的侧脸上, 继续用弱里弱气的声音说道: “指…指挥官..你在看些什么啊?” 终于意识到自己行为有些失态的我深呼吸了两口,看向他湛蓝色的眸子. 幽怨的能滴出水来的似得, 仿佛在责备我刚才的行为. 但这本应该让我自责的眼神中在结合此情此景之后却多了另一层色彩. “啊…啊…星敦..快把衣服穿上吧…” 她这诱惑的衣着和捎带媚意的眼神分明是想逼我犯错啊! 但那怎么都不能忽视的伤口……弹片划过的地方,粉色的嫩肉微微向外卷起..一定会很痛吧? 一定会的吧…那为什么,,即使这样,你也要摆出那样的姿势捉弄我呢? 啊不…你真的是在捉弄我吗?不是吧…关心自己的下级不是身为一个提督应该做的事吗? 既然是本职你为何还要做出那样的姿势啊? 你不知道吧..我其实根本就没看到你受伤啊……因为我认为,你根本就不会受那无辜之伤啊. “对不起…星敦..” “指挥官是笨蛋…” 星敦似乎并不在意伤口… “这么大声, 我听到啦…” “咳, 什么时候受伤的啊..” “在你…去拉声望的时候…”“对面..火力太猛了..”“我..需要肩负起责任啊” 再一次..列克星敦躲躲闪闪的眼神…你在辩解什么啊? “所以..你精神溜号了么?” 至于为什么溜号… “恩..恩..是的..” 她一副委屈的样子. “呼…真拿你没办法啊…” “那个…星敦…” 我觉得自己有些亏欠她…“她们都是我的姑….部下啊…” 我不去看星敦的眼睛…背着声望慢慢向前走着…“你知道的吧..我怎么会眼睁睁的看着自己可爱部下的性命受到危险呢…”“所以..不论当时换做是谁..我都会奋不顾身去做同样的事..”“当然…也包括你…”“所以啊…别让自己受伤啊” 你的指挥官会很自责的…“比起其他…我只希望你们平安…” 声望在我身后均匀的呼吸着,似乎已经睡着了…. “指挥官…” “所以说, 不要让自己再受一些无谓的伤痛了好吗?” 我回过头..看向她 我回过身,走到她身边. 牵起她白嫩的小手.. “走吧?” “恩..恩…” “那个..” “恩? 怎么了? “我看向一旁的她 “指挥官..自己也要小心哦..我决不允许你再做出那样的事..” “恩? “我楞了一下,旋即就理解了她的意思“那个…我会注意的…” “那个..星敦..你觉不觉得…刚才袭击声望的那队鱼雷机有点不对?” 我试着询问星敦,看看自己是不是漏掉了什么.. “恩..是有点奇怪呐…声望中了鱼雷之后..很快就醒来了啊..” !!!对啊..更奇怪的在这啊! 总不能说是声望他运气好吧…虽然我承认她的运气一向很好. 但这次如果也是运气的话,那也太强词夺理了啊.. “而且那只队伍很明显和我交手的不一样..” 我看向星敦..“动作麻利…在我咬上他们的编队之后..并没有慌张..而且在我试图攻击的时候,,不论是动作或是机动, 都比我厉害呐..”“但他们还没有还击..我就想只编队肯定和之前交手的不是一个队伍..”“而且…当我的飞机跟着他们到对面航母所在地之后…对面航母并没有立刻让他们降落..你不觉的很奇怪吗? “ “是啊…一般都会让自己的舰载机立刻降落补充油弹的吧…” “然后我就撤退啦~” “是啊…说到这个,你的战场嗅觉很敏锐啊” “哼哼…对了,,那个..信号恢复了吗? “ “啊….对了..” 我试着在频道里呼喊萤火虫的名字. “提督! 我们看到你们啦~ 指挥官好狡猾身边有声望姐姐和列克星敦姐姐! “ 听上去是恢复了….. “没关系, 不着急过来, 保持间距, 注意外围警戒, 我们还没有出危险区哦” 反正..天..晴了 “哼, 知道啦臭提督” “别贫啦..走吧..回家..有奖励哦~” “哎? 真的吗!真的吗?” “真的, 小孩子真好骗哦~” “哼! 提督! 我告诉你! 我生气了!” “哎呀.. 真的有啦,好吃的哦~” “哼~ 这还差不多嘛~ 唉,提督. 天晴啦..” “是啊…” 但心中的乌云何时才能拨开呢…我皱着眉头.. 伴着傍晚的海风..我们回到了港口, 我背着声望站在港口边上.. “星敦” “嗯..怎么了指挥官..?” “我先去送声望去医务室” 我看了看身后熟睡的声望.. “能麻烦你留在这儿接下萤火虫他们吗?” 我有点不好意思..这本来应该是我应做的事儿.. “唔…这个倒是..没问题..” 她站在原地, 伸出一只手指抵在嘴唇上.. “指挥官一个人..行吗?” 湛蓝色的眸子中透露着几丝担忧.. “没问题啊..” “哦~?” 星敦故意拉长音,担忧转成了怀疑..她双手背到了后面， 上身向我这边欠着。。 “恩~?” 有又一声长音..她怀疑的看向我.. 喂喂喂… “我怎么会对自己受伤的下属下手啊!” “嗯…” 星敦好像很满意似得.. “那么…声望酱就交给指挥官照顾咯” 她直起上身,歪着头微笑道 接着她转过身,望向天边海上夕阳下的几个移动的黑点.. “走吧..” 我调整了一下姿势, 背着声望向医务室一路小跑.. “该死! 事情明明就发生在我的眼前..” 我一手推开医务室大门..与其说是医务室..更不如说是…呃..浴室.. “这里..准备室” 我走到床边, 慢慢的蹲下身 “呼…” 声望被我放到了白色的床铺上 她靠着墙.. 先把舰装脱下来再说…如果没记错的话..这东西是可以被拆开的, 于是我开始琢磨这个固定在声望身上的东西要怎么拆.. “咦? 这个装置结构我好像在哪儿见过..” 我试着摆弄着舰装与声望身体连接的地方.. “咔…咔…咔..” “咔..叮” 随着一声清脆的金属碰撞声, 原本十分牢固的舰装连接处变得可以活动起来..接着很快便解开了她身上每一处与舰装连接的地方…我在次将她抱起轻放在边上的一张空床上…先不管舰装, 眼前的要是是把声望尽快送入修复池也就是浴池中.. 我看着眼前这为了我而伤的不轻的少女..我站在床边..拉过医用扫描仪将它推到了声望上方…最好别有什么内伤..我期望着… 几抹黯淡的红色像花儿一样绽放于她黑色的女仆装上, 每抹红色之下都暗藏着一道或几道深浅不一的伤口, 这样的伤口在她身上, 尤其是下身,几乎随处可见. 原本黑色的完好的连裤袜已经被撕出了几个大小不一的扣子, 开口处没有一寸肌肤是完好的, 形状不规则的伤口边缘向外翻卷露出了红色的组织.. “声望..” 我咬着牙.. 还是黑色..黑色的女仆裙同样是被撕开了四个长口子, 无数根撕裂的纤维杂乱的交错在开口处,她的腰上 胸口上 以及没有被衣物保护的双臂上..甚至是那精致的小脸上, 都在鱼雷爆炸的那一刹那都被刀子般的气浪,海浪所无情的切开.. “声望..对不起..” 我蹲下身..双臂杵在床上低着头捂住脸… “我本应该料到的…我本应该在注意制空的…我本应该早点叫你的..” 我低着头..喃喃自语.. “你本不用受到如此伤害的..” 你可千万别有事啊.. “滴…X射线扫描未发现异常, 各器官功能正常, 检测到大量外伤, 血压脉搏正常, 体温过高..” 我听着扫描仪慢吞吞一条条吐出来的结果…恨不得催它快点, 不过听着一条条钻入我耳的消息声望应该是没有什么大碍.. 等下喊下维斯塔(vestal/女灶神)和夕张过来看看吧..毕竟我不是专业的大夫.. 我抬起头, 准备站起身.. “舰长刚才一个人嘟哝什么呢…” “哎? 你醒了?” 我抬头看向声望, 她正坐在床上…低着身子, 异色瞳看着我充满了疑问.. “阁下刚刚在说什么呀?” 她身子更加往我这边倾斜, 我甚至能看到她脸上伤口内红色的嫩肉.. 这无疑再次刺痛了我的神经.. “对不起…声望..” “主人一个劲道什么歉嘛..” “这点小伤泡泡修复池就会恢复如初了哦? 你知道的主人..” “但..你明明不用遭受如此痛苦的..” 我再次看向她, 她贴的好近 “那样情况下没办法的吧, 要么我受轻伤,要么主人受重伤..” “不过..真是奇怪呢..” 声望小声嘟哝道 “主人可没有舰装哦? 女仆当然要优先保护自己的主人啊…” 声望笑着说 “可…” 我还想说些什么.. 声望伸出右手食指, 抵在我嘴唇上 “主人可没这么啰嗦哦..” 精致的小脸上洋溢着笑意.. 我低着头.. “哎?” 声望觉得眼前的主人有些不对.. “你要优先保护你自己…” “哎?” 声望的手指仍然抵在我的嘴唇上, 我头往后移了一下, 阴着脸开始说道…“在那样的情况下, 你和列克星敦是唯二的重型单位”“如果你受伤了失去大部分战斗力, 当时列克星敦也受到了来自空中的打击,”“正因为她也是带着伤的,加上原本应该由你所分担的一部分兵力此刻全部会压在她的肩上 ““而如果她也像你一样受伤, 那么敌方的全部兵力都将集中在游走于前排的驱逐舰们身上”“后果不堪设想…这也是为什么我选择撤退的原因”“我不想..” “说了这么多主人还是在担心声望嘛…” 她双手杵着下巴, 用仿佛看穿了一切的口吻打断了我的长篇大论, 异色瞳中带着一丝笑意 我突然站起身… “对,是啊! 没错,我就是担心你啊! ““所以我对…我对…” 我低下头, 一手抓着自己的头发… “没能救你感到….很自责..” 这句话随着我的一声叹息一同出口.. 声望半跪在床上, 直起上身贴着我的身体, 他的双臂环绕在我的脖子上, 就这样, 我被她的温暖轻轻的包围着… “主人, 这一切都是声望的选择..” 她抬起头, 异色瞳中几丝温柔在缓缓流转. “主人和声望都已经很努力了..所以主人不用过于自责” “而且, 我这不是没事吗?” 声望轻轻抚摸着我的脸颊.. “可恶…” “啊…主人怎么还是这样啊” “那好..” 声望双手叉着腰… “都怪主人没有及时发现敌人..” 声望皱起了眉头.. “害的本小姐自己平白无故受了伤..” 她娇嗔着.. “不过..这个因为你而被伤害的傻姑娘现在决定..” 她眼中闪过一丝戏谑 “潇洒的原谅你啦..” 我看着她一副胜利的笑脸.. “喂..这…算什么啊..” “还不是主人一直摆个苦瓜脸”.. “声望…” “怎么? “ “谢谢你…” “主人有这份心, 声望已经很高兴了…” 她再一次搂住了我的脖子.. “那个..声望..你..还没去泡澡呢吧? 小心留疤哦..” 我扭过头, 吞吞吐吐的说.. “哎? 那要怪谁啊? “ 声望扭过我的脸.. 她眨着眼.. “怪我…唔…” 她轻吻了我的脸颊.. “好了好了..主人如果偷看忍不住的话..” 她先开口道 “打住..打住..我什么都不会干的..” 声望笑了笑了.. “那声望换衣服去了” 声望转身向浴池走去.. 我掏出手机., 翻了翻通讯录, 按下了一个熟悉的号码. “嘟…嘟…嘟…嚓” 通了 “喂, 夕大博士吗? 有些事情想麻烦你调查下..” “恩..我想你会感兴趣的..” “谢谢..哎? 要添加新设备? 啊..好好好..我知道了..” 我挂下电话..这丫头还真是…. 嗯..趁着声望泡澡, 我低头看了眼表…应该还来得及… 我走出疗养楼..向厨房迈去.. 那群驱逐舰都应该回来了吧..我推开了厨房的门.. “哎? “ “小仙? 怎么在这儿啊?” 我看着在厨房中忙碌的逸仙.. 逸仙手上的动作突然停顿了一下.. “什…啊…在给您和大家做饭呢” 她没有看我一眼 逸仙熟练的切着菜..菜刀切过青菜发出咔嚓咔嚓的声音合着炉子上的锅发出的咕噜咕噜炖菜声音配上逸仙忙碌但熟练的身影..恩..有种家庭主妇的味道啊.. “小仙..要我帮忙吗?” “您那边, 没问题吗?” 逸仙再次停下了手中的动作… “呃..” 我心中十分清楚她说的问题究竟是什么.. “恩..声望她没什么事..” “我也…没事..” “没事就好…” 逸仙长舒一口气.. 我走到燃气灶面前.. 透过玻璃锅盖两份食材正在锅中随着气泡抖动…但这些似乎… “小仙..为什么有两份一样的啊?” 我看着面前的两份逸仙拿手的汤..但其中一个好像少了些什么.. “哎..这份没有香菇啊..啊…” 我立刻明白了..这份是为我准备的.. “嗯…我记着您不爱吃香菇, 但考虑到大家的口味..所以..” 逸仙打开冰箱.. “辛苦了…下次不用特意为我带份啦..” “可是每次提督都会将香菇剩下, 而且您的口味也比较重, 每次都要放较多的盐..” 逸仙看都没有看我, 但感觉她好像早就把我身上的每一根汗毛,每一处细节,每一个喜好…都已经看穿并熟记于心一样.. “提督, 来, 尝尝味道” 她转过身..将一勺汤送到我的嘴边.. “滋溜..” 我看着她紫色的眸子.. “恩…正合我口..真不愧是逸大才女, 厨艺一流啊” 我赞叹到 “我就知道” 对于我的赞赏,她的眼中没有一丝意外,反倒有些许欣慰.. “在这点上, 您真是一点没变..” 她小声说着.. 从什么时候开始的呢..我不太清楚, 逸仙似乎是读过我的大脑一样,起码从食物上来讲她对我简直了如指掌, 就像…我们之前认识一样… “我来帮忙吧..小仙” 我看了眼案板上切好的食材 “唔..还差几个炒菜是吧..没问题” 我将另一侧的燃气灶点燃, 准备倒油 “呼, 昔日的主厨如今已经成为逸大才女的副手了啊..” 我打趣道.. “不过..小仙啊, 一直以来, 辛苦你了” “您要保重身体..” 逸仙说了一句我摸不到头脑的话.. “不是还有你呢吗? 那么..开始吧..” 我用刀承着葱姜和肉一手推进了油锅里.. “好, 我会监督您放盐的…” 逸仙笑着说 “呼, 好了, 最后一道, 也完成啦” 我接过逸仙递过来的盘子, 端起炒勺将菜倒了进去. “小仙, 麻烦把大家都叫出来吧..” 我把做好的才逐一摆到桌上.. “那, 您不一起吃了吗?” “恩..我再给声望做点, 她还没吃呢..” “我知道了” 逸仙转身离开.. “那个汤..” 她挺住脚步, 侧过头来 “小冼特意做的..我当然要好好尝尝了..” “那…我先走了..” 我再次钻入厨房, 不知道声望平时口味怎样, 我呆呆的看着打开的冰箱, 一股冷气向扑面而来. 声望她算是来的较早的一波人了. 先是逸仙然后就是她了, 可这么长时间以来,我好像连她平时喜欢什么口味..都不知道… “就按照我自己的口味来吧…恩..少放点盐..” 当我再次钻出厨房的时候, 夜色已经悄然洒在了这片海域上..我拎着饭盒踏在港区的砖石路上, 我看了一眼表, 不知道她有没有泡完, 我是应该去理疗楼找她还是应该去宿舍? 如果去宿舍是不是有店不好啊… 不知不觉我已经走到了宿舍楼下… “有什么不好的, 还不是你指挥失误..” 我咬了咬牙, 准备先去浴池看看, 如果没人再去宿舍楼… 我走向浴室… //这里可以添加分支选项.列克星敦和声望 “那如果浴室有人岂不是会很尴尬..反正都到宿舍楼底下了..” 那不如先去宿舍..我转过身往回走.. “等下…我只做了一份啊..就这样去宿舍是不是不太好啊..” 我站住了脚步.. “但..她们都应该吃完饭了吧..” 我走进了楼门.. 不过等等…我好像把洗碗的重任一声不吱的丢给了逸仙… 啊啊啊..现在不是为逸仙感到抱歉的时候.. //宿舍楼的设计记着补上 我敲了敲门牌为声望的门.. 话说这里我还真没来过几次..毕竟女孩子的地方我一个男人不太好进入, 呃, 除了最开始的几次搬家具… 咦…没人吗? “咚…咚…咚” 我再次敲了敲门, 屋内静悄悄的, 没有一丝动静.. 是不是还没泡完啊? 果然应该先去浴室..我这样想着.. “咚咚” 我打算再尝试一次.. 哎哎哎? 我看了一眼门..这门没关啊! 房门虚掩着, 神色的门与深色的门框贴在一次, 如果不仔细观察, 很难发现这是一扇开着的门.. “那么…打扰了..” 我推开门.. //其实我觉得写到这就行了… 好干净啊, 我脱下鞋, 一脚踩在了声望屋柔软的毛绒地毯上.. “声望? 睡觉了吗?” 看来是我打扰到她了.. 我看着穿着睡衣, 准备下床的她. “呃..我敲了一会儿门,看到门虚掩着…就擅自进来了..” “主人还是忍不住了吗..” 她的声音好像有些沙哑.. 我把饭盒放在桌子上.. “是啊..忍不住担心你啊..” 桌子上几盒药零散的放着.. 我嘟囔道.. “声望?” 我脱下外套, 向低着头的她走去.. “主人…” 我伸出手, 撩起她额头上的刘海, 手心贴在了她的额头上.. “呼..好热..” “吃药了吗?” 我会想起刚才桌子上的几盒药.. “…”她无力的点了点头, 随后脑袋又耷拉下去了.. “我带了点吃了的, 声望, 还没吃饭吧?” 她靠在床上 “主人..亲手做的吗?” “恩..是啊, 所以你可要多吃点哦..” 我拿过来饭盒,随后坐在了她床边, 接着打开了饭盒盖子将盖子倒扣在盒底部,放在了自己腿上, 盛了一勺饭菜, 送到了声望的小嘴前.. “哼, 就这样自顾自的进入到女孩子的房间里..” “啊~” 异色瞳微微眯着, 一抹红晕悄然攀上了女仆少女的脸颊,她张开小嘴.. “啊..等下” 我收回伸出去的手.. “呼…呼..”“好像有点热..我先出吹吹” “唔…主人…你很会照顾人呐..” 她盯着我.. “好啦, 张嘴~” 声望再次张开嘴巴, 一口含住了勺子.. “味道..还行吗?” “嗯..还..还好..” “那就要乖乖吃光哦~” 我又盛了一勺饭菜.. “呜..” 我看着小嘴不断咀嚼的她.. “今天辛苦你了” “咕..嗯..没什么, 做了一些该做的而已” 女仆的眼神中恢复了一些神采… “可是…还是没能击败敌人…” “没关系..还能再打..对吧” 回想起今天那场战斗, 还有很多谜团没有解开.. “主人?..” “嗯?” 她张开小嘴 “啊~” “啊啊..这就来这就来..” 我笑着盛了一勺饭菜送入了她张开的口中 “唔…” “声望怎么跟小孩子似得..” 我看着食物咽下去的她 “哎? 这不是反差萌吗?” “行啦..都发烧了还贫..” 我将一勺盛好了的饭菜塞入她的嘴里.. “唔…咳咳…咳..咳咳” 面前的少女突然咳了起来… “我马上拿水来!” 我环顾了一下四周,,起身把它之前似乎是吃药剩下的水送到她面前.. “咳咳咳..” “唔..咕..” 他喝了口水..异样的瞳孔眨了眨.. “骗主人的啦~~” 她笑嘻嘻的说着… “……” 看得出来..战斗了一天, 在加上没能及时吃饭的她真的是饿了, 没用多久, 满满一饭盒的饭菜都被她吃了个精光.. “饱了?” 我问道.. “恩” 她眨了眨眼,但随后目光便落在了桌子上.. “呐…” 我顺着她的目光看向桌子.. “呃..那个..” 我把逸仙亲手给我做的一饭盒汤拿了过来.. “恩..饭还有..” 我打开另一只饭盒.. “不行吗..主人…” “怎么可能不行啊? 就是..这汤吧..可能..可能有点咸..” 我盛了一点汤,扮到了打开的饭盒中,汤还未完全凉掉, 一股香味扑面而来.. “恩..来吧…” “我开动啦~” 声望一下子含住了我递过去的勺子.. “呜~….” 接着她突然皱起眉.. “喏…” 我将早已准备好的水递了过去 “这…明…明..很咸啊” 他一口气干掉了一杯水.. “呃..我觉得还好吧..” 我挠了挠头.. “要不? 我再去给你做点吧” “嗯…” 她摇了摇头… “可总不能让病人饿着吧..” “可我..已经饱了呀?” “那…” “主人, 我只是想尝尝那个汤的啦~” 她笑着说道.. “真的?” “真的..” “嗯..吃完主人做的饭, 感觉都好多了啊..”“谢谢主人~” “谢啥啊…” “本来就没什么..你可是…救了我一命呢..” “没有那么严重..” 我看了看表.. “好啦, 我要走喽, “ 再留下去,,就不好了..对吧 “哎?” 声望看了我一眼.. “主人..不打算做些什么事情吗?” 她歪着头笑着看向我, 身子向我这边倾了倾.. “行了行了..好好休息吧” 我站起身,拎着盒饭. “好好..我知道啦” “那..我走咯?” 我向门口走去.. “主人~” 女仆少女轻轻的喊道 “恩? 现在想吃…” “晚~安~” “晚安…” “啊对了..下次记得关好门哦?” 咔嚓, 我向门外迈去一手带上门.. “关上了你还怎么进来啊…” 声望喝了一口水..躺在了床上..她拉了拉被子 “他自己也没吃饭吧..” “那汤也没那么咸嘛..” 声望双手抓着被边,照比之前,补充过能量之后,她现在感觉好多了.. “不过那还挺好喝的..照比那盒饭来说根本就..不是同一个人做的..吧…” “唔..还是..想吃..主人做的..” 但他已经走了啊..总不能再叫他回来吧..虽然..如果自己一个电话,那个笨蛋主人一定会回来..可..可自己怎么好意思开口啊.. “呜..” 她闭上眼睛, 暗示自己不再去奢望他的回来..少女开始调整呼吸..明天..就能见到他了..她这样想着… “咚咚咚…” “咚咚..” 声音从屋外向屋内扩散着.. “咚咚..” 声望睁开有些发沉的睡眼,她看了眼下钟..才过了一个多小时, 但她感觉好像已经过了四个小时似得.. 她光着脚..向门口走去..”反击吗…” “谁啊?..” 声望打开门.. “恩..嗨..” “主..主人?” 她有些吃惊.. “哎呀呀~主人还是忍不住寂寞吗?” 异色瞳少女戏谑的调侃道..她立刻从睡眼惺忪转为了小得意.. “那个..不是..” 我看着眼前一副小骄傲的声望.. “主人的话..做也..没关系哦” “不是不是..” 我赶紧辩解.. “哦? 主人还想用更华丽的辞藻来辩论吗?” “我回去看了一眼..还有点饺子..” “而且..我也没吃呢..” 我晃了晃手中的袋子.. “主…主人..” 她有些不敢相信.. “啊~主人~” 声望突然搂住了我的腰..拽着我往屋子里进.. “别这么大声啊喂..” “我自己进去啦..哎哎一会儿汤洒了..” (未修改)","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"镇守府手记-列克星敦","date":"2017-05-27T08:05:27.000Z","path":"2017/05/27/随笔-镇守府手记-列克星敦/","text":"由于官方没有公布出更多的关于关列克星敦的人设细节,而我又非常非常喜欢这个角色(水乌龟老师的画风真赞); 所以,我想尽力把该人物变得更立体,更活灵活现,然后我想通过写点什么东西的形式,在文章的字里行间之中把列克星敦的性格什么的表达出来,使人产生一种”啊,这就是她啊”的感觉,而不是通过罗列属性堆出一堆干巴巴的看了之后也不清楚这个人究竟是什么样的数据.但从未写过什么东西的我完全没有这种自信能驾驭住这种文章.对于文中的瑕疵还麻烦各位观众老爷指出,在下感激不尽.而对于该人物的人设补充,我没有想过符合广大虫群的口味,更多的是对我心中的完美恋人的一种表现(单身久了).也就是这个人设会夹杂着我的主管想法.完全的自嗨一下,如果你也喜欢,那在下不胜荣幸.如有雷同…那..不可能吧..毕竟我写的这么烂… &lt;&lt;镇守府手记-列克星敦&gt;&gt;BGM: 告白气球 这是一个短篇,讲述的是我遇到太太之一段时间之后但还没步入正轨那段时间里我的内心想法. 在这之前有几段日常和几段战斗…使我可爱的太太对我很感兴趣 当时的我刚来到这里不久,不久到甚至是对整个港区都还没有摸熟悉,就这样,在一个平静的上午正在享受美妙小憩的我,突然听到一阵不和谐的音乐声,是来自上头的电话,简单寒暄两局之后说让我最近准备一下,可能是有新的姑娘加入,而且不是普通的姑娘…. “什么..终于要来新人了么! “ 兴奋的我挥了一下拳头,并且为自己刚才休息被打断的懊恼感到羞愧. 毕竟初来乍到,并没有那么多资源供我招募新成员,然而即使是这样我的绝大部分资源也还用来招人了.因为..人手真的是太少了,算上我自己也只能勉强凑齐两支队伍,虽然我倾尽大部分资源但应招的人数也寥寥无几 ,偏僻的港口,新成立的镇守府,就连提督都是个刚加入的毛头小子..所以..人少似乎合乎情理,.不过这次是..特别调遣? 总之有新人愿意加入是极好的23333. 这样的话,人数够了我也就不用上场凑数了吧? 这样我也能像别的提督那样通过侦查无人机和姑娘们回传的实时影像指挥战斗了吧? 不过话说回来, 其实亲临沙场指挥战斗的感觉真的很棒啊,啊不,在这里应该叫海场什么的吧23333.和自己的姑娘们并肩作战,感受战场紧张的血腥味高度集中着神经,共同分担着责任…当然在经历了几场实战之后我也稍稍掌握了一些实战指挥上的经验,在这几次战斗中小心谨慎一直是我的信条,老实说就是怂,运用我所学的知识尽力冷静的分析所有的战术,在权衡利弊后凭借我的直觉选取其中最稳妥的一种方法行事.完全贯彻安全第一那句话. 说句漂亮话: 毕竟比起战役上的失败,使我更加不能容忍的是姑娘们受到的伤害… 随后我得知了新人具体到来的时间. 早上伴随着烦人的闹铃声与透过窗子闯进来的阳光我还是十分不情愿的起了床,打理好制服,洗个澡,吃过早饭后.享受海边早上略带凉意的海风,伴随着早上那照在身上还不太温暖的阳光.缓缓向港口走去,去迎接她的到来…呃.说到吃饭,其实在这段时间内,一直都是我在做饭的啊!不论是早中晚饭还是姑娘们的宵夜,烹饪环节都是我来做的,不过萤火虫她们也会帮着我打打下手.再加上人也不是很多,所以我们还是能应付过来的..等会儿…这都不是重点…重点是,我做饭并不好吃啊喂!我对自己的厨艺可是心知肚明的了解,属于毒不死人但味道也称不上美味的那种.因为在这之前主要是给自己做,自己嘛,一顿饭糊弄糊弄也就过去了,有句话叫什么来着–饿急了吃啥都好吃.不过姑娘们也不嫌弃我做的难吃,姑娘们都这样了我还能奢求什么呢?..以后,还得努力提高厨艺才行… 一边思索着,一边走着,一边享受着,享受着清晨的宁静,不知不觉着,来到了这儿. “啧” 抬头看向这几乎每天都要打个照面的港口,每次战斗都是从这儿出发的啊,别来无恙啊老伙计…哎? 港口上似乎..有一个人!.呃..她已经到了么..我居然迟到了! 真是..太差劲了…失礼啊.会给新人留下不好的印象吧….晚了啊…我也只能面带歉意的笑容向着那个站在港口上的少女小步快跑了过去…港口默默的记录着,忠实的记录着这儿发生过的一切… 我跑到那儿,抬头看向这个之后就要和我们朝夕相处的少女..“呃..那个..你好.你就是列克星敦吧?我是这儿的提督..” 咦?..当初看到她的第一眼就…得她在哪儿见过,接着就是一股电流弥漫全身. 仿佛触电..真不争气啊…真是过分啊…那一刻我终于体会到了之前从未体会的..什么是一见钟情… 少女抬头看向我 “啊…提督你好.” 随后一股更强烈的感觉.就像小孩子看到了自己心仪的玩具一样.满心欢喜,满脑子只有这个怎么看怎么顺眼的,恨不得立刻据为己有的玩具..为什么说是小孩子呢? 我想只有”小孩子”才会朝三暮四,明明是陪伴了自己许久的心爱之物,在被别的东西吸引的时候竟能毫不犹豫的将心爱之物抛到脑后的吧… “对..不起…我迟到了..”真是差劲啊…明明不应该迟到的.等下次放假我一定要出去买块表,我这样想着. “没有呢…是我来的太早啦”说完, 她笑着看着我… “太阳…升起来了啊,今天天气真好” “恩? 您说什么? 太阳早就升起来了哦~” “啊…不好意思..没什么..行李呢..行李就由我来拿吧.” 之后,她挥之不去的倩影在不知不觉之间已经悄然镌刻在我那颗飘忽不定的心上.在我对其他姑娘产生爱慕之情之时, 不知因何而起,脑子里所闪过的不是姑娘的笑容,不是对姑娘携手的憧憬,当然也不是姑娘婀娜的身姿.而是一缕亚麻色的长发,如丝一般柔顺的长发.漫不经心的散射着使人安心的光泽.我时常想想,这缕情丝摸起来究竟是何种感觉啊,感受亚麻色的细流因重力从指间缝隙滑过,从心间划过…. …… 来到这儿不久我就发现离镇守府不远处有个沙滩,虽说海滩这东西在这儿随处可见. 但这片沙滩的景色似乎比别的更美: 踩着脚下的细软海沙,抬头望向不远处从青翠后山蔓延过来的山体,山体到这儿似乎被盘古的斧子砍断了一样露出了整齐的灰色岩石形成的一个不高断崖, 以及远处被阳光关怀的波光粼粼与背后透过镇守府玻璃所发出的灯光交相辉映构成了一副..啊不..总觉得缺了点什么.所以我无聊时总是喜欢去那儿走走,听听海浪想向我诉说什么, 在沙滩上一步一个脚印漫步海边,寻找缺失的东西. 不过,那天早上有的可不仅是美景. 清空伴随着略带有咸湿感的海风.我静静地站在离海的不远处,海风时而吹过,给这炎炎夏日带来一阵短暂的清凉,当然也不解风情的吹动起她过腰的秀发,两侧鬓角也随风倾动.她就那样静静站在那,享受着夏日的碧海蓝天享受太阳的温度与带走分度带来清凉的海风. 而我就尽力隐藏自己的气息狡猾的享受着眼前这一切.. 你站在桥上看风景,看风景的人在楼上看你明月装饰了你的窗,你装饰了别人的梦. 终于,还是被她发现了, 虽然我尽力隐藏自己的气息,一般来讲我这样做是没人会注意到我这个普通的一抓一大把的青年的.而在此时普通则转变称为了更为普通的–泛滥.纵使我如此小心翼翼避免打破眼前这副找了好久,好不容易才构成的完美画卷. 不过接下来的事情似乎也就顺理成章了. 果然,她转过身来,两手勾在一起,很自然的搭在前面,可爱的小脑瓜向一侧歪着.我只好硬着头皮向她走去 ,总不能低着头吧? 我还没那么怂的说.这一抬头到好.我的眼睛很自然的和她那湛蓝色的眼眸对上了…那两潭湛蓝的清水略带笑意,像是在嘲笑我一样. “咦…? 我发现了哦..从刚才开始,我就发现了有一股奇怪的视线在注视着我呢…那股视线究竟是..谁的呢?” “呃…..那个…” //“不过..不讨厌呢” 面对突如其来的话语彻底清空了我的脑子,场面一度十分尴尬,至少我这么觉得.其实我现在很想说一句: 还能是谁的啊..别明知故问啦.但可能是被这烤炉似的太阳关怀的太久,所以我敢肯定脸上现在一定很有颜色…而且..偷看别人的确不对..尤其是偷看自己的漂亮下属..所以我完全说不出来话.. . 而此时我脑中有产生了另一种想法: 决不能浪费了这难得的独处时光..不管怎么样,赶紧说点什么好啊, 赶紧做点什么好啊..可是我到底应该说些什么好啊.如果我此时什么都不说,什么都不做…我的直觉已经先开了口: 你以后肯定会后悔的… “那个…”风又一次轻轻吹动起那一缕秀发…同时..风也第一次带来一股来自她的芳香… “别…别盯着人家看那么久啊…” “啊…对不起!” 卧槽了..我刚才到底做了什么啊! 真是的..,绝对会被讨厌的吧! 话说,真的有那么久吗? 明明感觉只有一会儿啊… “真 的 哦…” 一阵俏皮的话语突然钻入了我毫无防备的耳朵 呃…天! 原来她早就发现了啊…这使我觉得不用看也能知道那蓝色眼眸中嘲笑意味肯定更浓了…等等..这句话是什么意思..什么叫真的哦? 合着她知道我刚才在想什么? 我…惊了..她咋知道我刚才在想什么啊? 我刚才有说出来吗? 没有的吧..tan90°的吧? 我明明只是在想啊…难道来到我府的姑娘出现了超能力者? “你是怎…” “呐..你是不是想说? 我是怎么知道的呢? 噗…提督你知不知道…你想说的都早已写在了你脸上哦?” “啊..? 是..这样啊…有那么夸张吗?” 我不好意思的苦笑说道; 明明对自己的隐息技术很有自信的..但看她一副得意的样子…只是湛蓝的眸子却已无嘲意..只剩下笑.像是在说: 你的自以为是小伎俩被我看穿了哦~..不过即使这样.这样本应该使人恼火的话语..对着这张可爱的小脸蛋却完全..完全发不起来脾气啊…反而觉得更加可爱了…为什么这么熟练…如果这世上谁能对着这么可爱的脸蛋发脾气…那我不禁怀疑这货脑子是不是受了什么刺激? 不过为什么? 为什么她没有生气呢? 一般来讲,被偷看了这么久,无论是谁都会生气对吧? 我不理解… “哎? 明明在偷看人家…提督自己感觉不到吗? 真是过分.. “ 啊..果然…果然还是没有生气啊…生气的话无论如何也不能说出如此温柔的话语吧, 别看她眉头轻皱表面一副气鼓鼓的样子, 但那双湛蓝里透入出的却是..一种我捉摸不透的….期待? “对不起…下次..”下次..我一定要跟你站在一起… “不讨厌哦” “呃…!”她..她..她… “哎? 哈哈哈.提督脸红了.提督脸红了” “唉…真拿你没办法…” 当时这段我记得很清楚…应该说是..永远忘不了吧..她的芳香.. 此处可有本? 啊…太太别打我…我错了我错了….“好..好近..”我抬头看向她.想继续揣摩那藏在蓝宝石深处的秘密…可我却清晰的感到心跳咚咚咚的骤然加速. 此时的已她一只脚向前迈了一小步稍稍翘起脚尖,另一条脚脚尖点在原地,双臂已经背到了背后.整妙曼的身姿向我这边倾斜着..使我正好能看到斜下方白花花一片…正是制服下所包裹着的两团柔软…那独有的芳香再一次钻入鼻腔…这丫头..故意犯规… “不过..你别以为这样就能逃过一劫哦?” “要杀要剐随便你…”我心里一沉..我已经放弃挣扎了…但温柔的口气却使我没有感到多少紧张… “才没有那么过分呢! 我只是想要..提督为我亲手做顿饭而已啦..不过是..只为我哦” 什么?..什么!..居然..有人单点让我做饭..还是个这么可爱的姑娘..我受宠若惊啊…以至于不过脑子说错了话…“什么…你还没吃够啊? “ “恩..? 提督您说什么…?” 我不知道此时的我脸上是什么样的表情…..但她是又恢复了的老样子…那不带任何责备意思的生气就可以看出我他丫的又说错话了…不过真的..我差点动手戳一下她气鼓鼓的可爱脸蛋.. “啊..不不不…不是那个意思..我是说..真的有那么好吃吗?”现在挽救似乎还来得及..我今天真是得罪到她了…对不起啊…不过… “哼…反正我想吃啦”湛蓝的眸子发散出别样的神采… “成…小意思..那..走吧?”不过…接下来就轮到我主动了…谢谢你给予我力量… “恩~” 下集预告..我对于在海滩太太对我的主动感到不好意思..身为男生完全应该自己主动才对啊…但对于可爱的她又觉得这样被带节奏感觉很好..不过不论如何..我都要自己带带节奏! 是时候展现本人真正的厨艺了…太太..我们厨房见!","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"如何稍微有点瑕疵的把3D定制女仆2的模型导入到Maya2017","date":"2017-05-24T15:56:02.000Z","path":"2017/05/24/如何稍微有点瑕疵的把3D定制女仆2的模型导入到Maya2017/","text":"Warning:萌新向 众所周知,我是个死宅,我觉得我死的还可以,但算不上是硬核死宅,主要是因为囊中羞涩以及时间大部分被我用来扯淡了,不过像3D妹抖2这种游戏我还是十分喜欢的.233333 然后在一个月黑风高的晚上,本死宅正摩拳擦掌跃跃欲试准备重温我大I社的经典作品的时候,某群里的一个dalao突然问我3D定制女仆2能不能捏男的.. 是时候展现我..等等..Eexcuse me？我是不是撸多了看错了什么? 男..男的?!什么鬼!…算了是时候展现我高超の捏脸技术辣…那么开工..于是我抱着大佬的大腿开始讨论电影大业（大雾 那么.呃..首先.怎么把3D妹抖2里的模型导出来呢..于是这个大佬给我发了个链接(你..为什么这么熟练啊?)： https://tieba.baidu.com/p/4347623203?qq-pf-to=pcqq.group 是贴吧某大神自制的十分牛逼的3D妹抖插件，可以把3D妹抖2的人物模型导出为PMX格式（似乎是mmd的工程文件？）或OBJ格式，具体使用方法在帖子里，我就不重复叙述了。。 于是我展现了我神(手)乎(残)其(至)神(极)の捏脸技术..果断捏了个帅气的小♀哥♀哥: (再次感叹下..3D妹抖2这渲染真牛逼) 哎.,等等..说好的小哥哥! 这胸是怎么一回事啊,不过即使这样我也真觉得这个男装少女挺帅的.. 真没得治了..或许某些MOD可以解决此问题..不过这不是重点.. 重点是接下来到了激动人心的打开Maya环节.讲道理..这是我第二次打开Maya…真·萌新; [文件-&gt;导入].导入完我看了一眼吓得本萌新喵躯一震..口列娃纳尼? 为啥身体被分成了三段…这是何等的恶人才能干出的事儿啊(大雾).讲道理我一开始以为是Maya对obj格式的兼容问题.但有人告诉我,Maya对obj资呲的不错.然后我又想到是不是导出的问题?..我甚至考虑了3D妹抖2是不是只建了这三段的模型?….不过后来再次证明了我是个sb而且图样图森破… 在我不经意之间,鼠标轻划过屏幕勾勒出了一片…一片网格?! 凭借这本萌新敏锐的自觉.和十多分钟的摸索.我觉得.导出没问题.也不是3D妹抖建模的锅..只是..它变!透!明!了!..结果果然是透明度的问题..调回来就好辣..(不过他为啥会变透明啊? 求大佬详解~) 我们可以在[大纲视图]中查看透明的区域.并在右边的[属性编辑器]中把透明度调回来; 以此类推..我们还可以把贴图打上..按下[数字6]进入Maya的着色显示模式..(我才不会告诉你们我一开始没开着色显示弄了半个点的贴图…..被自己傻到);然后发现有的贴图已经被打上去了..而有的地方还是单调的模型灰..先把皮肤打上吧…看到右边的[属性编辑器]里有个[颜色]选项了吗? 看到颜色后面那个长的跟一个门似得的黑色框型小按钮了吗? 就是他,点一下,找到你存放模型的目录..找到长的跟皮肤似得的贴图..打开 让我们把所有的贴图都打上..不知道为啥有的地方贴图只有渲染才能看见.比如眉毛睫毛….而且那个神一般的阿诺德渲染器本baka完全玩不转啊.. 没有渲染: 五官不知道为啥都没了 阿诺德渲染器: 讲道理,这渲染效果真吊,就是那眉毛和眼睛是什么鬼啊! (求哪位大佬告诉我~) Maya软件渲染:终于有一个正常点的了.小伙…还挺帅的嘛..不过因为是CPU渲染..速度嘛..你们感受一下,我I7-6700HQ渲染540960分辨率的3D运动模糊产品级别,一帧用了6S.. *硬件2.0渲染: 速度快了一个数量级….但是效果..我真不会调","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"Maya","slug":"Maya","permalink":"http://yoursite.com/tags/Maya/"}]},{"title":"C++笔记-C++11的一些新标准","date":"2017-05-17T15:47:06.000Z","path":"2017/05/17/C++笔记-C++11的一些新标准/","text":"一些C艹11的新标准…反正都是些泥萌大家都知道的过时东西; initializer_list C++11提供了模板类initializer_list,可将其作用于参数,如果类有接受initializer+list作为参数的构造函数,则初始化列表就语法只能用于该构造函数,且列表中的元素必须是同一种类型或可以转换为同一种类型;这个类包含了成员函数begin()和end()用于获得列表范围;123456789101112#include&lt;initializer_list&gt;double sum(std::initializer_list&lt;double&gt; il)&#123; double tot = 0; for(auto p= il.begin(), p!=il.end(), p++) tot += *p; return to;&#125;int main()&#123; double sum(&#123;2.5,3.1,4&#125;);&#125; decltype 关键字decltype将变量的类型声明为表达式指定的类型; decltyoe(x) y让y的类型与x相同,x是一个表达式; 比如:123456double x;int n;decltype(x*n) q; // q和x*n的类型一样 即 doubledecltype(&amp;x) pd; //pd和&amp;x的类型一样 即 *doubledecltype(n) n1; //n1的类型和n一样 即intdecltype((x)) d1;//d1的类型为 &amp;double 这在定义模板的时候挺有用的,因为只有在模板被实例化的时候才能够确定类型;12345template &lt;typename T, typename U&gt;void ef(T t, U u)&#123; decltype(T*U) tu; &#125; 返回类型后置 C++11新增了一种函数声明语法,在函数名和参数列表后面指定返回类型1auto f1(double ,int)-&gt; double; // 返回double 他能让你使用decltype来指定模板函数类型:12345template &lt;typename T, typename U&gt;auto my(T t, U u) -&gt; decltype(t * u)&#123; ...&#125; 这里解决的问题是,在编译器遇到my的形参列表之前,T U还不在作用域内,因此必须使用后置返回类型; 模板别名: using = 他能够创建模板别名,和typedef不同的是,他可以用于模板部分具体化:123template &lt;typename T&gt; using arr = std::array&lt;T,12&gt;;//上述具体化模板array&lt;T,int&gt; 将int设置为12array&lt;int,12&gt; a1; //于是这句话可以替换为:arr&lt;int&gt; a1; //替换为这句; 作用域内枚举 传统的C++枚举提供了一种创建名称常量的方式; 但如果在同一个作用域内定义两个枚举,则他们不能重名;C++11新增了一种枚举解决了这些问题,这种枚举使用class或struct定义:12enum class NEW1&#123;never,sometimes,often&#125;;enum struct NEW2&#123;never,lever,server&#125;; 基于范围的for循环 对于内置数组以及包含方法begin()和end(0的类,可以使用基于范围的for循环来简化编程工作;123double prices[5] = &#123;4.99,10.99,6.87,7.99,8.49&#125;for(auto x : prices) cout &lt;&lt; x &lt;&lt; endl; x将以此为prices中1的每个元素的值,x的类型应与数组元素的类型匹配; 吐过想修改数组或容器里的元素可以使用引用:123vector&lt;int&gt; vi(6)for(auto &amp;x : vi) x = rand();; 默认的方法和禁用方法 假设要使用某个默认的函数，而这个函数由于某种原因没有自动创建,例如提供了移动构造函数,则编译器不会自动创建默认的构造函数,复制构造函数和复值构造函数.在这情况下使用default显示的声明这些方法的默认版本:123456class Someclass&#123; public: someclass(someclass &amp;&amp;) someclass() = default; //使用编译生成的默认构造函数&#125; 关键字delet可以禁止编译器使用特定方法,且适用于任何函数,例如,要禁止复制构造函数可以:12345678910 class Someclass &#123; public: someclass(someclass &amp;&amp;) someclass(const someclass &amp;) &#125;``` ### 管理虚方法: override 和 final 如果一个基类声明了一个虚方法，而我在派生类中提供了不同的版本..特征标不匹配,这将隐藏旧版本; class A{ int a;public: A(int i = 0) : a(i){} virtual void f(char ch) const {…};} class B{public: B(int i = 0) : a(i){} virtual void f(char ch) const {…};}``` 由于B定义的是f(charch)而不是f(char ch); 这导致了程序不能使用: bingo(10); b.f(&#39;@&#39;) 类似这样的代码; 所以我们可以使用override,把它放在f(char * ch) 后面.如果与基类方法不匹配则将视为错误; 而final解决了另一个问题.可能想禁止派生类覆盖特定的虚方法,谓词可在参数后面加上final;例如,下面的代码禁止A的派生类重新定义f().virtual void f(char ch) const final{...};","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-输入,输出和文件(三)","date":"2017-05-16T11:36:11.000Z","path":"2017/05/16/C++笔记-输入,输出和文件(三)/","text":"封面作者 文件输入输出### 简单文件I/O 如果想让程序写入文件,可以这样来做: 1. 创建一个 ofstream 对象来管理输出流; 2. 将该对象与特定的文件关联起来; 3. 使用cout的方式使用该对象,将输出写入文件; 4. 首先包含头文件#include&lt;fstream&gt;,然后声明一个ofstream的对象: ofstream fout 接下来,必须将这个对象与特定的文件关联起来,可以使用open,假设要打开文件jar.txt: ofstream.open(&quot;jar.txt&quot;); 也可以使用构造函数将这俩构步合成一条语句: ofstream fout(&quot;jar.txt&quot;); 然后以使用cout的方式使用fout,比如要把”boy next door”放到文件中: fout &lt;&lt; &quot;boy next door&quot; ; 由于ostream是ofstream类的基类,因此可以使用所有的ostream方法.另外以这种方式打开文件来进行输入时,如果没有要打开的文件,则将新创建一个.如果有了,则打开并清空文件,并输入; 读取文件和写入文件差不多: 1. 创建一个ifstream对象来管理输入流; 2. 将该对象与特定的文件关联起来; 3. 已使用cin的方式使用该对象; 同样,首先包含头文件#include&lt;fstream&gt;,然后声明一个ifstream对象,将它与文件名关联起来:12345ifstream fin;fin.open(&quot;my.txt&quot;);//或者写成一句话ifstream fin(&quot;my.txt&quot;); 可以像使用cin那样使用fin;12345678910char ch;fin &gt;&gt; ch;char buf[80];fin &gt;&gt; buf;fin.getline(buf,80);string lien;getline(fin,line); 当输入和输出流对象过期时,流到文件的链接将会关闭,但不会删除流; 可以使用close()显式关闭:12fout.close; //断开文件与写入流的链接fin.close; //断开文件与输出流的链接 下面是书上的一个栗子,输入文件名将某些信息写入文件,并读出;:12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string filename; cout &lt;&lt; &quot;输入文件名: &quot; &lt;&lt; endl; cin &gt;&gt; filename; ofstream fout(filename.c_str()); fout &lt;&lt; &quot;梦里不知秋已深,余情岂是为他人\\n&quot;; cout &lt;&lt; &quot;out DONE&quot; &lt;&lt; endl; fout.close(); ifstream fin(filename.c_str()); cout &lt;&lt; &quot;File name :&quot; &lt;&lt; filename &lt;&lt; endl; char ch; while(fin.get(ch)) cout &lt;&lt; ch; cout &lt;&lt; &quot;DONE&quot; &lt;&lt; endl; fin.close();&#125; ### is_open() 使用isopen检查文件是否被打开;1if (!fin.is_open()) &#123;...&#125; ### 文件模式 文件模式描述的是文件将如何被使用: 读 写 追加等:123ifstream fin(&quot;banjo&quot;,model);ofstream fout();fout.opem(&quot;harp&quot;,mode2); ios_base类定义了一个openmode类型;可以选择ios_base类中定义的多个常量来制定模式: ○ ios_base::in 打开文件,以便读取 ○ ios_base::out 打开文件,以便写入 ○ ios_base::ate 打开文件并移动到文件尾 ○ ios_base::app 追加到文件尾 ○ ios_base::true 如果文件存在,则清空 ○ ios_base::binary 二进制文件 ○ ios_base::app 保留文件内容,并在文件尾追加新信息 ○ 文件模式 | ios_base::ate 以指定模式打开并移动到文件尾; ifstream open()使用ios_base::in作为模式参数的默认值; ofstream open()方法使用ios_base::out|ios_base::trunc作为默认值; 可以使用 | 运算符来合并格式;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-输入,输出和文件(二)","date":"2017-05-11T07:58:06.000Z","path":"2017/05/11/C++笔记-输入,输出和文件(二)/","text":"封面作者 下面是cin の show time cin如何检查输入 不同版本的抽取运算符(&gt;&gt;)查看输入流的方法是相同的.他们跳过空白(空格,换行符,和制表符)直到遇到非空白字符,但在C的单字符模式下,&gt;&gt;它读取从非空白字符开始,到与目标类型不匹配的第一个字符之间全部内容; 例如:123int elevation;cin &gt;&gt; elevation;//假设键入-123Z 运算符将读取前四个.因为他们都是有效的整数.但Z不是.有的时候键入可能没有满足程序的期望,比如输入的是ZCAR,而不是-123Z,这种情况下程序不会修改elevation的值,并返回0;12345678910111213141516171819#include &lt;iostream&gt;int main()&#123; using namespace std; cout &lt;&lt; &quot;Enter&quot; &lt;&lt; endl; int sum = 0; int input; while(cin &gt;&gt; input) &#123; sum += input; &#125; cout &lt;&lt; &quot;&quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; return 0;&#125;/* 输入-123Z 输出: 流状态 流状态由3个ios_base元素组成: eofbit,badbit, failbit.其中没一个元素都是一位(1或0); 当cin操作达到文件末尾时,它将设置eofbit; 当cin操作未能读取到预期的字符时,他将设置failbit; 当一些无法诊断的失败破坏流时,它将设置badbit;当三个状态为都为0时表示一切顺利,(他为什么这么熟练啊); 下表列出了位和一些报告或改变流的ios_base方法; 书上的表格奉上: 其他istream类方法 ○ get(char &amp;)和getline(void)方法读取下一个输入字符,即使他是空格,制表符,换行符; ○ get(插入, int, char)和getline(char,int,char)在默认情况下读取一行; 单字符输入: get(char &amp;) 假设有如下代码123456789101112int ct = 0;char ch;cin.get(ch);while(ch != &apos;\\n&apos;)&#123; cout &lt;&lt; ch; ct++; cin.get(ch);&#125;cout &lt;&lt; ct &lt;&lt; endl;//输入: I C++ clearly. &lt;Enter&gt;//输出: I C++ clearly. 通过get(ch),代码读取,显示,并考虑空格和可打印字符;假设程序使用&gt;&gt;:123456789101112int ct = 0;char ch;cin.get(ch);while(ch != &apos;\\n&apos;)&#123; cout &lt;&lt; ch; ct++; cin&gt;&gt;get(ch);&#125;cout &lt;&lt; ct &lt;&lt; endl;//输入: I C++ clearly. &lt;Enter&gt;//输出: IC++clearly. 代码将首先跳过空格.并且循环不会停止.因为&gt;&gt;跳过了换行符,所以换行不会被赋值给ch,所以循环不会被终止. 成员函数get(void) get(void)尘缘函数还读取空白.但使用返回值来将输入传递给程序: 12345678910int ch = 0;char ch;ch cin.get();while(ch != &apos;\\n&apos;)&#123;cout &lt;&lt; ch;ct++;ch = cin.get()&#125;cout &lt;&lt; ct &lt;&lt; endl; 到达文件尾的时候.cin.get(void)都会返回值EOF(iostream的一个符号常量).可以利用此特型这样来读取输入: 12345int ch;while((ch = cin.get()) != EOF)&#123; //...&#125; 字符串输入: getline(),get()和ignore(); istream &amp; get(char *, int, char); istream &amp; get(char *, int); istream &amp; getline(char * int, char) istream &amp; getline(char * int) 第一个参数用于放置输入字符串的内存单元的地址.第二个参数是要读取的最大字符数+1(+1是因为要存结尾的空字符);第三个参数用于指定用作分节符的字符;上述函数都在读取最大数目的字符或遇到换行符后停止; get()和getline()最大的差距就是,get()将换行符留在输入流中,也就是截下来的输入操作首先看到的是遗留下的换行符;而getline()舍弃换行符; ignore()接受两个参数: 一个是数字,指定要读取的最大字符数; 另一个是字符,用作输入分界字符;比如: cin.ignore(255,&#39;\\n&#39;) 调用读取并丢弃接下来的255个字符,或直到遇到个换行符为止; 1234567891011121314151617181920212223242526272829//书上例子:#include &lt;iostream&gt;using namespace std;const int Limit = 255;int main()&#123; char input[Limit]; cout &lt;&lt; &quot;使用getline()接受字符串: &quot; &lt;&lt; endl; cin.getline(input,Limit,&apos;#&apos;); cout &lt;&lt; &quot;输出: &quot; &lt;&lt; endl; cout &lt;&lt; input &lt;&lt; &quot;\\n Done&quot; &lt;&lt; endl; char ch; cin.get(ch); cout &lt;&lt; &quot;下一个输入字符是:&quot; &lt;&lt; ch &lt;&lt; endl; if(ch != &apos;\\n&apos;) cin.ignore(Limit,&apos;\\n&apos;); cout &lt;&lt; &quot;使用get()接受字符串:&quot; &lt;&lt; endl; cin.get(input, Limit, &apos;#&apos;); cout &lt;&lt; &quot;输出:&quot; &lt;&lt;endl; cout &lt;&lt; input &lt;&lt; &quot;\\n Done&quot; &lt;&lt; endl; cin.get(ch); cout &lt;&lt; &quot;下一个输入字符是:&quot; &lt;&lt; ch &lt;&lt; endl; return 0;&#125;//注意getline() 丢弃分界字符# 而get()不会 其他istream方法 read(), peek(), gcount() putback(). read()函数读取指定数目的字节,并将它们存在指定的位置中,并返回istream &amp; 且 read()不会在输入后加上空字符,对于处理文件的输入输出,通常和write()配合使用; 比如:12char gross[144];cin.read(gross,144); //读取144个字符,并将他们存在gross中 peek()函数能查看下一个字符,但不提取他. while((ch = cin.peek()) != &#39;.&#39; &amp;&amp; ch != &#39;\\n&#39;) //用while检查下一个字符是否是&#39;.&#39;或&#39;\\n&#39;; gcount() 方法返回最后一个非格式化抽取方法(非&gt;&gt;)读取的字符数; 但对于strlen()还是setlen速度较快… putback() 函数将一个字符插入到输入字符串中.被插入的字符串将是下一条输入语句读取的第一个字符..他返回istream &amp; (可以拼接);并且他允许将字符插入到不是刚才读取的位置..是不是想到了什么? peek..没错peek()的效果相当于使用get()读取一个字符,然后使用putback()放回去….","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"在细雨纷飞的那天她送了我一个礼物","date":"2017-05-09T11:42:25.000Z","path":"2017/05/09/随笔-珊瑚海/","text":"&lt;&lt; 在细雨纷飞的那天她送了我一个礼物&gt;&gt; “果然还是下雨了啊,果然应该拿把伞啊..”起床的时候就觉得窗外阴沉的天空能拧出水似得,她也再三让我带把伞,以防万一.不过本着嫌麻烦的精神,我还是收回了原本伸向抽屉的手.伞什么的,拿着太麻烦了啊.说不定一会儿就放晴了呢.还好雨下的不大,淅淅沥沥的细雨落到脚下的青石砖上发出纱纱的声响混杂着自己踩在积水上的声音现在回想起早上立的flag真想给自己一耳光,当然,是早上的自己.不过上头也是有毒,大早上开的哪门子会啊?不过我感觉这次事情可能不小,不然也不至于我话都没说完传话员就把电话挂了唉..这才几天的太平日子啊..想到这我加快了跑向车站的脚步 山雨欲来风满楼推开那沉重的会议室大门..昏暗的指挥室内充斥着水手们常抽的劣质香烟的味道,一张椭圆形的桌子占据了四分之一的房间,而周围一群穿着海军军装的男人围在桌边更是显得这个临时指挥室的狭小.唯一一个披着海军军装坐着的男人显得有些格格不入.稀疏的胡茬和有些凌乱的莫西干式发型说明了这个男人已经有几天没整理过自己的仪容,你肯定能从他沧桑的脸上读出战争,血,与火的味道..,眼前这个刚毅,睿智,有些许疲惫但眼神却依旧犀利紧盯着桌子上的海图的男人就是我的上级.弗莱彻上将..“现在,我们扯平了”..”在袭击图拉吉后.我们跟对面的情报就拉平了” ….. 夜深了,我吹着海风独自走在那片熟悉的海滩上,战争已经悄然打响.. “恩哼,睡不着吗? 我可爱的的指挥官?” 面对突如其来的耳语我着实吓了一跳,但旋即又陷入在那温柔而又有些俏皮的语气中,无法自拔….“咳咳..别总是捉弄我啊..太太..好歹我也是一个小指挥官啊…” “唉? 又要什么嘛?..难道太太是一个指挥官对自己下属应有的称呼嘛? 我可爱的不严谨先生?” 听到这话我不禁老脸一红..确实..太太是我对她的爱称…她的温柔就好像傍晚的海风…. “咳咳,,指挥官,,你脸红了哦”“呐,今天淋雨了吧?” “呃…是..啊, 我以为这天不能下雨的..” “哎哎?! 发烧了吗?”蓝色的眼眸里充满了担忧… 不知不觉太太已经面对面离我很近了,她翘起脚,伸出手心贴在了我的额头上,我甚至能闻到她身上独有的洗发香波的味道,,湛蓝色的大眼睛看着我..亚麻色的头发在不算亮的舰船灯光的照射下竟发出了银白色的光泽…. “真好~ 看来没事呢” 面对此情此景我再也忍不住内心的感情..右手手掌顺势放在她那可爱的小脑袋上..尽情享受这丝滑的秀发接着右手顺着侧面的鬓角滑下..左手拨开似乎有些碍事的刘海,低下头轻吻在她额头上..她..好温柔啊.. “啊…呀…指挥官好狡猾…” 我笑笑不予否认. “对了指挥官,,这个给你..人家花了一天的假期给你挑的..好好珍惜哦..” 话说这好像是我第一次收到女孩子的礼物,,,而且还是我下属送的,,,不不不,,这都不是重点..重点是..太太送我东西了!我打开盒子,里面的手表发出滴答滴答的声响,深褐色的表带,黄白色的表盘…好生喜欢 “恩~ 来让我帮你带上~”“啊..啊…星敦. 谢谢,,,..这次.就…全靠你了” “指挥官,你的脸已经红的跟苹果一样了哦..” “啥? 有..有..有吗?” “有的啦..指挥官也要加油哦…我回去啦..晚安哦~”她走了…留下了在海风中还没缓过神的我,,,我现在只能感觉到手腕传来的金属独有的那种有些凉丝丝的温度..以及…脸上的温度与湿润..还有那太太头发的芳香…","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"_>如你所见.这里都是我的随笔","date":"2017-05-09T11:33:29.000Z","path":"2017/05/09/README/","text":"欢迎来到本智障瞎写的地方,这里充斥着平时的脑洞与灵光的乍现,不过..不论是文笔还是剧情都是小学生作文级の水准,不喜勿喷.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"C++笔记-输入,输出和文件","date":"2017-04-25T14:58:17.000Z","path":"2017/04/25/C++笔记-输入,输出和文件/","text":"封面作者 流和缓冲区 C++程序把输入和输出看作字节流.输入时,程序从输入流中抽取字节;输出时,程序将字节插入到输出流中.输入流中的字节可能来自键盘/硬盘/程序. 输出流中的字节可以流向屏幕/打印机/硬盘/程序.换句话说,流充当了程序和流源(流的来源)或流目标之间的桥梁.C++程序处理输出的方式将独立于其去向,因此管理输入分: ○ 将流与输入去向的程序关联起来 ○ 将流与文件链接起来. 换句话说,输入流需要两个链接,每端各一个.文件端链接来源,程序段链接将流的输出部分转存到程序中; 同样对输出流的管理包括将输出流连接到程序以及将输出目标与流关联起来; 通常使用缓冲区可以更高效地处理输入输出.缓冲区是用作中介的内存块,将信息从设备传输到程序或从程序传输给设备的临时存储工具. 缓冲方法从磁盘上读取大量信息,讲这些信息存在缓冲区中,然后每次从缓冲区里读取一个字节,因为从内存中读取单个字节的速度非常快.所以这种方法更快更方便.达到缓冲区尾部之后程序将从磁盘上读取另一块数据.输出时程序首先填满缓冲区.然后把成块数据传给硬盘,并清空缓冲区,已被下一批输出使用.这被称为刷新缓冲区(flushing the buffer). 流,缓冲区和iostream文件 ○ streambuf类维缓冲区提供内存,并提供了用于填充缓冲区,访问缓冲区内容,刷新缓冲区和管理缓冲区内存的类方法. ○ ios_base 类表示流的一般特征,如是否可读取,是二进制流还是文本流等; ○ ios类基于ios_base,其中包括了一个指向streambuf对象的指针成员; ○ ostream类是从iios类派而来的, 提供了输出的方法; ○ istream 类也是从ios类派来的,提供了输入方法; ○ iostream类是基于istream和ostream类的 因此继承了输入输出方法; 一些ostream方法 除了大家喜闻乐见的方法之外,ostream类提供了put()方法和write()方法.前者用于显示字符.后者用于显示字符串. 最初,put()方法原型如下: ostream &amp; put(char); 当前标准被模板化,以适用于wchar_t: cout.put(&#39;W&#39;); 还可以将数值类型参数(如int)用于put,这样: cout.put(65) // 输出A cout.put(66.3) //转为66 输出B write()方法显示整个字符串,模板原型如下: basic_ostream&lt;charT,traits&gt;&amp;write(const char_type* s,streamsize n) 第一个参数提供了要显示的字符串的地址,第二个参数指出要显示多少个字符串. 下面是一个及其智障的示例:123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; const char * s1 = &quot;Florida&quot;; const char * s2 = &quot;Kansas&quot;; const char * s3 = &quot;Euphoria&quot;; int len = strlen(s2); cout &lt;&lt; &quot;Increasing LOOP&quot; &lt;&lt; endl; int i; for(i = 1; i &lt;= len; i++) &#123; cout.write(s2,i); cout &lt;&lt;endl; &#125; cout &lt;&lt; &quot;Decreasing LOOP:&quot;; for(i = len; i &gt; 0; i--) cout.write(s2,i) &lt;&lt; endl; cout &lt;&lt; &quot;Exceeding string length: &quot; &lt;&lt; endl; cout.write(s2,len+5) &lt;&lt; endl; return 0;&#125; 需要注意的是,write()方法并不会在遇到空字符的时候自动停止打印.而是只打印指定数目的字符.即使超出了字符的边界. 刷新输出缓冲区 在屏幕输出时,程序不必等到缓冲区被填满.列如,将换行符发送到缓冲区之后.将刷新缓冲区.多数C++实现都会在输入即将发生的时候刷新缓冲区. 可以手动控制刷新缓冲区: 控制符flush刷新缓冲区,而控制符endl刷新缓冲区并插入一个换行符.12cout &lt;&lt; &quot;Kazusa&quot; &lt;&lt; flush;cout &lt;&lt; &quot;Setsuna&quot; &lt;&lt; endl; 其实控制符也是函数 可以直接调用flush()来刷新缓冲区: flush(cout); 用cout进行格式化### 1.修改显示时使用的计数系统: ostream类是从ios类派生而来的.而后者是从ios_base派生来的.ios_base类里都是描述格式状态的信息.例如,一个类成员中某些位决定了使用的技术系统,而另一个成员决定了字段宽度.通过使用控制符(manipulator),可以控制显示整数时使用的计数系统.比如控制字段宽度,和小数尾数. 要控制整数以十进制,十六进制,八进制.可以使用dec,hex和oct控制符. 如hex(cout) 或 cout&lt;&lt; hex 将其技术系统格式状态设置为16进制; 下面是一个比较智障的栗子1234567891011121314151617 int main()&#123; cout &lt;&lt; &quot;Enter an integer;&quot;; int n; cin &gt;&gt; n; cout &lt;&lt; &quot;n n*n&quot; &lt;&lt;endl; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n*n &lt;&lt; &quot;(decimal)&quot; &lt;&lt; endl; cout &lt;&lt; hex; cout &lt;&lt; n &lt;&lt; &quot; &quot;; cout &lt;&lt; n*n &lt;&lt; &quot; (hexadecimal)&quot; &lt;&lt; endl; cout &lt;&lt; oct &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n * n &lt;&lt; &quot;(octal)&quot; &lt;&lt; endl; dec(cout); cout &lt;&lt; n &lt;&lt; &quot; &quot;&lt;&lt; n *n &lt;&lt; &quot; (decimal)&quot; &lt;&lt; endl; return 0;&#125; ### 2.调整字段宽度 在上个代码示例中,输出各列没有对齐,可以使用width函数将长度不同的数字放到宽度相同的字段中: int width(); int width(int i); 第一种格式返回字段宽度的当前设置,第二种格式将宽度设置为i个空格,并返回以前的字段宽度值,且width方法只影响将显示的下一个项目.然后字段宽度将恢复为默认,下面是个书上的例子:12345678910111213141516171819202122232425262728 #include&lt;iostream&gt; int main() &#123; using namespacestd int w = cout.width(30); cout &lt;&lt; &quot;default field width = &quot; &lt;&lt; w &lt;&lt; endl; cout.with(5); cout &lt;&lt; &quot;N&quot; &lt;&lt; &apos;:&apos;; cout.width(8); cout &lt;&lt;&quot;N*N&quot; &lt;&lt; endl; for(long i=1; i &lt;= 100; i*=10) &#123; cout.width(5); cout &lt;&lt; i &lt;&lt; &apos;:&apos;; cout.width(5); cout&lt;&lt;i*i&lt;&lt;endl; &#125; return 0; &#125; /*输出: default field width = 0 N: N*N 1: 1 10: 100100: 10000 */ 上诉输出中,值在字段中右对齐,右对齐时空格被插入到值的左侧,cout通过加入空格来填满整个字段,用来填充的字符叫做填充字符(fill chararcter),并且右对齐是默认的;w的值为0是因为cout.width(30)返回的是以前的字段宽度,而不是刚设置的值. ### 3.填充字符 默认使用空格填充字段中未被使用的部分,可以用fill()成员来改变填充字符,而且新的填充字段将一直有效,直到更改他为止,用星号填充:cout.fill(&#39;*&#39;)1234567891011121314151617181920 int main()&#123; cout.fill(&apos;*&apos;); const char * staff[2] = &#123;&quot;waldo Whipsnade&quot;,&quot;Wilmarie Wooper&quot;&#125;; long bonus[2] = &#123;900,1350&#125;; for(int i = 0; i &lt; 2; i++) &#123; cout &lt;&lt; staff[i] &lt;&lt; &quot;: &quot;; cout.width(7); cout &lt;&lt; bonus[i] &lt;&lt; endl; &#125; return 0;&#125;/*输出waldo Whipsnade: ****900Wilmarie Wooper: ***1350*/ ### 4.设置浮点数的显示精度 浮点数精度的函数取决于输出模式.在默认模式下,他指的是显示的总位数.在定点模式和科学模式下,精度指的是小数点后面的位数.C++默认精度为6; 将精度设置为2: cout.precision(2)12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; float p1 = 20.40; float p2 = 1.9 + 8.0 /9.0; cout &lt;&lt; &quot;p1:&quot; &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; &quot;p2:&quot; &lt;&lt; p2 &lt;&lt; endl; cout.precision(2); cout &lt;&lt; &quot;p1(2): &quot; &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; &quot;p2(2):&quot; &lt;&lt; p2 &lt;&lt; endl; return 0; /* 输出p1:20.4p2:2.78889p1(2): 20p2(2):2.8*/ ### 5.打印末尾的0和小数点 下面的函数调用使cout显示末尾的小数点:cout.setf(ios_base::showpoint);showpoint是ios_base类中定义的类级静态常量;123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; float p1 = 12.40; float p2 = 1.9+8.0/9.0; cout.setf(ios_base::showpoint); cout &lt;&lt; &quot;p1:&quot; &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; &quot;p2:&quot; &lt;&lt; p2 &lt;&lt; endl; cout.precision(2); cout &lt;&lt; &quot;(2)p1&quot; &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; &quot;(2)p2&quot; &lt;&lt; p2 &lt;&lt; endl; return 0;&#125;/* 输出p1:12.4000p2:2.78889(2)p1:12.(2)p2:2.8*/ ### 6.setf() ios_base类有一个受保护的数据成员,其中的各位(标记) ,像开关一样分别控制着格式化的各个方面,打开开关称为设置标记,并将相应位设为1.而setf()函数提供了一种调整标记的途径: setf()有俩原型.第一个: fmtflags setf(fmtflags); fmtflags是bitmask类的typedef,用于存储标记格式;ios_base定义了代表位值的常量: ○ ios_base::boolalpha: 输入和输出bool值,可以为true或false; ○ ios_base::showbase: 对于输出,使用C++基数前缀 0 0x ○ ios_base::showpoint: 显示末尾的小数点 ○ ios_base::uppercase: 对于十六进制输出 使用大写字符E表示法 ○ ios_base::showpos: 在整数前面加上+ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main()&#123; int temp = 63; cout.setf(ios_base::showpos); cout &lt;&lt; &quot;showpos: &quot;&lt;&lt;temp &lt;&lt; endl; cout &lt;&lt; hex &lt;&lt; &quot;hex: &quot; &lt;&lt; temp &lt;&lt; endl; cout.setf(ios_base::uppercase); cout.setf(ios_base::showbase); cout &lt;&lt;&quot;uppercase &amp; showbase: &quot; &lt;&lt; temp &lt;&lt; endl; cout.setf(ios_base::boolalpha); cout &lt;&lt; &quot;boolalpha(true): &quot; &lt;&lt;true &lt;&lt; endl; return 0;&#125;/*输出showpos: +63hex: 3fuppercase &amp; showbase: 0X3Fboolalpha(true): true*/ 第二个seft()原型接受两个参数,并返回以前的设置: fmtflags setf(fmtflags, fmtflags); 函数的这种格式用于设置由多位控制的格式选项; 第一参数和以前一样,也是一个包含了所需设置的fmtlages值.第二参数指出要清除第一个参数中的哪些位; setf()函数是ios_base类的一个成员函数;由于这个类是ostream的基类,因此可以使用cout来调用该函数: ios_base::fmtflags old = cout.setf(ios::left, ios::adjustfield) 要恢复之前的可以: cou.setf(old,ios::adjustfield); 书上的例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; //使用左对齐，显示加号，显示尾随零，精度为3 cout.setf(ios_base::left,ios_base::adjustfield); cout.setf(ios_base::showpos); cout.setf(ios_base::showpoint); cout.precision(3); //使用e表示法,保存旧的格式设置 ios_base::fmtflags old = cout.setf(ios_base::scientific,ios_base::floatfield); cout &lt;&lt; &quot;左对齐:&quot; &lt;&lt; endl; long n; for(n = 1; n &lt; 41; n+= 10) &#123; cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|&quot; &lt;&lt; endl; &#125; //改为内对齐 cout.setf(ios_base::internal,ios_base::adjustfield); //恢复默认浮点显示样式 cout.setf(old,ios_base::floatfield); cout &lt;&lt; &quot;内对齐:&quot; &lt;&lt; endl; for(n = 1; n &lt; 41; n+= 10) &#123; cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|&quot; &lt;&lt; endl; &#125; //右对齐,使用定点计数法 cout.setf(ios_base::right,ios_base::adjustfield); cout.setf(ios_base::fixed,ios_base::floatfield); cout &lt;&lt; &quot;右对齐:&quot; &lt;&lt; endl; for(n = 1; n &lt; 41; n+= 10) &#123; cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|&quot; &lt;&lt; endl; &#125; return 0;&#125;/* 输出:左对齐+1 |+1.000e+000 |+11 |+3.317e+000 |+21 |+4.583e+000 |+31 |+5.568e+000 |内对齐+ 1|+ 1.00|+ 11|+ 3.32|+ 21|+ 4.58|+ 31|+ 5.57|右对齐 +1| +1.000| +11| +3.317| +21| +4.583| +31| +5.568| */ ## 6.iomanip 如果嫌前面那些麻烦的话,头文件iomanip中提供了一些其他控制符,他们能提供前面的部分服务.setprecision(),setfill() 和 setw(); setprecision()控制符接受一个指定精度的整数参数; setfill()控制符接受一个指定填充字符的char参数;setw()控制符接受一个指定字段宽度的整数参数;并且他们都能通过cout链接起来; 书上的例子:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;int main()&#123; using namespace std; cout &lt;&lt; fixed &lt;&lt; right; cout &lt;&lt; setw(6) &lt;&lt; &quot;N&quot; &lt;&lt; setw(14) &lt;&lt; &quot;square root&quot; &lt;&lt;setw(15) &lt;&lt; &quot;fourth root&quot; &lt;&lt; endl; double root; for(int n = 10; n &lt;= 100; n+=10) &#123; root = sqrt(double(n)); cout &lt;&lt; setw(6) &lt;&lt; setfill(&apos;.&apos;)&lt;&lt; n &lt;&lt; setfill(&apos; &apos;) &lt;&lt; setw(12) &lt;&lt; setprecision(3) &lt;&lt; root &lt;&lt; setw(14) &lt;&lt; setprecision(4) &lt;&lt; sqrt(root) &lt;&lt; endl; &#125; return 0;&#125;/* 输出 N square root fourth root....10 3.162 1.7783....20 4.472 2.1147....30 5.477 2.3403....40 6.325 2.5149....50 7.071 2.6591....60 7.746 2.7832....70 8.367 2.8925....80 8.944 2.9907....90 9.487 3.0801...100 10.000 3.1623*/","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-算法(STL)","date":"2017-04-21T14:53:05.000Z","path":"2017/04/21/C++笔记-算法(STL)/","text":"封面来源 算法的一些通用特征: STL文档使用模板参数名称来表示参数模型的概念.比如下面的copy()原型:12template&lt;class InputIterator, class OutputIterator&gt;OutputIterator copy(InputIterator first, OutputIterator last, OutputIterator result); 所以标识符InputIterator和OutputIterator都是模板参数,看名字一眼就能看出来区间参数必须是输入迭代器或更高级的,而只是结果存储的迭代器必须是输出迭代器或更高级的. STL的有些算法有两个版本: 就地算法(in-place algorithm)和复制算法(copying algorithm),顾名思义,sort()就是就地算法的例子:函数完成时,结果被存放在原始数据的位置上; 而copy()函数将结果发送到另一个位置,所以他是复制算法;STL对此的约定是,复制版本的名称将以_copy结尾. 比如replace()函数,他将所有的old_value替换为new_value,则它的复制版本为:123template&lt;class InputIterator,class OutputIterator, class T&gt;OutputIterator replace_copy(InputIterator first,Inputiterator last, OutputIterator result, const T&amp; old_value, const T&amp; old_value); 对于复制算法的约定是: 返回一个迭代器,指向复制的超尾(最后一个值后面)的位置 另一个常见变体是: 有些函数是根据函数应用于容器元素得到的结果来执行操作的.他们通常以_if结尾,比如replace_if:123456789template &lt; class ForwardIterator, class UnaryPredicate, class T &gt; void replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value)&#123; while (first!=last) &#123; if (pred(*first)) *first=new_value; //pred()是个一元谓词,根据其真假来决定是否将new_value赋给first ++first; &#125;&#125; 一个使用STL的例子:假设编写一个程序,让用户输入单次,希望最后得到一个按照输入顺序排列的单次列表,一个按照字母排序的列表(忽略大小写),并记录每个单次被输入的次数(不考虑标点,数字,符号): 输入和保存我们可以用vector&lt;&gt;: 1234vector&lt;string&gt; word;string input;while(cin &gt;&gt; input &amp;&amp; input != &quot;quit&quot;) word.push_back(input); 然后我们可以创建一个set对象,然后将vector中的单词复制(使用插入迭代器)到集合中.集合自动对其排序,无需使用sort(); 且集合只允许一个键出现一次因此也无需调用unique().至于忽略大小写…可以使用transfor,将vector中的数据复制到集合中.使用一个转换函数将函数转成小写;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;void display(const string &amp; a)&#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;char toLower(char ch)&#123; return tolower(ch);&#125;string &amp; ToLower(string &amp; st)&#123; transform(st.begin(),st.end(),st.begin(),toLower); return st;&#125;int main()&#123; vector&lt;string&gt; words; cout &lt;&lt; &quot;输入单词(quit退出): &quot; &lt;&lt; endl; string input; while (cin &gt;&gt; input &amp;&amp; input != &quot;quit&quot;) words.push_back(input); cout &lt;&lt; &quot;原始数据: &quot; &lt;&lt; endl; for_each(words.begin(),words.end(),display); cout &lt;&lt; endl; set&lt;string&gt; word_s; transform(words.begin(),words.end(), insert_iterator&lt;set&lt;string&gt;&gt;(word_s,word_s.begin()),ToLower); cout &lt;&lt; &quot;list: &quot; &lt;&lt; endl; for_each(word_s.begin(),word_s.end(),display); cout &lt;&lt; endl; map&lt;string,int&gt; wordmap; set&lt;string&gt;::iterator si; for(si = word_s.begin();si != word_s.end(); si++) wordmap[*si] = count(words.begin(),words.end(),*si); cout &lt;&lt; &quot;新数据: &quot; &lt;&lt; endl; for_each(word_s.begin(),word_s.end(),display); return 0;&#125; 其他库 slice类对象可用作数组索引,他们表示的是不是一个值而是一组值.slice对象被初始化为三个整数值: 起始索引,索引数,跨距.起始索引是第一个被选中的元素的索引,索引数指出要选择多少个元素,跨距表示元素之间的距离.例: slice(1,4,3)创建的对象表示选择四个元素,他们的索引分别是1,4,7,10;从索引开始加上跨距得到下一个元素的索引. 把第1,4,7,10元素设为10:1varint[slice(1,4,3)] = 10; 一个valarrat和slice混用的例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;valarray&gt;#include &lt;cstdlib&gt;using namespace std;const int SIZE = 12;void show(const valarray&lt;int&gt;&amp; v, int cols)&#123; int lim = v.size(); for(int i = 0; i &lt; lim; ++i) &#123; cout.width(3); cout &lt;&lt; v[i]; if(i % cols == cols -1) cout&lt;&lt; endl; else cout &lt;&lt; &apos; &apos;; &#125; if(lim % cols != 0) cout &lt;&lt; endl;&#125;int main()&#123; valarray&lt;int&gt; vint(SIZE); int i = 0; for(; i &lt; SIZE; ++i) vint[i] = rand() % 10; cout &lt;&lt; &quot;原始数据: &quot; &lt;&lt; endl; show(vint,3); valarray&lt;int&gt; vcol(vint[slice(1,4,3)]); cout &lt;&lt; &quot;第二列: &quot; &lt;&lt; endl; show(vcol,1); valarray&lt;int&gt; vrow(vint[slice(3,3,1)]); cout &lt;&lt; &quot;第二行: &quot; &lt;&lt; endl; show(vrow,3); cout &lt;&lt; &quot;将最后一列设为10:&quot; &lt;&lt;endl; show(vint,3); cout &lt;&lt; &quot;将第一列设置为下两个的总和:&quot; &lt;&lt; endl; vint[slice(0,4,3)] = valarray&lt;int&gt;(vint[slice(1,4,3)]) + valarray&lt;int&gt;(vint[slice(2,4,3)]); show(vint,3); return 0;&#125; 模板initializer_list(C++11) 模板initializerlist(在头文件initializer中)是C++11新增的,可以使用初始化列表语法将STL容器初始化为一系列值:12vector&lt;double&gt; payments(45.99,39.23,19.95,89.01);//创建一个包含四个元素的容器,并用列表中的四个值来初始化这些元素; 这么做可行是因为容器包含了将initializer_list作为参数的构造函数.比如vector就包含了一个将initializer_list作为参数的构造函数,因此上述声明和下面的等同;1vector&lt;double&gt; payments( &#123;45.99,39.23,19.95,89.01&#125; ); 这是C++11新增的通用初始化语法,可以使用{}而不是()来调用构造函数,并且在类有接受initializer_list作为参数的构造函数则将优先使用:1shared_ptr&lt;double&gt; pd&#123;new double&#125;; 所有initializer_list元素的类型都必须相同,但编译器有的时候将尽心必要转换:12vector&lt;double&gt; payments &#123;45.99, 39.23, 19, 89.0&#125;;//19会转为19.0,但不能进行窄化转换,也就是不能隐式的把上面的double转为int; initializer_list使用例子,另外他还包含成员函数begin() end() size():123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;double sum(initializer_list&lt;double&gt; il)&#123; double s = 0; for(auto p = il.begin(); p != il.end(); p++) s += *p; return s;&#125;double average(const initializer_list&lt;double&gt; &amp; av)&#123; double s = 0; double n = av.size(); if(n &gt; 0)&#123; for(auto p = av.begin(); p != av.end(); p++) s += *p; s = s/n; &#125; return s;&#125;int main()&#123; cout &lt;&lt; &quot;List 1: sum = &quot; &lt;&lt; sum(&#123;2,3,4&#125;); cout &lt;&lt; &quot;ave = &quot; &lt;&lt; average(&#123;2,3,4&#125;) &lt;&lt; endl; initializer_list&lt;double&gt; dl = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; cout &lt;&lt; &quot;List 2: sum = &quot; &lt;&lt; sum(dl); cout &lt;&lt; &quot;ave = &quot; &lt;&lt; average(dl) &lt;&lt; endl; dl = &#123;16.0, 25.0, 36.0, 40.0, 64.0&#125;; cout &lt;&lt; &quot;List 3: sum = &quot; &lt;&lt; sum(dl); cout &lt;&lt; &quot;ave = &quot; &lt;&lt; average(dl) &lt;&lt; endl; return 0;&#125; 可以按值传递initializer_list对象,也可以按引用传递;STL是按值传递;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-函数对象","date":"2017-04-17T14:58:36.000Z","path":"2017/04/17/C++笔记-函数对象/","text":"作者 很多STL算法都使用函数对象也叫函数符.函数符是可以以函数方式与()结合使用的任意对象.包括函数名,指向函数的指针,和重载了()运算符的类对象(即定义了函数operator()()的类)可以定义这样一个类:12345678910class Linear&#123; private: double slope; double y0; public: Linear(double s = 1, double y = 0) : slope(s),y0(y)&#123;&#125; double operator() (double x)&#123;return y0+slope * x;&#125;&#125;; 这样重载的()运算符将能够像函数那样使用Lineat对象:123Linear f2(2.5,10.0);double y1 = f1(12.5);double y2(0.4) 其中y1将使用表达式0+112.5来计算,y2将使用表达式10.0+2.50.4来计算.y0和slope的值来自对象的构造函数,而x的值来自于operator()()的参数; 话说回来,还记得for_each()的第三个参数吗? 通常,第三个参数可以是常规函数,也可是函数符.那么如何声明第三个参数呢?STL使用模板解决了这个问题,for_each的原型看上去:12345template&lt;class InputIterator, class Function&gt;Function for_each(InputIterator fist,InputIterator last,Function f);//ShowReview()的原型如下:void ShowReview(const Review &amp;); 这样表示符ShowReview的类型为void(*)(const Review &amp;),将其赋给模板参数f,也是Function的类型,Function是可以表示具有重载的()运算符的类类型.f是指向函数的指针,而f()调用该函数.如果参数是个对象,则f()是调用其重载的()运算符的对象; 函数符概念 ○ 生成器(generator) 是不用参数就可以调用的函数符 ○ 一元函数(unary function) 是用一个参数可以调用函数符,返回bool值的一元函数的是谓词(predicate) ○ 二元函数(binary function) 是用两个参数可以调用的函数符,返回bool值的二元函数是二元谓词(binary predicate) 例如:sort()的一个版本,将二元谓词作为其第三个参数:12bool WorseThan(const Review &amp; r1, const Review &amp; r2);sort(books.begin(),books.endl(),WoresThan); list模板有一个将谓词作为参数的remove_if()成员,该函数将谓词应用于区间中的所有元素,如果谓词返回true则删除这些元素,例如删除链表three中所有大于200的元素:1234bool tooBig(int n)&#123;n &gt; 100&#125;;list&lt;int&gt; scores;scores.remove_if(tooBig); 下面这个类演示了类函数符适用的地方,假设要删除另一个链表中所有大于200的值,且如果能将被比较的值作为第二个参数传给tooBig(),那我们就可以使用不同的值调用该函数辣,但谓词只能有一个参数,这可咋整..:123456789template&lt;class T&gt;class TooBig&#123; private: T cutoff; public: TooBig(const T &amp; t) : cutoff(t) &#123;&#125;; bool opeator()(const T &amp; v)&#123;return v &gt; cutoff;&#125;&#125; 这里,一个值(v)是作为函数参数传递的,另一个cutoff是由类的构造函数设置的. 下面的程序演示了这种技术:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;class TooBig&#123;public: T cutoff; TooBig(const T &amp; t) : cutoff(t) &#123;&#125; bool operator()(const T &amp; c)&#123;return c &gt; cutoff;&#125; //重载()&#125;;void outint(int n)&#123;cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;int main()&#123; TooBig&lt;int&gt; f100(30); //创建实例初始化cutoff为30 int vals[10] = &#123;10,20,30,40,50,60,70,80,90,100&#125;; list&lt;int&gt; a(vals,vals+10); //创建俩链表 list&lt;int&gt; b(vals,vals+10); //输出链表 for_each(a.begin(),a.end(),outint); cout &lt;&lt; endl; for_each(b.begin(),b.end(),outint); cout &lt;&lt; endl; a.remove_if(f100); //此时cutoff为30.即在a中删除所有大于30的数 b.remove_if(TooBig&lt;int&gt;(50));//创建匿名对象 for_each(a.begin(),a.end(),outint); cout &lt;&lt; endl; for_each(b.begin(),b.end(),outint); cout &lt;&lt; endl; return 0;&#125; f100是一个声明的对象,而TooBig(50)是个匿名对象; 综上,我们可以将接受两个参数的模板函数转化为接受单个参数的函数对象例如:123456789101112template &lt;typename T&gt; //接受两个参数的模板函数bool tooBig(const T &amp; t1,const T &amp; t2)&#123; return t1 &gt; t2&#125;;template&lt;typename T&gt; //接受单个参数的模板函数对象class TooBig&#123;private: T val;public: TooBig(const T &amp; t) : val(t)&#123;&#125; bool operator()(const T &amp; ot) &#123;return t &gt; val;&#125;&#125; 即可以这么写:1234TooBig&lt;int&gt; my(30);int x;cin &lt;&lt; x;if( my(x))&#123;...&#125; //和tooBig(x,100)一样 调用my(x),相当于调用了tooBig(x,100),换句话说类TooBig是个函数适配器,可以使函数满足不同的接口; 预定义的函数符: transform()函数有两个版本,第一个版本的前两个参数是指定容器区间的迭代器,第三个参数将结果复制到哪里的迭代器,第四个参数则是一个函数对象(函数符);比如:12transform(l.begin(),l.end(),out,sqrt);//你就当l是个容器实例,out是个输出迭代器,sqrt是开平方;//这就是吧容器l里的挨个开平方,并发送到输出流 第二个版本与第一个版本有所不同,版本二是一个二元函数,其第三个参数为第二个区间的起始位置,后面的参数不变,所以说如果我们想算俩容器里每个数的平均值就可以:12double add(double x, double y)&#123;return x + y&#125;;transform(l.begin(),l.end(),l2.begin(),out,add); 但这样吧….就得给每种类型都定义一个add,,,所以让我们用模板吧比如plus&lt;&gt;..那么让我们看看SLT预定的几个函数符: 自适应函数符合函数适配器 上表列出的预定义函数符都是自适应的,自适应函数符携带了表示参数类型和返回类型的typedef成员,他们分别是:result_type,first_argument_type和second_argument_type.比如plus对象的返回类型被表示为plus::result_type,这是int的typedef; 函数符自适应性的意义在于: 函数适配器对象可以使用函数对象,并使用typedef成员.例如,接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回类型匹配的变量. 比如现在我们想将容器l里的每个元素都乘上2.5..那么跟上面那个一样我们是用:1transform(l.begin(),l.end(),out,multiplies); 但是吧multiplies是个二元函数…所以我们得把接受两个参数的函数符(multiplies)转换成接受一个参数的multiplies.我们使用神奇的bind1st();假设现在有个二元函数对象f2(),可以把f2()的第一个参数的值跟f2()相关联,所以我们对multiplies的二元转一元就可以写成:12bind1st(multiplies&lt;double&gt;,2.5); //将mu和2.5相关联.2.5将用于mu的第一个参数; 第二个参数在此:12transform(l.begin(),l.end(),out,multiplies&lt;double&gt;,2.5);//这样容器l里的每个元素都将作为mu的第二个参数;达到乘2.5的目的","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-泛型编程(续","date":"2017-04-11T14:35:05.000Z","path":"2017/04/11/C++笔记-泛型编程(续/","text":"封面来源 容器种类 STL具有容器概念和容器类型.概念是具有名称的通用类别,容器类型是可用于创建具体对象的模板. 容器概念 容器概念描述了所有STL容器都需要满足的一些要求.他是个概念化的抽象基类,说他是一个概念化的抽象基类,是因为容器类不真正使用继承机制. 所有的容器都提供某种特定的特征和操作,下表对一些通用特征进行了总结: 上表中的复杂度表示执行操作所需的时间,从快到慢依次为: ○ 编译时间 ○ 固定时间 ○ 线性时间 如果复杂度为编译时间,则操作将在编译时执行,执行时间为0;固定复杂度意味着操作发生在运行阶段,但独立于对象中的元素数目;线性复杂度意味着时间与元素数目成正比; C++11新增的容器要求 下表列出了C++11新增的通用容器要求,其中rv表示类型为X的非常量右值,如函数返回值,另外要求X::iterator满足正向迭代器的要:; 序列(sequence) 序列概念增加了迭代器至少是正向迭代器的要求,并且要求元素按严格的线形顺序排列,即存在第一个元素,最后一个元素,除了端点的俩元素外,每个元素前后都分别有一个元素,且不会在两次迭代之间发生变化.这7个STL容器类型都是序列: deque,forward_list,list,queue,priority_queue,stack,vector; 下表表示了序列所需要的操作,t表示类型为T(存在容器中的值的类型)的值,n表示整数,p,q,i,j表示迭代器: 因为模板deque,list,queue,priority_queue,stack和vector都是序列的概念模型,所以他们中的一些还可以使用下表所列出的操作: 详细介绍 vector: 前面说过了,不做赘述 deque: deque模板类表示双端队列,实现类似vector,他支持随机访问,但不同的是:从deque对象的开始位置插入和删除元素的时间是固定的,而vector是在结尾处提供了固定时间的插入和删除,在而别的地方都是线性时间,但vector的速度似乎快一点.. list: list模板类表示双向链表.除了第一个和最后一个元素外,每个元素都与前后的元素相连接.他和vector的区别在于,list在链表中任意位置插入和删除的时间是固定的(废话).list擅长的是元素的快速插入和删除.但他不支持数组表示法和随机访问.从容器中管插入或删除元素后,链表迭代器指向的位置不变,但数据不同.然后插入新元素并不会移动已有元素,只是修改链接信息. list的成员函数,Alloc有默认值: ○ void merge(list &amp; x) //将链表x与调用链表合并.两个链表必须排序,合并后的链表在调用链表中,x为空.这个函数复杂度为线性时间; ○ void remove(const T &amp; val) //从链表中删除val的所有实例,复杂度为线性时间; ○ void sort() //使用&lt;运算符排序,复杂度为NlogN; ○ void splice(iterator pos, list x) //将链表x的内容插入到pos的前面,x为空,复杂度为固定时间; ○ void unique() //将连续的相同元素压缩为单个元素(删除重复元素),复杂度为线性时间 list的示例代码 insert()和splice()之间的区别在于:insert()将原始区间的副本插入到目标地址,而splice()则将原始区间移动到目标地址,且splice()方法执行后,迭代器指向的元素不变. forward_list(C++11): forward_list容器类实现了单链表.也就是每个节点都只连接到下一个节点,而没有连接到前一个节点.所以他只需要正向迭代器,并且是不可反转容器; queue: queue模板类是个适配器类.他让底层类(默认为deque)展示典型的队列接口.但他限制比deque多,不允许随机访问队列,不允许遍历队列,他可以: ○ bool empty()const //如果队列为空,返回true,否则返回false ○ size_type size()const //返回队列中元素的数目 ○ T&amp; front() //返回指向队首元素的引用 ○ T&amp; back() //返回指向队尾元素的引用 ○ void push(const T&amp; x) //在队尾插入x ○ void pop() //删除队首元素 priority_queue: 该类是另一个适配器,支持的操作和queue一样,区别是在priority_queue中最大的元素会被移动到队首; 构造函数参数:12priority_queue&lt;int&gt; pql;priority_queue&lt;int&gt; pq2(greater&lt;int&gt;) stack: 该类也是个适配器,和queue相似,他给底层类(默认是vector)提供了典型的栈接口;但他不允许随机访问栈元素,不允许遍历栈,只能用一些栈的基本操作,如压入,弹出,查看栈顶值,检查元素数目,测试栈是否为空,他还可以: ○ bool empty() const //如果栈为空则返回true,否则返回false ○ size_type size() const //返回栈中元素数目 ○ T&amp; top() //返回指向栈顶元素的引用 ○ void push(const T&amp; x) //在顶部插入x ○ void pop() //删除栈顶元素 array(C++11): 非SLT容器,其长度为固定,所以也就没有调整容器大小的操作(如push_back(),insert()),但定义了一些成员函数如operator [] ()和at().可将很多STL算法用于他(如copy(),for_each()); 关联容器(associative container) 关联容器是将值于键值关联在一起,并使用键来查找值.表达式X::key_type指出了键的类型.他们提供了对元素的快速访问(查找).STL提供了四种关联容器: set, mulitiset,map,multimap. 前两种在文件set.h中,后两者在map.h中定义. 最简单的关联容器是set,其值类型与键值相同,键是唯一的,对于set来说值就是键; multiset类似set,只是可以有多个键值相同,比如: 如果建和值的类型为int,则multiset对象包含的内容可以有1,2,2,2,3,5等.而在map中,值于键的类型不同,键和值是一一对应的;而multimap和map差不多,只是一个键可以与多个值相关联; set示例:12345 const int N = 6; string s1[N] = &#123;&quot;ass&quot;,&quot;we&quot;.&quot;can&quot;,&quot;booy&quot;,&quot;next&quot;,&quot;can&quot;&#125;; set&lt;string&gt; A(s1,s1+N); ostream_iteratior&lt;string,char&gt; out(cout,&quot; &quot;); copy(A.begin(),A.end(),out); 和别的容器相似set也使用模板来制定要储存的值类型,与其他容器相似,set也有一个将迭代器区间作为参数的构造函数.上述代码片段输出表明键是唯一的,虽然数组里有俩for,但如果两个集合包含相同的值,则这个值将在并集中只出现一次,所以for在集合中只出现了一次,这是因为set的键值是唯一的,且集合是经过排序的:cout: ass booy can next we set_union()函数接受五个迭代器参数,前两个迭代器定义了第一个集合的区间,接下来的两个参数定义了第二个集合的区间,最后一个参数是输出迭代器,指出将结果集合复制到什么位置.举个栗子,要显示集合A,B的并集可以:1set_union(A.begin(),A.end(),B.begin(),B.end(),ostream_iterator&lt;string,char&gt; out(cout,&quot; &quot;)); 假设要将记过放到C集合中,而不是现实他,则最后一个参数应该是个匿名insert_iterator,将信息复制给C:1set_union(A.begin(),A.end(),B.begin(),B.end(),insert_iterator&lt;set&lt;string&gt;&gt;(C,C.begin())); 方法lower_bound()将键作为参数并返回一个迭代器,迭代器指向集合中的第一个不小于键参数的成员,upper_boun()将键作为参数并返回一个指向集合中第一个大于键参数的成员.函数set_intersection()和set_difference()粉蝶查找交集和获得两个集合的差,参数与set_union()相同; multimap示例: 基本的multimap声明使用模板参数指定键的类型和存储的值类型.他一个键可以与多个键值相关联.下面声明创建一个multimap对象,键类型为int,值类型为string,第三个模板参数是可选的,用于对键排序,默认使用less&lt;&gt;:1multimap&lt;int,string&gt; codes; 如果要用区号作为键来存城市名字,一种方法是创建个pair,再将它插入:12345pair&lt;const int, string&gt; item(213,&quot;Los Angeles&quot;);codes.insert(item);//或创建匿名pair对象:codes.insert(pair&lt;const int, string&gt; (213,&quot;Los Angeles&quot;);) 对于pair对象,可以使用first和second访问其两个部分:12pair&lt;const int, string&gt; item(213,&quot;Los Angeles&quot;);cout &lt;&lt; item.first &lt;&lt; item.second &lt;&lt; endl; 成员函数count()接受键作为参数,返回具有该键的元素数数目.lower_bound()和upper_bound()将键作为参数,并分别返回集合中第一个不小于键参数的成员和第一个大于键参数的成员;equal_range()用键做参数,返回两个迭代器,表示的区间与该键匹配. 无序关联容器 无需关联容器也是将值与键关联起来,并用键找值,但底层差别在于关联容器基于树形结构,而无序关联容器基于哈希表,速度奇快.比如unordered_set,unordered_map,unordered_multiset,unordered_multimap;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-泛型编程","date":"2017-04-05T14:20:46.000Z","path":"2017/04/05/C++笔记-泛型编程/","text":"封面作者 STL是一种泛型编程.面向对象编程关注的是程序的数据方面,而泛型编程关注的是算法.泛型编程旨在编写独立于数据类型的代码.在C艹中通常使用的工具是模板,模板是的能够按照泛型定义函数和类,而STL通过通用算法更近了一步. 为何使用迭代器 模板使得算法独立于存储类型,而迭代器使算法独立于使用的容器类型.所以他们都是STL通用方法的组成部分. 如果在一个double数组中搜索特定值可以这样写:1234567double * find_ar(double * ar, int n, const double &amp; val)&#123; for(int i = 0; i &lt; n; i++) if(ar[i] == val) return &amp;ar[i];//如果在数组中找到val则返回val在数组中的地址; return nullptr; //否则返回一个空指针&#125; 在这里我们基于了特定的数据结构(数组)可以使用模板来将这种算法推广到包含==运算符的任意类型的数组. 不过我们也可以使用链表:12345struct Node&#123; double item; Node * p_next;&#125; 假设有一个指向链表第一个节点的指针,每个节点的p_next都指向下一个节点,链表最后一个节点的p_next被设置为nullptr…则可以这么写:12345678Node * find_ll(Node * head,const double &amp; val)&#123; Node * start; for(start= head; start!=nullptr; start = start-&gt;p_next) if(start-&gt;item == val) return start; return nullptr;&#125; 他俩一个使用数组,一个将start重置为start-&gt;p_next,广义上他们都一样:将值于容器中的值比较,直到找到匹配为止.但在这里我们基于了特定的数据结构(链表) 而泛型编程旨在使用同一个find函数来处理数组,链表,或其他容器类型.函数不仅独立于容器中储存的类型,而且独立于容器本身的数据结构.模板为我们提供了存储在容器中的数据类型的通用表达,所以我们还需要遍历容器中的值的通用表达.而迭代器正好是干这活的… 要实现find函数,我们的迭代器应该具备以下特征: 应能够对迭代器执行解引用操作,一边能够访问他引用的值,即如果p是个迭代器,则能对*p进行定义; 应能够将一个迭代器赋值给另一个.即如果p和q是迭代器.则能够对p=q进行定义; 应能够使用迭代器遍历容器中的所有元素,这可以为迭代器定义++p和p++来实现; 应能够将一个迭代器和另一个迭代器进行比较,看他们是否相等.即如果p和q都是迭代器则能对p==q和p!=q进行定义 对于find函数来讲,有上述功能就够了,STL按照功能的强弱定义了不同等级的迭代器.另外常规指针就能满足迭代器的要求,可以使之接受两个指示区间的指针参数,其中一个指向数组的起始位置另一个指向数组的超尾;并且如果我们的函数没找到指定的值,那么让他返回尾指针,因此可以这样重写find_ar():123456789typedef double * iterator;iterator find_ar(iterator begin,iterator end,const double &amp; val)&#123; iterator ar; for(ar = begin; ar!=end; ar++) if(*ar == val) return ar; return end;&#125; 对于find_ll()函数,可以定义一个迭代器类,其中定义了运算符*和++;123456789101112131415161718192021struct Node&#123; double item; Node * p_next;&#125;class iterator &#123; Node * pt;public: iterator() : pt(nullptr)&#123;&#125; iterator(Node * p) : pt(p)&#123;&#125; double operatror*()&#123;return pt-&gt;p_next;&#125; iterator &amp; operator++()&#123; //++pt pt = pt-&gt;p_next; return *this; &#125; iterator &amp; operator++(int)&#123; //int表示后缀版++运算符,该int参数永远不会用到只做区分 iterator temp = *this; pt = pt-&gt;p_next; return temp; &#125; //你就假装我这里重载了==和!=&#125; 废了这么大劲之后,我们的find函数改就可以这样写:12345678iterator find_ll(iterator head, const double &amp; val)&#123; iterator start; for(start = head; head!=0; ++start) if(*start = val) return start; return nullptr;&#125; 机智的你一定发现了我这不学好的一天净扯淡: 这踏马不废话么这俩玩意(函数)一毛一样啊,差别就是find_ar用了超尾.find_ll返回的是nullptr啊..其实我们还可以让链表的最后一个元素后面还有个空白元素..这样链表也有了超尾.他们俩就成了真·一个(功能的)算法; //我是第一个分割线↓ 前面的废话都是为了下面的废话做铺垫的: STL其实就是遵循上面的方法.首先每个容器类(vector, list等)定义了相同的迭代器类型,对于其中的某个类,迭代器可能是指针;但对于另一个类,迭代器可能是对象.但他们都将提供列如 * 和++等这样的操作.其次每个容器类都有个超尾标记,当迭代器递增到容器最后一个值的后面的时候把这个值赋值给迭代器.每个容器类都有begin()和end()方法,begin返回指向第一个元素的迭代器,end返回一个指向超尾的迭代器.每个容器类都有++操作用来遍历容器 尽是废话 使用迭代器的时候不用管他是咋实现的..知道咋用就成(如果你碰到需要自己定义迭代器的情况当我放屁):观众: 你智障吧废话谁踏马不会用这玩意 哎呦你咋知道的…没错我就是智障.在知道了迭代器大概是咋构造的之后的我们可以更加自信满满的并没有雄赳赳气昂昂跨..啊不..写出迭代器:123vector&lt;double&gt;::iterator pr; //这玩意是输出vector&lt;double&gt;里的元素for(pr = sco.begin(); pr != sco.end(); pr++) cout &lt;&lt; *pr &lt;&lt; endl; 这里本萌妹使用了C艹11,做一个炫酷的紧跟潮流个屁的智障: 12for(auto pr = sco.begin(); pr != sco.end(); pr++) cout &lt;&lt; *pr &lt;&lt; endl; 作为一种编程风格,最好直接使用STL函数来处理细节,如for_each(),或C艹11的迷之基于范围的for循环:1for(auto x: sco) cout &lt;&lt; x &lt;&lt; endl; 迭代器类型 STL定义了五中迭代器,分别是: 输入迭代器,输出迭代器,正向迭代器,双向迭代器,随机访问迭代器;他们都可以执行解引用操作 输入迭代器： 从程序的角度来说,即来自容器内部的讯息被视为输入,因此输入迭代器可被程序用来读取容器中的信息,但不一定能让程序修改容器里的值. 输入迭代器必须能访问容器中所有的值(废话),可以通过++运算符来实现(废话).但输入迭代器并不保证第二次遍历容器时顺序不变,另外当迭代器被递增后,也不保证先前的值可以被解引用.基于输入迭代器的算法都应该是单通行(single-pass)的,输入迭代器是单项迭代器,可以递增,但不能递减. 输出迭代器: 输出指的是将信息从程序传输给迭代器,因此程序的输出就是容器的输入,和输入迭代器差不多,他只能够解引用让程序能修改容器的值,也就是只能写,而不能读. 对于单通行,只读算法可以使用输入迭代器,对于单通行,只写算法,则可以使用输出迭代器. 正向迭代器: 正向迭代器与输入输出迭代器不同的是,他总是按照相同的顺序遍历一系列值.另外正向迭代器递增后仍可以怼前面的迭代器值解引用,并得到相同的值. 既可以读写又可以只读:12int * pirw; //读写const int * pir;//只读 双向迭代器:具有正向迭代器全部特征,并且支持(前后缀)递减运算符; 随机迭代器:具有全部双向迭代器的特征,并且能够根据要求直接跳到容器中任何一个元素; 概念,改进和模型(完全不知道书上在说啥)下面是咬文嚼字时间 迭代器是一系列要求,而不是类型.STL算法可以使用任何满足要求的迭代器所实现,STL术语叫概念(concept)来描述一系列要求.概念可以具有继承的关系,例如双向迭代器继承了正向迭代器的功能,然而不能将继承机制用于迭代器: 假设我们将双向迭代器实现为一个常规指针,而指针属于C++内置类型,不能从派生而来.但从概念上将他确实能够继承.所以有些STL文献使用术语改进(refinement)来表示这种概念上的继承.so,双向迭代器是正向迭代器概念的一种改进.而概念的具体实现叫做模型(model). 将指针用于迭代器 迭代器是广义指针,指针满足所有迭代器要求,因此STL算法可以使用指针来对基于指针的非STL同期进行操作其实就是可以将STL用于数组…..123const int SIZE = 100;double Rec[SIZE];sort(Rec,Rec+100); sort()函数接受指向容器第一个元素的迭代器和指向超尾的迭代器作为参数.Rec或&amp;Rec[0]是第一个元素的地址,Rec+SIZE是最后一个元素后面的元素的地址;由于指针是迭代器,而算法是基于迭代器的,所以可将STL算法用于常规数组. 假设要把信息输出到显示器上,可以使用一个表示输出的迭代器则可以使用copy();STL有一个ostream_iterator模板是输出迭代器的一个概念模型:123#include &lt;iterator&gt;...ostream_iterator&lt;int,char&gt; out_iter(cout,&quot; &quot;); //注意这双引号里有个空格 out_iter是个接口,能够使用cout来显示信息,第一个模板参数指出被发送给输出流的数据类型,第二个参数(car)值出了输出流使用的字符串类型; 将copy()用于迭代器:12345copy(dice.begin(),dice.end(),out_iter);//这意味着将dice容器整个区间复制到输出流中,即显示容器里的内容//也可以直接构建个匿名的迭代器:copy(dice.begin(),dice.end(), osteram_iterator&lt;int,char&gt;(cout,&quot; &quot;)); 这样用表示将由15和空格组成的字符串发送到cout的输出流中:1*cout_iter++ = 15; // 和 cout &lt;&lt; 15 &lt;&lt; &quot; &quot;; 一样 有输出就有输入,可以用俩isteram_iterator模板对象来定义copy()的输入范围,如下,isteram_iterator的第一个参数(int)是指出要读取的数据类型,第二个参数指出输入流使用的字符串类型(char),构造函数参数cin意味着使用由cin管理的输入流,构造函数参数为空则表示输入失败:12copy(istream_iterator&lt;int,char&gt;(cin), istream_iterator&lt;int,char&gt;(), dice.begin() ); //从输入流中读取,直到失败; 下面的代码演示了如何使用copy和istream迭代器以及反向迭代器:1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;iterator&gt;#include&lt;vector&gt;using namespace std;int main()&#123; using namespace std; int casts[10] = &#123;6,7,2,9,4,11,8,7,10,5&#125;; vector&lt;int&gt; dice(10); copy(casts,casts+10,dice.begin()); cout &lt;&lt; &quot;原始数据: &quot; &lt;&lt; endl; ostream_iterator&lt;int,char&gt; out_iter(cout,&quot; &quot;); copy(dice.begin(),dice.end(),out_iter); cout &lt;&lt; endl; cout &lt;&lt; &quot;使用了反向迭代器重新输出:&quot; &lt;&lt; endl; copy(dice.rbegin(),dice.rend(),out_iter); cout &lt;&lt; endl; cout &lt;&lt; &quot;使用了vector类的reverse_iterator: &quot; &lt;&lt; endl; vector&lt;int&gt;::reverse_iterator ri; for(ri = dice.rbegin(); ri != dice.rend(); ++ri) cout &lt;&lt; *ri &lt;&lt; &apos; &apos;; cout &lt;&lt; endl;return 0;&#125; 但是上述代码是在其已知了dice的大小的情况下进行的,如果不知道容器的大小呢?,并且还是向容器中刚添加元素(而不是像上述代码覆盖已有内容),这种情况下咋整?有三种插入迭代器可以将复制转为插入解决问题,他们使用动态内存分配插入新元素: back_insert_iterator; //将元素插入到容器尾,但只能用于允许在尾部快速插入的容器; (vector符合) front_insert_iterator; //将元素插入到容器前面,但只能用于允许在起始位置做时间固定插入的容器; insert_iterator; //将元素插入到insert_iterator构造函数的参数指定位置之前; 这些迭代器将容器类型作为模板参数,将模板名作为构造函数参数:1back_insert_iterator&lt;vector&lt;int&gt;&gt;back_iter(dice); //为名为dice的vector&lt;int&gt;容器创建个back_insert_iterator 下列程序演示了两种迭代器的使用方法,并且使用for_each()输出:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;iterator&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void output(const string &amp; s)&#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;;&#125;int main()&#123; string s1[4] = &#123;&quot;F&quot;,&quot;A&quot;,&quot;♂&quot;,&quot;Q&quot;&#125;; string s2[2] = &#123;&quot;B&quot;,&quot;L&quot;&#125;; string s3[2] = &#123;&quot;M&quot;,&quot;J&quot;&#125;; vector&lt;string&gt; words(4); copy(s1,s1+4,words.begin());//words地方够,可以复制进来 for_each(words.begin(), words.end(), output); cout &lt;&lt; endl; copy(s2,s2+2,back_insert_iterator&lt;vector&lt;string&gt;&gt;(words));//从后面插♂入 for_each(words.begin(),words.end(), output); cout &lt;&lt; endl; copy(s3,s3+2,insert_iterator&lt;vector&lt;string&gt;&gt;(words,words.begin())); //插♂前面 for_each(words.begin(),words.end(), output); cout &lt;&lt; endl; return 0;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-Vector","date":"2017-03-28T13:34:47.000Z","path":"2017/03/28/C++笔记-Vector/","text":"画师P站ID:61403923 标准库模板 STL提供了一组表示,容器,迭代器,算法,函数对象的模板.容器是一个与数组类似的单元,可以储存若干个类型相同的值.算法用来完成特定任务(如对数组进行排序)的处方;迭代器用来遍历容器里的对象,与能够遍历数组的指针类似,是广义的指针.函数对象是类似于函数的对象,可以是类对象或函数指针. 模板类Vector 可以创建vector对象; 将一个vector对象赋值给另一个,或者使用[]运算符来访问vector中的元素.头文件vector中定义了vector模板举个书上的栗子,输入书名和评分:123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int NUM = 5;int main()&#123; vector&lt;int&gt; vi(NUM); vector&lt;string&gt; vs(NUM); cout &lt;&lt; &quot;请输入&quot; &lt;&lt; NUM &lt;&lt; &quot;个书名和你的评分&quot; &lt;&lt; endl; int i = 0; for(;i &lt; NUM;i++) &#123; cout &lt;&lt; &quot;#第&quot; &lt;&lt; i+1 &lt;&lt; &quot;本:&quot;; getline(cin,vs[i]); cout &lt;&lt; &quot;\\n 请输入评分:&quot;; cin &gt;&gt; vi[i]; cin.get(); &#125; for(i = 0; i &lt; NUM; i++) &#123; cout &lt;&lt; &quot;名字: &quot; &lt;&lt; vs[i] &lt;&lt; &quot; 评分:&quot; vi[i] &lt;&lt; endl; &#125; return 0;&#125; 对vector的操作 size(): 返回容器中的元素数目; swap(): 交换两个容器的内存; begin(): 返回一个指向容器中第一个元素的迭代器; end(): 返回一个表示超过容器尾的迭代器; 什么是迭代器? 他是一个广义的指针(恩没错就是指针),可以对其执行类似指针的操作比如解引用,递增;每个容器都定义了适合的迭代器,一般是名为iterator的typedef,其作用域为整个类.比如声明一个vector的迭代器可以这样做:1234567891011vector&lt;double&gt;::iterator pd; //pd是一个迭代器vector&lt;double&gt; sum;//sum是一个vector对象pd = sum.begin(); //将pd指向sum的第一个元素*pd = 22.3; //对pd解引用,把22.3赋值给pd所指向的元素(也就是sum的第一个元素);++pd; //使pd指向下一个元素//另外可以不这么写: vector&lt;double&gt;::iterator pd = sum.begin();//而是这样做:auto pd = sum.begin(); //C++11 前面说过超过容器尾的迭代器,那么什么是超过结尾呢(past-the-end)?它是一种迭代器,指向容器最后一个元素后面的那个元素的指针.end()成员函数表示超过结尾的位置,如果将迭代器设为容器的第一个元素,然后自加.则最终可将它到达容器结尾,从而遍历整个容器.12for(pd=sum.begin(); pd != sum.end(); pd++)cout &lt;&lt; *pd &lt;&lt; endl; push_back()是一个方便的方法,他讲元素添加到矢量末尾,这样他讲负责管理内存,增加矢量的长♂度,使之容纳下新成员:12345vector&lt;double&gt; sco;double temp;while(cin &gt;&gt; temp &amp;&amp; temp &gt;= 0) sco.push_back(temp); //只要有足够的内存,程序可以根据需要增加sco的长度 cout&lt;&lt; &quot;你输入了:&quot; &lt;&lt; sco.size() &lt;&lt; &quot;个元素&quot;; erase()方法可以删除是两种给定区间的元素.他接受两个迭代器的参数,这俩参数定义了要删除的区间.第一个迭代器指向区间的起始处,第二个指向区间的末尾.例如下列代码删除了[sco.bgein(),sco.begin()+2)区间内的元素:1sco.erase(sco.begin(),sco.begin()+2); inster()方法的功能与erase()相反,他接受三个迭代器参数,第一个指向了新元素的插入位置,第二三个迭代器定义了被插入区间,这个区间通常是另一个容器对象的一部分;就是把A容器的一部分复制出来,插入到B容器的某一位置;列入下列代码将new_v中的除了第一个元素之外所有的元素查到old_v矢量的第一个元素前面:1234vector&lt;int&gt; old_v;vector&lt;int&gt; new_v;old_v.inster(old_v.begin(),new_v.begin()+1,new_v.end()); 对Vector的其他操作 矢量模板并不包括如搜索,排序,随机排序等.STL从更广泛的角度定义了非成员函数(non-member)来执行这些操作.但有的时候,即使有执行相同任务的非成员函数,STL还会定义一个成员函数,因为有的操作使用特定的算法比使用通用的算法效率更高.比如Vector的swap()效率比非函数成员的swap()高;但非函数成员能交换俩类型不同的容器的内容; 三个具有代表性的STL函数: for_each(); fandom_shuffle(); sort(); for_each()接受三个参数,前两个是定义容器中区间的迭代器,最后那个是指向函数的指针(函数对象).被指向的函数不能修改容器元素的值,这玩意可以代替for用:12345678void ShowStr(const string &amp;str)&#123; cout &lt;&lt; str &lt;&lt; endl;&#125;vector&lt;string&gt; books;vector&lt;string&gt;::iterator pr;for(pr = books.begin(); pr != books.end(),pr++) //正常的for ShowStr(*pr); //上面的for可替换为: for_each(books.begin(),books.end(),ShowStr) //这样可以避免显示使用迭代器 random_suffle()该函数接受两个指定区间的迭代器参数,并随机排列该区间的元素,前提是该函数要求可以对容器任意访问,显然vector满足:1random_shuffle(books.begin(),books.end()); sort()函数也要求容器资呲随机访问.该函数有俩重载,一个接受两个定义区间的迭代器参数,并使用容器定义的&lt;运算符容器内容进行升序排序.12 vector&lt;int&gt; myint; sort(myint.begin(),myint.end()); 但如果容器元素是用户自定义的,那么则要给你自定义的类填个&lt;的重载,也就是operator&lt;()..比如我自定义了个结构或类Rev:12345678910111213struct &#123; string title; int rating;&#125;;bool operator&lt;(const Rev &amp; rl, const Rev &amp; r2)&#123; if(r1.title &lt; r2.title) return true; eles if(r1.title == r2.title &amp;&amp; r1.rating &lt; r2.rating) return true; else return false;&#125; 然后就可以对包含Review对象(如books)的矢量进行排序了:1sort(books.begin(),books.end()); 上述程序是按照title成员的字母顺序排序的,如果title一样就按rating排序.如果想降序排序或者按照rating排序,可以使用另一种格式的sort().他接受三个参数,前两个参数也是指定区,间的迭代器,最后一个参数指向要使用的函数的指针(函数对象) 说白了就是函数名 而不去使用operator&lt;().:123456bool WorseThan(const Rev &amp; r1, const Rev &amp; r2)&#123; if(r1.rating &lt; r2.rating) return true; eles return false;&#125; 有了这函数之后就可以….将Rev对象的books矢量按照rating升序排列(你不说降序么)..:1sort(books.begin(),books.end(),WorseThan); 上述代码与operator&lt;()相比,WorseThan()函数对Rev的排序工作不是那么完整,WorsThan()中如果俩对象的title一样,则视为相同,这叫完整弱排序(strict weak ordering).而operator()中如果俩对象的title一样则比较rating,这叫全排序(total ordering); 基于范围的for循环 基于范围的for循环是为了STL而设计的:123double prices[5] = &#123;4.66,10.99,6.54,6.55,8.48&#125;;for(double x : prices) cout &lt;&lt; x &lt;&lt; endl; 在这种for循环中,括号内的代码声明一个与容里内容类型相同的变量,然后指出了容器名称,循环将使用指定的变量x依次访问容器的每个元素…. 比如 for_each(books.begin(),books.end(),ShowStr);可以写成:1for(auto x : books) ShowStr(x); //根据books将推断出x的类型为Rev 不同于for_each(),基于范围的for循环能修改容器里的内容,你只需要指定一个引用参数:12void reRev(Rev &amp; r)&#123;r.rating++;&#125;for(auto &amp; x: books) reRev(x);","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-智能指针","date":"2017-03-26T14:45:49.000Z","path":"2017/03/26/C++笔记-智能指针/","text":"封面来源 使用智能指针 C++有三个智能指针模板(auto_ptr,unique_ptr,shared_ptr),都定义了类似于指针的对象,可以将new获得的地址赋值给这种对象.(其中auto_ptr是C++98提供的解决方案,C++11已经摒弃,不建议使用).当智能指针过期时,其析构函数将使用delete来释放内存.另外share_ptr和unique_ptr的行为与auto_ptr相同. 要使用智能指针首先包含头文件memory.1auto_ptr&lt;double&gt; pd(new double); new double是new返回的指针,指向新分配的内存块.他是构造函数auto_ptr&lt;double&gt;的参数.即对应于原型中的形参p的实参.同样new double也是构造函数的实参.其他两种智能指针的写法:12unique_ptr&lt;double&gt; pdu(new double);shared_ptr&lt;string&gt; pss(new string); 下列代码举例了全部三种智能指针:123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Report&#123;private: string str;public: Report(const string s) : str(s) &#123;cout &lt;&lt; &quot;Objectt created:&quot; &lt;&lt; endl;&#125; ~Report() &#123;cout &lt;&lt; &quot;Object deleted&quot; &lt;&lt; endl;&#125; void comment() const &#123;cout &lt;&lt; str &lt;&lt; endl;&#125;&#125;;int main()&#123; &#123; auto_ptr&lt;Report&gt; ps(new Report(&quot;auto_ptr&quot;)); ps-&gt;comment(); &#125; &#123; shared_ptr&lt;Report&gt; ps(new Report(&quot;shared_ptr&quot;)); ps-&gt;comment(); &#125; &#123; unique_ptr&lt;Report&gt; ps(new Report(&quot;unique_ptr&quot;)); ps-&gt;comment(); &#125; return 0;&#125; 智能指针很多地方和正常指针类似,可以对他进行解引用操作( *p),用它来访问成员(p-&gt;fun),将他赋值给指向相同类型的常规指针,或者赋值给另一个同类型的只能指针; unique_ptr为何优于auto_ptrauto:123auto_ptr&lt;string&gt; p1(new string(&quot;auto&quot;));auto_ptr&lt;string&gt; p2;p2 = p1; 在第三句,p2接管string对象所有权后,p1的所有权被剥夺,但如果程序随后视图使用p1,则是件坏事因为p1已经不再指向有效的数据;unique_ptr:123unique_ptr&lt;string&gt; p3(new string(&quot;auto&quot;));unique_ptr&lt;string&gt; p4;p4 = p3; 编译器认为第三句非法,避免了p3不再指向有效数据的问题; 但有时候将一个智能指针赋值给另一个不会出现悬挂指针的危险:12345678unique_ptr&lt;string&gt; demo(const char * s)&#123;unique_ptr&lt;string&gt; temp(new string);return temp;&#125;...unique_ptr&lt;string&gt;ps;ps = demo(&quot;2333333&quot;); demo()返回一个临时unique_ptr,然后ps接管了demo的临时返回值,ps拥有了string对象的所有权.因为demo返回的临时对象很快就会被销毁.所以没有机会使用它来访问无效的数据,所以编译器允许这种赋值.所以就是,如果源unique_ptr是个临时右值,编译器将允许赋值,但如果源unique_ptr将存在一段时间,编译器将禁止这样做..….. 如果一定要写类似于p3p4那样的代码.要安全的使用指针的话,可以给他赋新值,C++有个标准库函数std::move(),能够让你将一个unique_ptr赋给另一个.:12345using namespace std;unique_ptr&lt;string&gt; ps1, ps2;ps1 = demo(&quot;23333&quot;);ps2 = move(ps1);cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; unique_ptr还可以当数组用:1unique_ptr&lt;double[]&gt;pda(new double(5)); 为啥unique_ptr能知道安全和不安全的用法呢? 因为它使用了C++11的移动构造函数和右值引用…. 选择智能指针 如果程序要使用多个指向同一个对象的指针,应选择shared_ptr,必去有个指针数组,并使用一些辅助指针来标示特定的元素(比如最大值最小值);比如两个对象都指向第三个对象的指针; stl容器;这些操作都可以使用shared_ptr;但不能用unique_ptr和auto_ptr; 如果程序不需要多个指向同一个对象的指针,则可以使用unique_ptr.如果函数使用new分配内存并返回指向该内存的指针.则其返回类型声明为unique_ptr是个不错的选择;这样所有权将转让给接受返回值的unique_ptr,而该智能指针将负责调用delete;12345678910111213141516unique_ptr&lt;int&gt; make_int(int n)&#123; return unique_ptr&lt;int&gt; (new int (n)); &#125;void show(unique_ptr&lt;int&gt; &amp; pi)&#123; cout &lt;&lt; *a &lt;&lt; &quot; &quot;;&#125;int main()&#123; vector&lt;unique_ptr&lt;int&gt;&gt; vp(size); for(jint i = 0; i &lt; vp.size(); i++) vp[i] = make_int(rand() % 1000); vp.push_back(make_int (rand() % 1000)); for_each(vp.begin(),vp.end(),show());&#125; 其中的push_back()调用没毛病,因为他返回一个临时的unique_ptr对象.另外如果安置而不是按引用给show()传递对象,则for_each()将会非法,因为这将导致使用一个来自vp的非临时unique_ptr初始化pi,前面说过,这是不行的. 在unique_ptr为右值的时候,可将其赋值给shared_ptr,要求和赋值给另一个unique_ptr一样:123unique_ptr&lt;int&gt; pup(make_int(rand%1000)); //假设make_int返回类型是unique_ptrshared_ptr&lt;int&gt; spp(pup);shared_ptr&lt;int&gt; spr(make_int(rand() % 1000)); //假设make_int返回类型是unique_ptr 模板shared_ptr有个显示构造函数,可将右值的unique_ptr转化为shared_ptr.shared_ptr将接管原来的unique_ptr所有的对象;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-string类","date":"2017-03-25T14:51:53.000Z","path":"2017/03/25/C++笔记-string类/","text":"string类的构造函数:size_type是一个依赖于实现的整形在头文件string中定义的.string类将string::npos定义为字符串的最大长度,通常为unsigned int的最大值.NBTS(null-terminated-string)来表示空字符结束的字符串.12345678910111213141516string(const char *s); //将string对象初始化为s指向的NBTSstring(size_type n, char c) //创建一个包含n个元素的string对象,其中每个都被初始化为cstring(const string &amp;str) //将一个string对象初始化为string对象str(复制构造函数)string() //创建一个长度为0的默认string对象string(const char * s,size_type n) //创建一个裁剪了s的前n个字符串的对象.template&lt;class Iter&gt;string(Iter begin, Iter end) //将一个string对象初始化为区间[begin,end)内的字符串,begin和end就像指针,用于指定位置string(const string &amp; str, string size_type pos = 0, size_type n = npos)//将一个string对象初始化为对象str中从位置pos开始到结尾的字符,或从pos的位置到第n个字符串;string(string &amp;&amp; str) noexcept//C++11新增,将一个string对象初始化为string对象str,并且可能修改str(移动构造函数)string(initializer_list&lt;char&gt;il) //C++11新增,将一个string对象初始化为列表il中的字符 第五个构造函数将一个C-风格字符串和一个整数作为参数,其中的整数参数来表示要复制多少个字符串(如果20被改成40则将会继续复制字符串..将导致十五个无用的字符串被复制到five的结尾处):12char alls[] = &quot;All&apos;s well that ends well&quot;;string five(alls,20);//这里只是用了前二十个字符来初始化five对象. 第六个构造函数有一个模板参数:1template&lt;class Iter&gt;string(Iter begin,Iter end); begin和end想指针那样指向内存中的两个位置,构造函数将使用begin和end之间的值对string对象初始化.1string six(alls+6,alls+10) //six被初始化为well; 在这里数组名相当于指针,所以alls+6和alls+10的类型都是char,因此类型char将替换Iter.第一个参数指向数组(从零开始)alls中的第六个字符串(w),第二个参数指向alls的第十个(well后面的空格); 现在假设要用该构造函数将对象初始化为另一个string对象(假设为five)的一部分内容,则下面这句不管用:1string seven(five+6,five+10); 原因在于对象名并不是数组名,所以five不是个指针,但five[6]是一个char值,&amp;five[6]则是个地址,因此可以被用作该构造函数的一个参数:1string seven(&amp;five[6],&amp;five[10]); 第七个构造函数将一个string对象的部分复制到构造的对象中:1string eight(four,7,16);//从four的第八个字符开始将16个字符复制到eight中 C++11新增的构造函数: 构造函数string(string &amp;&amp; str)类似于复制构造函数,导致新的string为str的副本,但跟复制构造函数不一样的是,他不保证将str视为const.这种构造函数被称为移动构造函数(move constructor). 构造函数string(initialzer_list)使得下面的声明是合法的:12string p = &#123;&apos;L&apos;,&apos;U&apos;,&apos;C&apos;,&apos;K&apos;&#125;;string c&#123;&apos;L&apos;,&apos;U&apos;,&apos;C&apos;,&apos;K&apos;&#125;; string类输入: 对于string有两种输入方式:123456string stuff;cin &gt;&gt; stuff;getline(cin,stuff);//getline有个可选参数,用于指定使用哪个字符串来确定输入的边界:getline(stuff,&apos;:&apos;); //string的getline会自动调整大小使得正好容得下输入的字符串&apos; 虽然string的getline能自动调节大小,但是有一些限制,如过想要读取一个文本,那么string对象所允许的最大长度(大小为unsigned int的值)可能不够. string的getlin从输入中读取字符串并将其储存到目标string中,直到发生下面三种情况之一: 到达文件尾. 遇到分界字符(如 \\n) 读取的字符数达到最大值; 使用字符串 可以比较字符串.string类对于全部六个关系运算符都进行了重载.如果在机器排列序列中,一个对象位于另一个对象的前面,则前者小于后者.如果机器排列序列为ASCII码,则数字江小鱼大写字符,大写字符小于小写字符.12345678910string str1 = &quot;cobra&quot;;string str2 = &quot;coral&quot;;string str3[20] = &quot;anaconda&quot;;if(str1 &lt; str2) ...if(str1 == str3) ...if(str3 != str2) ...//可以确定字符串的长度.size()和length()成员函数都返回字符串中的字符数:if(str1.length() == str2.size()) ... 可以以多种方式在字符串中搜索给定的字符串或字符.重载的find方法:12345678size_type find(const string &amp; str, size_type pos = 0) const;//从字符串的pos位置开始,查找字符串str,找到了则返回该字符串首次出现时其首字符的索引,没有就返回string::npossize_type find(const char* s,size_type pos = 0) const; //同上size_type find(char ch, size_type pos = 0)const; //同上size_type find(const char* s,size_type pos = 0, size_type n);//从字符串的pos开始,查找s的前n个字符串组成的子字符串.找到则返回子字符串首次出现的首字符的索引,否则返回string::npos 除此之外还有: rfind()方法查找子字符串或字符串最后一次出现的位置; find_first_of()方法在字符串中查找参数中任何一个字符串首次出现的位置; find_last_of()方法用法相同,查找的是最后一次出现的位置 find_first_not_of()方法在字符串中查找第一个不包含在参数中的字符串","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-类型转换运算符&友元,异常の总结","date":"2017-03-23T14:51:04.000Z","path":"2017/03/23/C++笔记-类型转换运算符&友元,异常的总结/","text":"图片来源 类型转换运算符 C++对于类型转换采取更严格的限制.并添加了四个类型转换运算符: dynamic_cast const_cast static_cast reinterpret_cast; dynamic_cast运算符前面介绍过.假设有俩类High和Low,而ph和pl的类型分别为High和Low,则仅当Low是High的可访问基类(直接或者间接)时,下述语句才能将Low*指针赋给pl:1pl = dynamic_cast&lt;Low*&gt;ph; 该运算符的作用是能够在类层次结构中进行向上类型转换. const_cast运算符只有一种用途的类型转换,即改变值为const或volatile(去掉/增加const/volatile特性):1const_cast&lt;type-name&gt;(expression) 如果类型的其他地方也被修改则上述类型将出错.除了cosnt或volatile特征(有或无)可以不同外,type_name和expression的类型必须相同.再次假设High和Low:12345High bar;const High * pbar = &amp;bar;...High * pb = const_cast&lt;High*&gt;(pbar); //没毛病,将删除pbar的const标签const Low * pl = const_cast&lt;const Low*&gt;(pbar);//不行,因为他尝试将const High*改为const Low* 然而其实也可以不用const_cast:12345High bar;const High * pbar = &amp;bar;...High * pb = (High *)(pbar);Low * pl = (Low *)(pbar); 但修改const值的结果可能是不确定的,请看示例:123456789101112131415161718void change(const int * pt, int n)&#123; int *pc; pc = const_cast&lt;int * &gt;(pt); *pc += n;&#125;int main()&#123; int popl = 38383; const int pop2 = 2000; cout &lt;&lt; &quot;pop1,pop2: &quot; &lt;&lt; pop1 &lt;&lt; &quot;,&quot; &lt;&lt; pop2 &lt;&lt; endl; change(&amp;pop1,-103); change(&amp;pop2,-103); cout&lt;&lt; &quot;pop1,pop2&quot;&lt;&lt; pop1 &lt;&lt; &quot;,&quot; &lt;&lt; pop2 &lt;&lt; endl; return 0;&#125; 调用change()时修改了pop1,但没有修改pop2.在change()中,虽然指针pt被声明为const int ,但const_cast去掉了pt的const标签,并赋给了pc,所以pc能修改pop1的值.但仅当指针指向的值不是const时才可行,所以pc不能修改pop2的值. *static_cast语法:1static_cast&lt;type-name&gt;(expression) 仅当typename能被隐式的转换成expression所属类型或expression能被隐式的转换成typename所属的类型的时候,上述转换才是合法的.假设Low是High的基类,而P是一个无关的类,则从High转换到Low,或者从Low转换到High的时候是合法的,而从Low转到p则是非法的.123456High bar;Low blow; High * pb = static_cast&lt;High*&gt;(&amp;blow); //可以 Low * pl = static_cast&lt;Low *&gt;(&amp;bar); //可以 P * pmer = static_cast&lt;Pond *&gt;(&amp;blow) //不行 reinterprete_cast几乎能资呲所有的类型转换,比如可以将指针类型转化为能存下这个指针的整形,但不能将指针转化为更小的整形或浮点型.并且不能讲函数指针转化为数据指针,且不能去掉const标签;语法:1reinterpret_cast&lt;type-name&gt;(expression); 示例:1234struct dat(short a, short b);long value = 0xA224B118;dat * pd = reinterpret_cast&lt;dat *&gt;(&amp;value);cout &lt;&lt; hex &lt;&lt; pd-&gt;a;//显示 前两个字节的值 友元,异常总结 类可以将其它函数,其他类的程序作为自己的友元.在一些情况下需要使用向前声明.并需要注意正确的组合类和方法的顺序; 嵌套类是声明在其他类中的类,但不比是其公有接口的组成部分. 当异常触发时,程序将控制权转交给匹配的catch块,catch块里面的是解决异常或终止程序的代码,在catch块之前的是try块,直接或间接导致异常的函数调用必须放在try块中. RTTI可以检测对象的类型.dynamic_cast运算符可以用于将派生类指针转化为基类指针,其可以安全的调用虚函数.typeid运算符返回一个type_info对象.可以对两个typeid的返回值进行比较看看是不是特定的类型.而type_info对象可用于获得关于对象的信息 而dynamic_cast,static_cast,const_cast,和retinterpret_cast提供了安全的明确的类型转换.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-RTTI(运行阶段类型识别:Runtime Type Identification)","date":"2017-03-20T14:53:04.000Z","path":"2017/03/20/C++笔记-RTTI/","text":"霞之丘诗羽 RTTI这个听上去银瓶乍破水浆迸铁骑突出刀枪鸣的名字正是我大C艹的运行阶段类型识别(Runtime Type Identification)的简称 RTTI可以通过基类的指针和引用来检测这些指针和引用所指向的派生类对象的具体类型. 假设有一个类层次结构,其中的类都是从一个基类派生而来的,则可以让基类指针指向其中的任何一个类的对象.在处理一些信息之后,选则一个类,并创建这种类型对象,然后返回这个对象的地址,而这个地址可以赋值给基类指针,那么如何确定这个对象的类型? 只有知道了类型,才可能调用类方法的正确版本,如果在这个类结构层次中,所有的成员都拥有虚函数,在这个时候就不需要知道对象的类型.但派生类可能包含一些新的方法,在这种情况下只有某些类型可以使用该方法.这时候就可以使用RTTI提供解决方案. dynamic_cast 运算符: 这个运算符可以检测是否可以安全的将对象的地址赋值给特定的类型指针. 假设有下列类层次结构:12345678910111213class Grand&#123;&#125;;class Superb: public Grand()&#123;&#125;class Magn : public Superb()&#123;&#125;//假设有下列指针:Grand * pg = new Grand;Grand * ps = new Superb;Grand * pm = new Magn;//假设有下列类型转换,那么谁是比较安全的?:Magn * p1 = (Magn *) pm; //安全,因为相同类型的指针指向了相同类型的对象.Magn * p2 = (Magn *) pg; //不安全,因为派生类指向基类,而派生类可能有些方法是基类没有的.Superb * p3 = (Magn *) pm;//安全,因为基类指向派生类. 所以,问题”指针指向的是那种类型”和”类型转换是否安全”,类型是否安全更通用点.原因在于:要调用类方法.类型并不一定要完全匹配,儿科一是定义了方法的与你版本的基类类型. dynamic_cast语法:12 Superb * pm = dynamic_cast&lt;Superb *&gt;(pg); //指针pg的类型如果可以被安全的转换为Superb*则运算符将返回对象的地址,否则返回一个空指针 下列代码演示了这种处理,首先他定义了三个类.Grand类定义了一个虚函数Speak(),并且其他类都重定义了这个虚函数,Superb类定义了一个虚函数Say(),而Magn也重定义了他.程序定义了GetOne()函数用来随机创建这三种类中的某种类对象,并对其初始化,然后将地址作为Grand*指针返回并赋给pg.然后使用pg调用Speak().因为这个函数是虚的随意代码能够正确的调用指向的对象的Speak()版本.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Grand&#123;private: int hold;public: Grand(int h = 0) : hold(h)&#123;&#125; virtual void Speak() const&#123;cout &lt;&lt; &quot;Grand&quot; &lt;&lt; endl;&#125; virtual int Value() const&#123;return hold;&#125;&#125;;class Superb : public Grand&#123;public: Superb(int h = 0) : Grand(h)&#123;&#125; void Speak() const &#123;cout &lt;&lt; &quot;Superb&quot; &lt;&lt; endl;&#125; virtual void Say() const&#123;cout &lt;&lt; &quot;superb value of &quot; &lt;&lt; Value() &lt;&lt; endl;&#125;&#125;;class Magn : public Superb&#123;private: char ch;public: Magn(int h = 0,char c = &apos;A&apos;) : Superb(h),ch(c)&#123;&#125; void Speak() const &#123;cout &lt;&lt; &quot;Magn&quot; &lt;&lt; endl;&#125; void Say() const&#123;cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; endl;&#125;&#125;;Grand * GetOne()&#123; Grand * p; switch(std::rand() % 3) &#123; case 0 : p = new Grand(std::rand() % 100); break; case 1 : p = new Superb(std::rand() % 100); break; case 2 : p = new Magn(std::rand() % 100,&apos;A&apos; + std::rand() % 26); break; &#125; return p;&#125;int main()&#123; std::srand(std::time(0)); Grand * pg; Superb * ps; for(int i = 0; i &lt; 5; i++) &#123; pg = GetOne(); pg-&gt;Speak(); if(ps = dynamic_cast&lt;Superb *&gt;(pg)) //如果类型转换成功,则ps为非零.失败则返回空指针0. ps-&gt;Say(); &#125; return 0;&#125; typeid运算符和type_info类 typeid运算符使得能够确定两个对象是否为同种类型.他接受两种参数: 类名 结果为对象的表达式 typeid运算符返回一个对type_info对象的引用,其中type_info是在头文件typeinfo中定义的一个类.这个类重载了==和!=运算符,以便可以使用这些运算符来对类型进行比较.1typeid(Magn) == typeid(*pg); //如果pg指向的是一个Magn对象,则表达式结果为bool值.true,否则为false. 如果pg是一个空指针,则程序将引发bad_tyoeid异常.type_info包含了一个name()方法,该函数返回一个随着实现而异的字符串…通常是类名.1 cout&lt;&lt; &quot;Class Name:&quot; &lt;&lt; tyoeid(*pg).name() &lt;&lt; endl; 有瑕疵的RTTI例子: 不讨论大家对RTTI的争论,介绍一个应该避免的编程方式:123456789 Grand * pg;Superb * ps;for(int i = 0; i &lt; 5; i++)&#123; pg = GetOne(); pg-&gt;Speak(); if(ps = dynamic_cast&lt;Superb *&gt;(pg)) //如果类型转换成功,则ps为非零.失败则返回空指针0. ps-&gt;Say();&#125; 通过不使用dynamic_cast和虚函数,而使用typeid(),可将上述代码重写为:1234567891011121314151617181920Grand * pg;Superb * ps;for(int i = 0; i &lt; 5; i++)&#123; pg = GetOne(); if(typeid(Magn) == typeid(*pg)) &#123; pm = (Magn*) pg; pm-&gt;Speak(); pm-&gt;Say(); &#125; else if(typeid(Superb) == typeid(*pg)) &#123; pm = (Superb*) pg; pm-&gt;Speak(); pm-&gt;Say(); &#125; else pg-&gt;Speak();&#125; 上述代码不仅sb而且还有毛病..如果从Magn类派生出一个Insu的类,而后者需要重新定义Speak()和Say().则必须修改for循环,添加一个else if.但下面的语句适合所有从Grand派生出的类:1234pg-&gt;Speak();//下面语句适合所有从Superb派生而来的类:if(ps = dynamic_cast&lt;Superb *&gt;(pg))ps-&gt;Say(); 所以说如果发现ifelse中使用了typeid,则应该考虑是否使用虚函数和dynamic_cast","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-异常(3)","date":"2017-03-19T14:51:16.000Z","path":"2017/03/19/C++笔记-异常(3)/","text":"图片来源 异常何时会迷失方向异常被引发之后,有两种情况会导致问题: 意外异常(unexpected exception): 如果异常是在带异常规范的函数中引发的,则必须与规范列表中的某种异常匹配(在继承层次结构中,类类型与这个类机器派生类的对象匹配)就是得有个catch块能跟你写的异常符合/能接受你那异常,否则则成为意外异常.(C++11已经摒弃这东西了,然而有的代码还在用它) 举个正确的栗子: 通过给函数制定异常规范,可以让函数的用户知道要捕获那些异常.放屁,真水1234567891011 double Argh(doouble,double) throw(out_of_bounds) &#123; ... try&#123; x = Argh(a,b); &#125; catch(out_of_bounds &amp; ex)&#123; ... &#125; .. &#125; 未捕获异常(uncaught exception): 如果异常不是在函数中引发,则必须捕获他.如果没有捕获(在没有try块或没有catch块时,将出现) 在默认情况下,出现上述情况程序将被终止,然而可以修改程序对上述异常的反应…未捕获异常不会导致程序立刻停止,首先会调用terminate()函数,terminate()会调用abort()函数,但可以修改terminate()调用的函数(不让他调用abort()).可以使用set_terminate()函数来修改.(在#include中):12345typedef void (*terminate_handler)();terminate_handler set_terminate(terminate_handler f) throw(); //C++ 98terminate_handler set_terminate(terminate_handler f) noexcept; //C++ 11void terminate(); //C++ 98void terminate() noexcept; // C++ 11 typedef使得terminate_handler成为一个指向没有参数和返回值的函数的指针.set_terminate()将这个不带任何参数且返回类型为void的函数的名字(地址)作为参数,并且返回这个函数的地址,如果set_terminate()被多次调用,则terminate()将调用最后一次set_terminate调用设置的函数. 举个栗子:一个未被捕获的异常导致程序打印一条消息,然后调用exit()函数.12345678910111213#include&lt;exception&gt;using namespace std;void myQuit()&#123; cout &lt;&lt; &quot;由于出现未捕获异常,程序终止&quot;; exit(5);&#125;int main&#123; set_terminate(fun);//如果出现未捕获异常,将终止操作指定为调用fun(); throw; //触发未捕获异常&#125; 现在如果程序引发未捕获异常,则将调用terminate(),而terminate()将会调用myQuit(). 原则上,异常规范应该包含函数调用的其他函数所引发的异常.比如A()调用了B(),而B()可能引发retor对象异常,则A(),B()的异常规范中都应该包含retort. 如果函数引发了其异常规范中没有的异常呢?这样处理起来就比较繁琐,所以C++11也将其摒弃.所以说这玩意咋看都像是坑 那么在这种情况下,行为与未捕获异常极其相似,程序将调用unexpected().这函数将调用terminate(),后者在默认情况下调用Abort().跟terminate()一样,有一个可以修改其行为的set_terminate()一样,也有一个用于修改unexpected()的set_unexpected():12345typedef void (*unexpected_handler)();unexpected_handler set_unexpected(unexpected_handler f) throw(); //C++98unexpected_handler set_unexpected(unexpected_handler f) noexcept; //C++11void unexpected(); //C++98void unexpected() noexcept;//C++0x 然而set_unexpected()比set_terminate()更加严格,unexpected_handler函数可以: 通过调用terminate()(默认行为).abort(),exit()等来终止程序 引发异常 如果新引发的异常原来的相匹配,则程序将开始寻找引发新异常的函数规范; 如果新引发的异常跟原来的不一样,且异常规范中没包括sed::bad_exception则将调用terminate(). 如果新引发的异常跟原来的不一样,且异常规范中包括了sed::bad_exception则不匹配的异常会被sed::bad_exception异常取代. 有关异常的注意事项 使用异常会降低程序运行速度.(废话 异常规范不适用于模板. 因为模板函数引发的异常随特定的具体化而异. 异常和动态内存分配并非总能协同工作 动态内存分配和异常:正常:1234567void fun()&#123; string mesg(&quot;Boy Next Door&quot;); ... if(..) throw exception(); ... return;&#125; 当函数结束时,将为mesg调用string的析构函数,虽然throw过早的终止了函数,但因为栈解退的存在使得析构函数仍然被调用完成清理. 有瑕疵:12345678void fun(int n)&#123; string * mesg = new string[n]; ... if(..) throw exception(); ... delete [] mesg; return;&#125; 这里有个瑕疵: 当栈解退时,将删除栈中的变量mesg,但函数过早的终止意味着句尾的delete [] mesg;被忽略.指针虽然没了,但内存还没被释放且不可访问…这就容易造成一些问题.. 修改版:123456789101112131415void fun(int n)&#123; string * mesg = new string[n]; ... try&#123; if(..) throw exception(); //捕获异常 &#125; catch(exception &amp; e)&#123; delete [] mesg; //清理 throw; //重新引发 &#125; ... delete [] mesg; return;&#125; 然而可以用智能指针解决该问题","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-异常(2)","date":"2017-03-14T14:46:57.000Z","path":"2017/03/14/C++笔记-异常(2)/","text":"封面来源 其他异常特型(一些碎碎念 虽然throw-catch机制类似于函数参数和返回机制,但还是有所不同. 其一便是函数中的返回语句是将控制权返回到调用函数的函数,但throw语句将向上寻找,并将控制权返回给一个能够捕获相应异常的try-catch组合. 另一个不同便是,引发异常是编译器总是创建一个临时拷贝.举个栗子:123456789101112131415class problem&#123;...&#125;void fun() throw (problem) // 表示函数只能抛出problem类型的异常.更简单的写法: throw problem()&#123; if(...)&#123; problem opps; throw oops; &#125;&#125;...try&#123; super();&#125;catch(problem &amp;p)&#123; // 这里的p指向的是oops的副本而不是其本身,因为函数执行完毕之后 oops当不复存在; ....&#125; 对于接在函数名后面的throw(something): void fun() throw(); //表示fun函数不允许抛出任何异常，即fun函数是异常安全的 void fun() throw(…); //表示fun函数可以抛出任何形式的异常 void fun() throw(exceptionType); // 表示fun函数只能抛出exceptionType类型的异常 使用引用传递参数更重要的原因是,基类可以使用派生类对象.现在假设有个异常类层次结构,冰妖分别处理不同的异常类型,则使用基类引用能够捕获任何异常对象;而使用派生类对象则只能捕获他所属类以及他的派生类的对象. 因为基类可以使会用派生类对象,而且引发异常的对象将被第一个与之匹配的catch块捕获,那么所以catch块的排列顺序应该与派生类顺序相反:这又是一个一不留神就会留下bug的功能123456789101112131415161718class bad_1&#123;...&#125;;class bad_2 : public bad_1&#123;..&#125;;class bad_3 : public bad_2&#123;...&#125;...void duper()&#123; ... if(...) throw bad_1(); if(...) throw bad_2(); if(...) throw bad_3();&#125;...try &#123; duper();&#125;catch (bad_3 &amp; b3)&#123;...&#125;catch (bad_2 &amp; b2)&#123;...&#125;catch (bad_1 &amp; b1)&#123;...&#125; 如果将catch(bad_1 &amp; b1)放在最前面,他将捕获 bad_1,bad_2,bad_3, 只能通过相反的顺序排列,bad_3才会被bad_3处理程序所捕获. 所以说,如果有一个异常类继承层次结构,应该这样排列catch块: 将捕获位于层次结构最下面的异常类的catch语句放在最前面,将捕获基类异常的catch语句放在最后面;也就是倒着写 exception类 exception头文件定义了exception类,C++可以把它用作于其他异常类的基类.使代码可以引发exception异常,他有一个名曰what()的虚方法,因为是个虚方法所以你可以根据你的实现重定义他. 12345678910111213#include &lt;exception&gt;class bad_hmean : public std:: exception&#123; public: const char * what() &#123;return &quot;不要总想搞个大新闻&quot;;&#125;&#125;//如果不想以不同的方式处理这些派生类的异常,可以在同一个基类中捕获他们:try&#123; ...&#125;catch(std::exception &amp; e)&#123; cout &lt;&lt; e.what() &lt;&lt; endl;&#125; 当然你也可以分开捕获他们,去吧大师球 1.stdexcept异常类 头文件sedexcept定义了几个异常类.比如logic_error和runtime_error类,他们都是以公有集成的方式从exception类继承过来的:12345678910class logic_error: public exception&#123; public: except logic_error(const string &amp; what_arg);&#125;class runtime_error: public exception&#123; public: except runtime_error(const string &amp; what_arg);&#125;//注意 这些类的构造函数都接受一个string对象作为参数,他们提供了what()方法并且返回C-风格字符串 这两个新的类又被作为两个派生类系列的基类,其中logic_error类描述了典型的逻辑错误,这些逻辑错误是可以通过合理编程避免的,但还是可能发生.下面每个类的名称指出了他们用于报告的错误类型: logic_error类: domain_error: invalid_argument: length_error out_of_bounds: doormain_error: 数学函数值域(range)和定义域(domain),定义域由函数可能的参数组成,值域由函数可能的返回值组成,函数在输入参数或返回值不在制定范围的情况下将会引发domain_error异常; incalid_argument: 异常incalid_argument指出了给函数传递了一个意料之外的值.这个和定义域(domain)都有点不一样.例如如果希望输入的每个字符串要么是0要么是1,那么当输入的字符串中包含其他字符的时候,incalid_argument会被触发. length_error: 异常length_error指出了由于没有足够的空间类执行所需操作.比如string类的append()方法在合并得到的字符串长度超了的时候; out_of_bounds: 异常out_of_bounds通常用于指示索引错误,比如定义了个数组类,其operator()[]在使用的索引无效时引发out_of_bounds异常 runtime_error类这个类描述了可能在运行期间发生的难以预料的错误: range_error: overflow_error: underflow_error: 下溢(underflow) 存在浮点类型可以表示的最小非零值,当计算结果小于这个值的时候,将导致下溢错误.上溢(overflow) 存在计算结果超过了某种类型能够表示的最大数值时,将导致上溢.对于计算结果可能不在函数允许范围之内,但没有发生上下溢的时候可以用range_error异常; 继承关系可以使程序员一起处理他们(如果你愿意的话): 下面代码分别处理每种异常,先单独捕获out_of_bounds,然后统一不过其他logic_error系列异常,最后统一不过exception异常,runtime_error,以及其他从exception派生而来的异常: 1234567try&#123;...&#125;catch(out_of_bounds &amp; oe)&#123;...&#125;//捕获out_of_boundscatch(logic_error &amp; oe)&#123;...&#125;//捕获logic_error类catch(exception &amp; oe)&#123;...&#125;//捕获runtime_error,exception,和其他从exception派生而来的异常//↑↑如果你很不爽这么做的话可以给runtime_error,exception派生出来俩异常类,使异常类可以归入同一个继承层次中. bad_alloc异常和new 对于使用new导致的内存分配问题,C++比较新的处理方式是让new引发bad_alloc异常,头文件new包含bad_alloc的声明.他是从exception类公有派生而来,但在以前当无法分配请求的内存量时new返回一个空指针. 举个栗子:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;cstdlib&gt;using namespace std;struct Big&#123; double stuff[20000];&#125;;int main()&#123; Big* pb; try&#123; cout &lt;&lt; &quot;试着申请一大块儿内存&quot; &lt;&lt; endl; pb = new Big[100000]; /*pb = new (std::nothrow) Big[10000]; //这样在内存请求失败的时候会返回空指针 if()&#123; cout &lt;&lt; &quot;请求失败&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125;*/ cout &lt;&lt; &quot;请求通过&quot; &lt;&lt; endl; &#125; catch(bad_alloc &amp; ba)&#123; cout &lt;&lt; &quot;捕捉到异常&quot; &lt;&lt; endl; cout &lt;&lt; ba.what() &lt;&lt; endl; exit(EXIT_FAILURE); &#125; cout &lt;&lt; &quot;成功分配内存&quot; &lt;&lt; endl; pb[0].stuff[0] = 4; cout &lt;&lt; pb[0].stuff[0] &lt;&lt; endl; delete [] pb; return 0;&#125; 如果内存申请失败了则方法what()将会返回字符串std::bad_alloc.(在我的MinGW5.5下返回std::bad_array_new_length)如果你的程序没触发异常清加大请求分配内存量 另外还有一种是在new处理失败时返回空指针的:12int *p = new(std::nothrow) int;int *b = new (std::nowthrow) int[500];","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-异常","date":"2017-03-07T15:14:32.000Z","path":"2017/03/07/C++笔记-异常/","text":"图片来源: 不好意思本智障找不到了.请在p站搜雪染ちさ.. 在(keng)神(te)奇(duo)的C++中, 本智障经常写出一些正常的代码导致我的bug编译不过去. 举个书上的栗子,计算两个数的调和平均数的定义为: 两个数字倒数的平均数, 表达式: 2.0 * x * y / (x + y) 这样的话如果xy互为相反数的情况下岂不是很尴尬? abort() 对于这种问题,处理方式之一是如果检查到xy互为相反数则调用 abort() 函数(abort处于 cstdlib.h ).他会想标准错误流发送 abnormal program termination (程序异常终止),而且返回一个由时间决定的值,告诉操作系统处理失败..当然也可以用exit(),只不过不显示消息而已; 1234567891011121314151617181920212223242526 #include &lt;iostream&gt;#include &lt;cstdlib&gt;double hmean(double a,double b)&#123; if(a == -b) &#123; std::cout &lt;&lt; &quot;这俩数有毛病...&quot; &lt;&lt; std::endl; //在MinGW 5.3.0 32bit 下不使用abort的情况输入10和-10,调和平均数是 -inf std::abort(); //运行到这儿直接退出 所以不会显示下面bye的那句 &#125; return 2.0 * a * b / (a+b);&#125;int main()&#123; std::cout&lt;&lt; &quot;输入俩数以计算调和平均数:&quot;; double x, y, z; while(std::cin &gt;&gt;x &gt;&gt; y) &#123; z = hmean(x,y); std::cout&lt;&lt; x &lt;&lt;&quot; 和 &quot;&lt;&lt; y &lt;&lt; &quot; 的调和平均数是 &quot; &lt;&lt; z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;输入任意按回车退出&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;bye 再次按回车退出.&quot;; return 0;&#125; 异常机制对于异常的处理有三个部分: 引发异常(throw) 使用处理程序捕获异常(catch) 使用 try 块(try) throw关键字表示引发异常,紧随其后的值(如字符串或对象)指出异常的特征;catch关键字表示使用异常处理程序(exception handler)捕获异常,括号内的表示异常要处理的类型,花括号内的表示遇到异常所采取的措施,虽然catch长的像个自带定义的函数,然而他并不是.try关键字表示其中的代码可能会出现异常,他后面一般跟着一个或多个catch. 如码所示:1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;double hmean(double a, double b)&#123; if(a == -b) throw &quot;异常:这俩数有毛病&quot;; //异常被触发 return 2.0 * a * b /(a + b);&#125;int main()&#123; double x , y, z; cout &lt;&lt; &quot;请输入俩数: &quot;; while(cin &gt;&gt; x &gt;&gt; y) &#123; try &#123; z = hmean(x,y); //try块里的表示需要注意这些代码可能触发异常 &#125; catch (const char * s)&#123; //捕捉到异常 程序跳到这儿 发现char类型与 throw后面的字符串匹配 cout &lt;&lt; s &lt;&lt; endl; //匹配之后执行代码块内的代码处理异常 cout &lt;&lt; &quot;请重试: &quot;; continue; &#125; cout &lt;&lt; x &lt;&lt; &quot; 和 &quot; &lt;&lt; y &lt;&lt; &quot; 这俩数的调和平均数是: &quot; &lt;&lt; z &lt;&lt; endl; cout &lt;&lt; &quot;输入任意字符串退出: &quot;; &#125; cout &lt;&lt; &quot;bye,再按回车退出&quot; &lt;&lt; endl;&#125; 现在假设异常被触发,hmean()引发异常,被引发的异常是常量字符串:”异常:这俩数有毛病”,于是throw终止函数hmean()的执行,沿着函数调用序列往后查找,发现hmean()函数是从main()中的try块中调用的,于是throw把控制权返回给main函数,程序将在main里寻找与引发的异常类型所匹配的异常类型处理程序(说白了就是找参数类型跟throw后面的类型一样的catch块),程序找到唯一匹配的参数为char* 的catch块:类似下面的12345catch (const char * s)&#123; //捕捉到异常 程序跳到这儿 发现char类型与 throw后面的字符串匹配 cout &lt;&lt; s &lt;&lt; endl; //匹配之后执行代码块内的代码处理异常 cout &lt;&lt; &quot;请重试: &quot;; continue;&#125; 于是,程序吧字符串:”异常:这俩数有毛病”赋值给s,然后执行catch(const char* s)内的代码.如果函数引发了异常而没有try块或没有匹配的catch时程序将调用abort()函数 将对象作用异常类型通常,引发异常的函数将传递一个对象,这就可以通过不同的异常类型来区分不同的函数在不同的情况下引发的异常,另外对象可以携带信息,同时catch块可以根据这些信息来决定采取什么样的措施.请查看具体代码举个栗子:12345678910111213void hmean(int a, int b) &#123; if(...) throw _Error(a,b); //你就假装_Error是个构造函数并且异常被触发,此时调用构造函数初始化对象并存储参数;&#125;try&#123; hmean(2,3); //这是个可能触发异常的函数&#125;catch (_Error &amp; e)&#123; e.mesg(); //你就假装这里是调用了_Error类的消息输出方法并告诉你代码有毛病了;&#125; 异常规范和C++11C++98新增了一种不受待见(最好别用这玩意)的异常规范(exception specification),他长这样:12double harm(double a) throw(bad_thing); //可能会抛出bad_thing异常double marm(double) throw(); //不会抛出异常 throw()部分就是异常规范,他可能出现在函数原型和函数定义中,他可以包含类型列表.这玩意的作用之一是告诉用户可能需要使用try块(然而直接写注释更方便),另一作用是让编译器添加执行运行阶段的代码,使劲检测是否违反了异常. C++11资呲一种特殊的异常规范,使用noexcept指出函数不会引发异常,不过对于这个还是存在争议的:1double marn() noexcept; //marn() 不会抛出异常 栈解退其实一张图就可以解释栈解退不过我还是要哔(chao)哔(xi)两句 假设try块没有直接调用引发异常的函数,而是调用了对引发异常函数进行调用的函数,则程序将从引发异常的函数直接跳到包含try块的函数. C++是如何处理函数的调用和返回的? 程序将调用函数的指令的地址(返回地址)放到栈中.当被调用的函数执行完毕之后程序将通过地址来确定从哪里开始继续执行.函数调用将函数参数也放到了栈中,他们被视为自由变量,如果被调用的函数又调用了另一个函数,那么后者的信息也会被添加到栈中,以此类推.当函数结束时,程序流程将跳到调用函数时储存的地址处(也就是返回到调用他的那个函数里),同时栈顶元素被释放,以此类推.并在结束时释放自由变量,如果自动变量是类对象,那么他的析构函数将被调用(如果有析构函数的话). 现在假设异常被触发(程序终止),则程序也将释放栈中的内存,但不会在释放栈的第一个返回地址后停止,而是继续释放栈,直到找到一个位于try块中的返回地址才停止.随后控制权将转到块尾的catch里,而不是调用函数后面的第一条语句,这个个过程被称为栈解退. 然而栈解退有个和函数返回一样的特征. 对于栈中的自动类型对象,类的析构函数将被调用.不同的是,函数返回仅仅处理放在栈中的对象,而throw则是处理try块和throw之间整个函数调用序列放在栈中的对象. 如果没有栈解退这种特性,则引发异常后,对于中间函数调用放在栈中的对象,他们的析构函数不会被调用. (现在上图: throw 与 return","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-友元类","date":"2017-03-05T15:07:46.000Z","path":"2017/03/05/C++笔记-友元类/","text":"类并非只能拥有友元函数还可以将类作为友元,友元被赋予从类外访问类的私有部分的权限,在这种情况下,友元类的所有方法都可以访问原始类的公有/私有/保护成员,也能指定特定的成员函数为一个类的友元. 什么时候希望一个类成为另一个类的友元? 书上举得一个栗子:完整代码 假设编写一个模拟遥控器和电视机的程序,决定有TV和Remote类表示电视机和遥控器,显然这两个类存在着某种关系(净说废话).但电视机不是遥控器,反之亦然,所以正常的公有继承is-a关系并不适用.遥控器并非电视机的一部分.所以,包含私有和保护集成的has-a关系也不适用.但众所周知遥控器可以改变电视机的状态.这说明遥控器应该是电视机类的一个友元. 友元的声明:友元声明可以位于公有,私有或者保护部分,所在其位置无关紧要.但由于Remote类提到了TV类所以必须先定义Tv类,或者使用前向声明.这样来声明一个友元类:1friend class Remote; 1234567891011121314151617181920212223242526272829303132333435363738394041class Tv&#123;public: friend class Remote; enum&#123;off,on&#125;; enum&#123;MinVal,MaxVal = 20&#125;; enum&#123;Antenna,cable&#125;; enum&#123;tv,dvd&#125;; Tv(int s = off,int mc = 125):state(s),volume(5), maxchannel(mc),channel(2),mode(cable),input(tv)&#123;&#125; void onoff()&#123;state = (state == tv) ? off: on;&#125; bool ison() const &#123;return state == on;&#125; bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode()&#123;mode = (mode = Antenna) ? cable: Antenna;&#125; void set_input()&#123;input = (input = tv) ? dvd : tv;&#125; void settings() const;private: int state; int volume; int maxchannel; int channel; int mode; int input;&#125;;class Remote&#123;private: int mode;public: Remote(int m = Tv::tv):mode(m)&#123;&#125; bool volup(Tv &amp; t)&#123;return t.volup();&#125; bool voldown(Tv &amp;t)&#123;return t.voldown();&#125; void onoff(Tv &amp; t)&#123;t.onoff();&#125; void chanup(Tv &amp;t)&#123;return t.chanup();&#125; void chandown(Tv &amp;t)&#123;return t.chandown();&#125; void set_mode(Tv &amp;t)&#123;return t.set_mode();&#125; void set_input(Tv &amp;t)&#123;return t.set_input();&#125; void set_chan(Tv &amp;t, int c)&#123;t.channel = c;&#125;&#125;; 从上面的从书中摘抄的毫无诚意的代码中可以看出,所有的Remote方法都是Tv类的友元,似乎Remote类除了构造函数都使用了Tv类的公有接口,但是事上唯一直接访问了Tv类成员的Remote类方法是Remote::set_chan(),那么就可以选择仅特定的类成员成为另一个类的友元.但这样就要小心的排列声明和各种定义;让Remote::set_chan()成为Tv类的友元的方法是,在Tv类声明中将其定义为友元: 123class Tv&#123; friend void Remote::set_chan();&#125; 就酱,但是吧……编译器要处理这句话首先得知道Remote的定义,不然编译器不知道Remote是个类,所以这就要把Remote类的声明挪到Tv类声明前面,但Remote类用了Tv对象..这就又得把Tv类定义挪到Remote类定义前面去.咦等等.那Remote咋办他需要在Tv类的前面啊.这..这就很尴尬了,呐,避免这种死循环的方法是使用 前向声明(forward declaration):123class Tv ; //前向声明class Remote&#123;...&#125;class Tv&#123;...&#125;; 那能不能这样?:123class Remote;class Tv&#123;...&#125;;class Remote&#123;...&#125;; 这是不行的,在编译器在Tv类中的声明中看到Remote类的一个方法称为Tv类的友元之前,该先让编译器看到Remote类的声明和Remote::set_chan()函数的声明. 好了,但在Remote类中可以看到,有些方法包含了内联代码,例如: void onoff(Tv &amp; t){t.onoff();}由于它使用了一个Tv的方法,所以在此之前编译器必须看到Tv类声明,但是Tv类在Remote类后面声明..解决方法就是把函数定义放在Tv类之后就成.. 吼,现在只有一个Remote方法是Tv类的友元了; 编译器一开始通过前向类型得知了Tv是个类,在读取声明并编译了这些方法之后,使用lnline关键字仍然可以使Remote类未定义的函数称为内联方法.完整代码 其他友元关系遥控器能影响电视.现在你想通过电视对遥控器产生某种影响,这可以让类彼此成为对方的友元来实现; 需要记住的是对于使用Remote类对象的Tv方法,其 函数原型 可以在Remote类声明之前声明,但必须在Remote类之后定义,这样编译器才有足够的信息来编译该方法.12345678910111213class TV&#123;friend class Remote;public: void buzz(Remote &amp; r); ...&#125;;class Remote&#123; friend class Tv; public: void bool volup(Tv $ r)&#123;t.volup();&#125;&#125;;inline void Tv::buzz(Remote &amp; r)&#123;...&#125; 由于Remote声明在Tv后面,所以可以在类声明中定义volup();buzz()可以再Tv中声明,但必须在Remote后面定义; 共同友元函数需要访问两个类的私有数据,函数可以是一个类的成员,另一个类的友元; 也可以是两个类的友元:12345678910111213class A; //前向声明class B &#123; friend void fun(A &amp; a,const B &amp; b); //编译器发现前向类型A 得知A是一个类型 friend void fun(B &amp; b,const A &amp; a);&#125;class A&#123; friend void fun(A &amp; a,const B &amp; b); friend void fun(B &amp; b,const A &amp; a);&#125;//定义友元函数inline void fun(A &amp; a,const B &amp; b)&#123;...&#125;inline void fun(B &amp; b,const A &amp; a)&#123;...&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-嵌套类","date":"2017-03-04T15:04:38.000Z","path":"2017/03/04/C++笔记-嵌套类/","text":"封面来源 在(quan)神(shi)奇(keng)的C++中,放在另一个类中声明的类被称为嵌套类(nested class),它通过提供新的类型类作用域来避免名称混乱.包含类的成员和函数可以创建和使用被包含类的对象; 仅当嵌套类声明位于包含类的公有部分时,才可以在包含类外通过作用域解析运算符使用嵌套类; 不不不,这个和包含不一样,包含是将一个类的类对象作为另一个类的类成员; 而嵌套类则是定义了一种类型且仅在包含嵌套类声明的类中有效 12345678910//在包含类的私有部分声明了个嵌套类class Queue&#123;private: class Node &#123; public: Node(); &#125;&#125; 使用两次作用域解析运算符就可以定义Node()辣:1Queue::Node::Node()&#123;...&#125; 嵌套类和访问权限如果嵌套类是在另一个类的私有部分声明的,则只有包含他的类知道他的存在,且对于从包含类派生出来的类来讲,因为派生类不能直接访问基类私有部分,所以嵌套类也是不可见的. 如果嵌套类是在另一个类的保护部分声明的,则对于包含他的类来说是可见的,而对于外部来讲嵌套类是不可见的,但后者的派生类可以直接创建这种类对象. 如果嵌套类是在另一个类的公有部分声明的,因为他是公有的,则对于包含他的类,对与包含他的类的派生类以及外部世界都可以使用它. 访问控制在Queue类中声明Node类并没有赋予Queue类任何访问权限,Node也没有赋予Queue任何访问权限,所以Queue只能显示的访问Node成员,所有我将Noede类所有成员声明为公有,不过没关系,虽然Queue的方法可以直接访问Node类,但被Queue声明为私有的Node对于外部来讲是不可见的. 模板类中的嵌套(并不会发生什么奇怪的问题; 完整代码","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-成员模板&将模板用作于参数","date":"2017-01-08T15:43:01.000Z","path":"2017/01/08/C++笔记-成员模板&将模板用作参数/","text":"模板成员:模板类将另一个模板类和模板函数作为其成员1234567891011121314151617181920212223template &lt;typename T&gt;class beta&#123;private: template&lt;typename V&gt; class miao &#123; private: V val; public: miao(V v = 0) : val(v)&#123;&#125; void show() const &#123;cout &lt;&lt; val &lt;&lt; endl;&#125; V value() const &#123;return val;&#125; &#125;; miao&lt;T&gt; q; miao&lt;int&gt; n;public: beta(T t, int i) : q(t),n(i) &#123;&#125; template &lt;typename U&gt; U blab(U u,T t) &#123;return ((n.value() + q.value()) * u/t);&#125; void bshow() const &#123;q.show(); n.show();&#125;&#125;; 12hold&lt;T&gt; q;hold&lt;int&gt; n; n 是基于int 类型的hold 对象,q 的基于T 类型的hold 对象,下述声明使得T表示的是double,因此q 的类型是 hold&lt; double&gt;:1beat&lt;double&gt; guy(10,2.5); blab() 方法的U 类型由该方法被调用时的参数决定,T 类型由对象的实例化决定,下述例子中,guy 的声明将T 类型设置为double,U 的类型则为int.1cout&lt;&lt;guy.blab(10,2.5); 虽然混合类型所引起的自动类型转换导致blab() 函数中的计算以double 类型进行,但返回值的类型为U (即int),因此上述输被截断为28. 如果使用guy.blab()时,使用10.0代替10,那么U 的类型将会设置为double ,使得返回值也为double,因此输出为28.2608. 将模板类用作参数模板类可以包含类型参数(如 typename T )和非类型参数(如 int ),还可以包含本身就是模板的参数. 举个书上的栗子:12345678910111213141516171819202122232425262728293031template&lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;private: Thing&lt;int&gt; s1; Thing&lt;double&gt; s2;public: Crab()&#123;&#125; bool push(int a,double x)&#123; return s1.push(a) &amp;&amp; s2.push(x);&#125; bool pop(int &amp; a,double &amp; x)&#123;return s1.pop(a) &amp;&amp; s2.pop(x);&#125;&#125;;int main()&#123; Crab&lt;Stack&gt; cs; int ni; double nd; cout &lt;&lt; &quot;Enter int double pairs,such as 4 3.5(0 0 to end):&quot; &lt;&lt; endl; while (cin &gt;&gt; ni &gt;&gt;nd &amp;&amp; ni &gt; 0 &amp;&amp; nd &gt; 0) &#123; if(!cs.push(ni,nd)) break; &#125; while(cs.pop(ni,nd)) cout &lt;&lt; ni &lt;&lt; &quot; , &quot; &lt;&lt; nd &lt;&lt; endl; cout &lt;&lt; &quot;DONE&quot; &lt;&lt;endl; return 0;&#125; 12template &lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;&#125; 如上, 上述模板参数类型为template &lt; typename T&gt; class Thing,其中Thing 为参数. 这意味着为了使 Crab&lt; King&gt; legs 被接受,模板类参数King 必须是个模板类:12template &lt;typename K&gt; class King&#123;...&#125; legs 声明将用King&lt; int&gt; 替换 Thing&lt; int&gt; ,用 King&lt; double&gt; 替换 Thing&lt; double&gt;,但是在下面的代码中就有所不同. 在Crab 类中,有两行代码声明了两个类对象:12Thing&lt;int&gt; s1;Thing&lt;double&gt; s2; 而mian 函数中包含以下声明,因此,Thing&lt; int&gt; 将被实例化为 Stack&lt; int&gt; ,而Thing&lt; double&gt;将被实例化为Stack&lt; double&gt;.总之,模板参数Thing 将被替换为声明Crab 对象时被用作模板参数的模板类型.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-模板的具体化","date":"2017-01-06T11:32:50.000Z","path":"2017/01/06/C++笔记-模板的具体化/","text":"隐式实例化:编译器在需要对象之前,不会生成类的隐式实例化12ArrayTp&lt;int,100&gt; * pt; //不生成实例pt = new ArrayTp&lt;int,100&gt;;//现在生成实例 显式实例化:使用关键字template并指出所需类型来声明类的时候,编译器将生成类声明的显式实例化:1template class ArrayTp&lt;string,100&gt;; 在这种情况下,虽然没有创建类对象,编译器也将生成类,包括方法定义. 显式具体化:(显式具体化==特型)在需要特殊要求的时候对模板进行修改,使其行为不同,这时可以创建显式具体化. 书上举的栗子:假设现在定义一个表示排序后数组的类:1template &lt;typename T&gt; class SortedArray&#123;...&#125; 假设模板使用&gt;运算符来对值进行比较,对于数字来说没毛病,对于类型T,只要定义了T::operator&gt;(),也没毛病,但是T如果是个const char **的字符串就不行了,因为这需要使用strcmp(),而不是&gt;*.这种情况下可以提供一个现实模板具体化.格式如下:1template &lt;&gt; class Classname &lt;specialized-type-name&gt;&#123;...&#125; 当具体化模板和通用模板都与实例化请求匹配时,编译器将使用具体化模板. 所以说要使用const char 类型的SortedArray*模板可以这么写:1template &lt;&gt; class SortedArray&lt;const char *&gt; &#123;...&#125; 这样在使用const char **类型的SortedArray*模板时将使用上述专用定义而不是用通用模板定义. 部分具体化:部分具体化可以给类型参数制定具体的类型:12template &lt;class T1, class T2&gt; class Pair&#123;...&#125;;template &lt;class T1&gt; class Pari&lt;class T1,int&gt;&#123;...&#125;; template后面的是没有被具体化的类型参数.上述T2被具体化为int,但T1不变. 部分具体化特型使得能够设置各种限制,例如:12345678//一般模板template&lt;typename T1,typename T2,typename T3&gt;class Trio&#123;...&#125;//对T3具体化的模板template&lt;typename T1,T2&gt; class Trio&lt;T1,T2,T3&gt;&#123;...&#125;//对T2,T3具体化的模板template&lt;typename T1&gt; class Trio&lt;T1,T2*,T3*&gt;&#123;...&#125; template 后面的是没有被具体化的类型参数 给出上述定义编译器将作出如下选择:123Trio&lt;int,double,string*&gt; T1; //使用一般模板Trio&lt;int,short&gt; T2; //使用对T3具体化的模板Trio&lt;string,string*,char*&gt;;//使用对T2,T3具体化的模板","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-多重继承","date":"2016-12-30T11:31:05.000Z","path":"2016/12/30/C++笔记-多重继承/","text":"必须使用关键字来限定每一个基类,不然编译器会默认成私有派生:1class mylove : public string, valarray&lt;double&gt; //valarray为私有继承 其实你不用看这仨奇葩类的123456789101112131415161718192021222324252627282930313233343536373839404142class Worker&#123;public: Worker() : name(&quot;NULL&quot;),id(0L)&#123;&#125; Worker(const string &amp; s,long n) : name(s),id(n)&#123;&#125; virtual ~Worker() = 0; virtual void Set(); virtual void Show() const;private: string name; long id;&#125;;class Waiter : public Worker&#123;public: Waiter() : Worker(),panache(0)&#123;&#125; Waiter(const string &amp; s, long n, int p = 0) : Worker(s,n),panache(p)&#123;&#125; Waiter(const Worker &amp; w, int p) : Worker(w),panache(p)&#123;&#125; void Set(); void Show() const;private: int panache;&#125;;class Singer : public Worker&#123;public: Singer() : Worker(),voice(other)&#123;&#125; Singer(const string &amp; s, long n, int v = other) : Worker(s,n),voice(v)&#123;&#125; Singer(const Worker &amp; w, int v =other) : Worker(w),voice(v)&#123;&#125; void Set(); void Show() const;protected: enum&#123;other,alto,contralto,soprano,bass,baritone,tenor&#125;; enum&#123;Vtypes = 7&#125;;private: static char* pv[Vtypes]; int voice;&#125;; Worker?从Singer和Waiter共有派生出SingingWaiter:1class SingingWaiter : public Singing, public Waiter&#123;...&#125; 但这将出现二义性,因为Singing和Waiter都继承了一个Worker:12SingingWaiter sw;Worker* pw = sw; //二义性,鬼知道这时候用哪个worker so..应该使用类型转换来指定对象:123Worker* pw = (Singing*) &amp;sw;Worker* pw2 = (Waiter*) &amp;sw;//不过下面还有更简(ma)单(fan)的虚基类可以解决该问题 虚基类虚基类使得从多个类(他们基类相同)派生出的对象只继承一个基类对象.例如:在类声明中使用关键字virtual,可以使Worker被作用Singer和Waiter的虚基类:12class Singer : virtual public Worker&#123;...&#125;class Waiter : public virtual Worker&#123;...&#125; //这么写也行 然后 SingingWaiter可以定义为:1class SingingWaiter : public Singer,public Waiter&#123;...&#125; 现在SingingWaiter类只有一个Worker对象副本了,Singer和worker共享一个Worker对象,所以现在可以使用多态了. 新的构造函数规则使用虚基类时,构造函数需要使用一种新的方法,这是因为C++在基类是虚的时,禁止信息通过中间自动传递给基类,编译器在这时会使用基类的默认构造函数. 12345678910111213//通过中间类自动传递:class A&#123; int a; A(int n = 0) : a(n);&#125;class B :public A&#123; int b; B(int a = 0, int bm = 0) : A(a),b(bm);&#125;class C : public B&#123; int c; C(int a = 0, int b = 0, int cm = 0) : B(a,b),c(cm);&#125; 使用虚基类时我们必须显示调用构造函数:1234567SingingWaiter(const Worker &amp; wk,int p = 0,int v = Singer::other) :Worker(wk),Waiter(wk,p),Singer(wk,v)&#123;&#125; //显示使用worker SingingWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other) :Waiter(wk,p),Singer(wk,v)&#123;&#125; //错误的示范,会调用Worker的默认构造函数 对于非虚基类,显示调用Worker(const Worker&amp;)是非法的 哪个方法?那么问题来了,我们打算在SingingWaiter中重定义Show方法,并用SingingWaiter对象调用继承的Show方法:12345//所以我傻不愣登的写下了如下代码:SingingWaiter aha(&quot;喵喵&quot;,2017,1,soprano);aha.Show(); //二义性,Worker和Singer都有Show() 鬼知道这个是哪个?aha.Singer::Show(); //然而可以用作用域解析运算符来确定 最好是使用模块化:12345678910111213141516171819Woeker::Data() const &#123; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name; cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id;&#125;Waiter::Data() const&#123; cout &lt;&lt; &quot;panache: &quot; &lt;&lt; panache &lt;&lt; endl;&#125;Singer::Data() const&#123; cout &lt;&lt; &quot;rating: &quot; &lt;&lt; pv[voice] &lt;&lt; endl;&#125;SingingWaiter::Data() const&#123; Worker::Data(); Singer::Data();&#125;SingingWaiter::Show() const&#123; Worker::Data(); Data();&#125;//就是.........有点麻烦...","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"Hello World!!","date":"2016-12-27T13:49:34.066Z","path":"2016/12/27/hello-world/","text":"喵喵喵 本人的渣渣博客 以后就在这里撒欢辣 写的比较傻逼~ 大神轻喷呐 如有错误还劳驾指出哦~ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"C++笔记-私有继承","date":"2016-12-23T16:17:20.000Z","path":"2016/12/24/C++笔记-私有继承/","text":"使用私有继承,基类的共有成员以及保护成员都将成为派生类的私有成员派生类不继承基类的接口,但能在派生类的成员函数中使用它们,私有继承特征与包含相同:不继承接口,继承实现.所以它可以用来实现has-a关系. 示例:123456class player : private string,private valarray&lt;double&gt;//使用多个基类:多重继承&#123; public: ...&#125; 在这里新版本的构造函数将使用初始化成员列表,使用类名而不是使用成员名来标识构造函数: 12player::player(const char* str,const double* p,int i) : string(str),valarray&lt;double&gt;(p,i)&#123; &#125; 保护继承1class player : protected string,protected valarray&lt;double&gt;&#123;...&#125; 保护继承时,基类的公有成员和保护成员都将成为派生类的保护成员.使用私有继承时,第三代类将不能使用基类的接口,这是因为基类的公有方法在派生类中将变成私有方法.使用保护继承时,基类的公有方法将在二代类中变成受保护的,所以第三代类可以使用它们. 使用using重定义访问权限使用保护派生或者私有派生时,基类的公有继承将成为保护或者私有成员,如果想让基类方法在类外使用可以定义一个使用该基类方法的派生类方法.1234//派生类player希望使用基类valarray类的sum方法double player::sum() const &#123; return valarry&lt;double&gt;::sum();&#125; 或者可以使用using声明:123456class player : private valarray&lt;double&gt;&#123; public: using valarray&lt;double&gt;::min; using valarray&lt;double&gt;::max;&#125; 他们就像player类的共有方法一样:1cout &lt;&lt; &quot;high score:&quot; &lt;&lt; a[i].max &lt;&lt; endl; 注意 using声明只使用成员名,没有特征标,圆括号,返回类型,例如要在player]类中使用valarray类的operator[]方法,只需包含:1using::valarray::operator[]; 通常使用包含来建立has-a关系;如果新类需要访问原有类的保护成员,或需要重新定义虚函数应使用私有继承","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-包含类对象的成员","date":"2016-12-23T14:19:08.000Z","path":"2016/12/23/C++笔记-包含类对象的成员/","text":"接口和实现 使用公有继承时,类可以继承接口,可能还有实现(基类的纯虚函数提供接口,但不提供实现),获得接口是is-a的关系组成部分.而是用组合,类可以获得实现不继承接口是has-a的关系组成部分. 错误的示范:1234567891011121314class player&#123;private: string name; valarray&lt;double&gt; source; ostream &amp; arr_out(ostream &amp; os) const;public: player():name(&quot;NULL&quot;),source()&#123;&#125; explicit player(const string &amp; s) :name(s),source()&#123;&#125; explicit player(int n) :name(&quot;NULL&quot;),source(n)&#123;&#125; player(const string&amp; na, int n) :name(na),source(n)&#123;&#125;&#125;; 12player mylove(&quot;YSY&quot;,10);mylove = 5; //喵喵喵??重置ArrayD为五个空值的元素? mylove = 5;这里应该是:mylove[5] = 5才对.如果没有写explicit,编译器将调用转换构造函数player(5),name 的默认值将是NULL,并且编译器将会生成一个临时对象,并用临时对象替换mylove原有的值,这并不是我们想要的.如果加了explicit,编译器会报错这对我们debug很有利.毕竟在编译期出错优于在运行期出错.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-类设计总结","date":"2016-12-21T14:57:57.000Z","path":"2016/12/21/C++笔记-类设计总结/","text":"默认构造函数:默认构造函数要么没有参数,要么所有参数都有默认值.在派生类构造函数初始化列表中记得显示调用基类构造函数,否则编译器将会使用基类的默认构造函数,这可能会出现错误. 复制构造函数:1classname(const classname &amp;) 在按值传递,安置返回对象,编译器生产临时对象,将新对象初始化为一个同类对象的时候,将调用复制构造函数. 赋值运算符: 1classname &amp; operator=(const classname &amp;) 用于处理同类对象间的赋值,如果希望处理string类与classname类的赋值可以写成:1classname &amp; operator=(const string &amp;) 析构函数:当对象过期时,析构函数负责清理工作(如释放内存),对于基类应该提供一个虚析构函数,即使他不需要. 转换构造函数:1classname(const schar *) 使用一个参数的构造函数他定义了从参数类型到类类型的转换(话说这个中文名跟转换函数就差了两个字,但不一样容易弄混). 123Star(const char*);Star a = Star(&quot;233&quot;);a = &quot;233&quot;; 第二/三句话将会调用Star::operator(const Star &amp;)并使用Star(const char)生成一个对象,该对象将作用于赋值运算符函数的参数. 使用转换构造函数时候时建议使用explicit禁止隐式转换* 按值传递对象与传递引用通常在编写以对象作为参数的函数时,应该按引用,不应该使用按值传递参数,一是为了效率,二是因为在继承使用虚函数时,基类使用引用参数的函数可以接受派生类. 返回对象与返回引用如果函数返回的是通过引用或指针传递给他的对象,则应该按引用返回对象.返回引用可以节约内存和时间,与按引用传递相似,调用与被调用函数使用同一个对象进行操作.但不总是可以返回引用,比如函数不能返回一个在函数中创建的临时变量的引用,因为当函数结束时临时变量将会消失,这时候应该返回对象. const123456789classname::classname(const char * s) //确保方法不修改参数classname::show() const; //确保方法不修改调用他的对象,这里的const表示const classname * this,this指向调用的对象const classname&amp; classname::fun(const classname &amp; cn) const&#123; if(s.total &gt; total) return s; else return *this;&#125;;//该方法返回cn/this的引用,但因为cn/this是const,所以方法不能对cn/this进行修改,这意味着返回类型也必须为const 共有继承要考虑的因素:is-a关系is-a为”是一个”的意思,如果派生类不是某种特殊的基类则不要使用,比如从大脑类派生出程序员类.is-a关系的标志之一是:无需进行显示转换即可将积累指针或引用指向或引用派生类对象(向上强制类型转换).反之是可能出现错误的. 赋值运算符将派生类赋值给基类对象:123456class ZheXue &#123;...&#125;//基类-哲♂学class GaoBiLi : public ZheXue&#123;...&#125;//派生类-搞♂比♂利ZheXue bili;GaoBiLi fuc;bili = fuc; 1bili = fuc; 这将转化为: bili.operator=(fuc)他将调用 ZheXue::operator=(const ZheXue &amp;); 那如果将基类赋值给派生类对象呢:1fuc = bili; 这将转化为fuc.operator=(bili) ; 他将调用 GaoBiLi::operator=(const GaoBiLi &amp;);然而,派生类引用不能自动引用基类对象.除非我们定义转换构造函数:GaoBiLi(const ZheXue &amp;) ;转换构造函数可以有一个类型为基类的参数和其他参数,但其他参数必须有默认值: 1GaoBiLi(const ZheXue &amp; zx,string &amp; na = &quot;比♂利♂王&quot;,string &amp; ty = &quot;森之♂妖精&quot;); 这样转换构造函数会根据bili来创建一个临时对象,然后把它作为赋值运算符的参数.然而还可以直接写个参数为ZheXue的赋值运算符函数….: 1GaoBiLi::operator=(const ZheXue &amp;)&#123;......&#125;; 私有成员与保护成员对于外界来说,只能用共有成员来访问二者,对于派生类来说,可以直接访问基类的保护成员,而私有成员仍要通过基类的成员函数来访问. 虚方法如果要在派生类中重定义基类的方法则应该使用virtual. 析构函数基类的析构函数应当是虚的.这样在使用指针或者引用删除派生对象时,程序会先调用派生类的析构函数然后调用基类的,而不会只调用基类的析构函数 友元函数友元函数并非类成员因此不能继承,如果希望派生类函数能使用基类的友元函数,可以使派生类指针或引用强制转换为基类的指针或引用,然后使用转换后的指针或引用来调用友元函数. 123456ostream &amp; GaoBiLi::operator&lt;&lt;(ostream &amp; os, GaoBiLi &amp; gbl)&#123; os &lt;&lt; (const ZheXue &amp;)gbl; os &lt;&lt; &quot;name:&quot; &lt;&lt; gbl.name &lt;&lt; endl; return os;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-继承和动态内存分配","date":"2016-12-15T14:01:19.000Z","path":"2016/12/15/C++笔记-继承和动态内存分配/","text":"如果基类使用动态内存分配，派生类不使用1234567891011121314151617class player&#123; privatec: string * name; bool sex; public： player(const string &amp; na = &quot;NULL&quot;,bool a = 0); player(const player &amp; p); virtual ~player(); player &amp; operator=(const player &amp; p);&#125;class ship : public player&#123; private: int age; public: ...&#125; 那么是否要为ship类定义显示析构函数,复制构造函数,重载赋值运算符呢? 不需要. 析构函数: 对于ship类,我们没有对他进行任何特殊的操作,所以默认的析构函数是合适的 复制构造函数:首先我们知道的是,默认复制构造函数是执行成员复制,因为player使用了动态内存分配,所以,默认复制构造函数不适用于player类,但对于ship类是适合的.当复制继承的组件获或者成员时,则使用他的复制构造函数.所以当ship的默认复制构造函数会使用player的默认复制构造函数来复制ship里的player对象.所以默认复制构造函数对于他们来说是合适的. 赋值运算符: ship默认的赋值运算符也会使用player的赋值运算符来对player成员进行赋值,所以是合适的. 如果基类和派生类都使用动态内存分配123456class ship : public player&#123; private: string * type; public: ...&#125; 在这种情况下必须显示定义派生类的显示析构函数,复制构造函数,重载赋值运算符. 析构函数: 派生类的析构函数先释放type所管理的内存,然后基类析构函数释放name所管理的内存. 复制构造函数:派生类的复制构造函数只能访问派生类的数据,所以他必须调用父类的复制构造函数.ship::ship(const ship &amp; p) : player(p) , 因为player类因为复制构造函数有一个player&amp;参数,而基类可以指向派生类型,因此player的复制构造函数将使用ship参数的player部分来构造新对象的player部分. 赋值运算符:因为派生类采用动态内存分配,所以他需要一个显示赋值运算符.ship的赋值运算符只能直接访问ship类的数据,但他却要负责所继承的基类对象的赋值,这个时候可以显示调用基类的赋值运算符方法.然后在处理派生类的赋值.1234567ship &amp; ship::operator=(const player &amp; p)&#123; if(this == p) return *this; player::operator=(p);//显示调用基类赋值运算符 delete type; type = new string; type = p.type;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-抽象基类(Abstract-Base-Class,ABC)","date":"2016-12-14T15:46:31.000Z","path":"2016/12/14/C++笔记-抽象基类(Abstract-Base-Class,ABC)/","text":"啥时候使用抽象基类?在下理解的是:你有一个基类和一个该基类的派生类,但是基类里有一些你派生类根本用不上的方法,使用了派生类就会导致一些信息冗余.然而不继承基类单独写个类你发现效率也不高,而且你发现你的基类和你的派生类之前还是有共同点的..这个时候就要上抽象基类了….把其共同点放到抽象基类里,然后分别从抽象基类派生刚才的”基类”与”派生类”. 啥是抽象基类 就是类里定义了纯虚函数的类………然而定义了纯虚函数就只能作为基类了.23333 纯虚函数纯虚函数:virtual 返回类型 函数名(形参) =0;在虚函数声明后面加个 =0 就是纯虚函数了,当类声明中包含纯虚函数的时候,则不能创建该类对象.所以包含纯虚函数的类只能作为基类,在原型中使用 =0 指出类是一个抽象基类,在类中可以不定义该函数.12345678class player&#123; private: int age; string name; pbulic: ... virtual void show() = 0;&#125; 总之: ABC描述的是至少使用一个纯虚函数的接口,从ABC派生出的类将根据派生类的具体特征使用常规虚函数来实现这种接口.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-访问控制protected","date":"2016-12-13T15:22:36.000Z","path":"2016/12/13/C++笔记-访问控制protected/","text":"protected关键字protected的意思是保护,和private有点相似,在类外只能通过共有类成员来访问protected中的成员.但他与private的区别体现在:在派生类中,派生类的成员可以直接访问基类的protected成员,但不能直接访问基类的private成员.举个栗子:12345678910111213141516class player&#123; ... public: void R18(int a)&#123; if(a&lt;18)cout &lt;&lt; &quot;禁止入内&quot;; else &#123;cout &lt;&lt; &quot;欢♂迎&quot;; &#125; protected: int age;&#125;class ship : public player&#123; ... public: void showshipage(int m)&#123; age = m; cout &lt;&lt; age &lt;&lt; &quot;欢♂迎&quot;;&#125;//通过派生类公有成员直接访问基类protected成员 ...&#125; 但是这样做是有点小问题的age成员被设置为只能通过player::R18()来访问,但是有了ship::showshipage()将会忽略player::R18()的禁止入内措施,这使得age变成了一个公有变量…….然而对于成员函数来,保护控制很有用,他可以让派生类访问一些公众不能访问的内部函数.so..你问我滋补滋磁,我是滋次的.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-静态联编和动态联编","date":"2016-12-11T15:38:53.000Z","path":"2016/12/11/C++笔记-静态联编和动态联编/","text":"一些理解性概念 啥是联编将源代码中的程序调用解释为执行特定的函数代码块被称为函数名联编在编译过程中的联编被称为静态联编在程序运行时的联编被称为静态连编 ##指针和引用类型的兼容性将派生类指针或引用转为基类指针或者引用被称为向上强制转换,如果是共有继承则不需要进行显式类型转换,任何对基类对象做的操作都适合派生类对象.相反,将基类指针或者引用转换为派生类指针或者引用被称为向下强制转换,需要显示类型转换,但是派生类可以新增成员函数,由于基类没有这些函数,这使得使用新增成员函数的类成员函数不能作用于基类.123456789101112131415161718192021222324class player&#123; pubilc: player(string &amp; na)&#123;name = na;&#125; void showname()const &#123;cout &lt;&lt; name;&#125; private: string name;&#125;class ship : pubilc player&#123; public: ... void shouage(int age); private: int age;&#125;player lex(&quot;lexington&quot;); ship * t =(ship*)&amp;lex; //将基类指针转化为派生类指针,必须显示类型转换,向下强制转换ship sar(&quot;saratoga&quot;);player* v = &amp;sar; //将派生类指针转化为基类指针,向上强制转换t-&gt;showage(20); //不安全的操作 showage不是player的成员v-&gt;showname(); //安全的 现在我们有个虚方法1234567891011121314``` void fr(player &amp; r) //r.sizhai(); void fp(player * p) //p-&gt;sizhai(); void fv(player v) //v.sizhai(); fun()&#123; player p(&quot;LEX&quot;); ship s(&quot;sar&quot;); fr(p); // player::sizhai(); fr(s); // ship::sizhai(); fp(p); // player::sizhai(); fp(s); // ship::sizhai(); fv(p); // player::sizhai(); fv(s); // player::sizhai(); &#125; 由于按值传递ship对象的player部分被传递给函数fv().但是引用和指针发生的向上强制转换分别为player对象和ship对象使用了不同的函数(virtual).隐式向上强制类型转换使得基类对象可以指向基类对象或派生类对象,因此需要动态联编. 虚函数和动态联编概念理解:虚函数工作原理通常,编译器处理虚函数的原理是:给每个对象添加一个隐藏成员,这个隐藏成员保存了一个指向函数地址数组的指针.它被称为虚函数表,虚函数表保存了类对象的虚函数地址.列如,基类对象包含一个指针,它指向基类中所有虚函数的地址表.派生类对象将指向一个独立地址表的指针,如果派生类里提供了虚函数的定义,那么这个独立的地址表将会保存新函数的地址,如果没提供,该表将使用原始版本的地址.如果派生类定义了新的虚函数,那么该函数的地址也会被添加到表中. 注意:无论类中有多少个虚函数,都只在对象中添加一个地址成员,只是大小有所差别 虚函数总结: 构造函数不能是虚函数; 析构函数应该是虚函数(除非不作为基类); 友元不能是虚函数,因为友元函数不是类成员; 如果基类声明被重载,则应在派生类中重定义所有的基类重载版本; 重定义不是重载,如果重定义继承的方法,应该确保与原型完全一致;注意:如果原返回类型是指向基类的指针或者引用,可以改成指向派生类的指针和引用,这被成为返回类型协变","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-一个简单的基类","date":"2016-12-08T13:58:54.000Z","path":"2016/12/08/C++笔记-一个简单的基类/","text":"从一个类派生出另一个类,原始类被称为基类,继承类被称为派生类例:1234567891011121314151617181920class player&#123; public: player(const string &amp; na,bool se = 1); void Name() const&#123;cout &lt;&lt; name &lt;&lt; endl;&#125; bool sex &#123;return sex;&#125; privat: string name; bool sex;&#125; class Ship : public player //继承了player类 公有派生&#123; public://派生类需要自己的构造函数并且必须使用基类的构造函数 Ship(bool mw = 0,int ag, const string &amp; na, bool se = 1); Ship(bool mw = 0,int ag,player &amp; p); int ShowAge() &#123;cout &lt;&lt; age; return age;&#125; private: bool myWife; int age;&#125; 冒号说明了Ship的基类是player,public表示了这个基类是公有基类,这被成为公有派生.使用公有基类,基类的公有成员将成为派生类的公有成员,基类的私有成员也将成为派生类的一部分但是不能直接访问,需要通过继承的基类的公有方法来间接访问.创建派生类对象的时候,首先创造基类对象,C艹使用成员列表初始化完成该工作:12345678910//在此声明成员列表初始化只能用于构造函数 Ship::Ship(bool mw, int ag,const string &amp; na,bool se) : player(na,se)&#123; mw = 1; ag = 18; &#125; Ship::Ship(bool mw,int ag,player &amp; p) : player(p)&#123; mw = 0; ag = 14; &#125; 在第二个构造函数中 由于基类类型为 player &amp; ,因此将会调用基类的复制构造函数,由于基类没有该函数,则编译器将会自动生成一个~基类对象首先被创建.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数 派生类和基类之间的特殊关系基类指针或引用可以在不进行显式类型转换的情况下,指向或引用派生类对象或引用.然而基类指针和引用只能用于调用基类方法.所以不能用它们来调用派生类方法,如果将基类对象和地址赋值给派生类引用和指针.因为派生类引用可以为基类对象调用派生类方法,但是基类没有派生类的成员所以这么做是没意义的.可以这么写:123456789Ship sp1(1,17,&quot;Lexington&quot;,0);player *a = &amp;sp1; //OKplayer &amp;b = sp1; //OKa.Name();b-&gt;Name();player sp2(&quot;Saratoga&quot;,0);Ship *c = &amp;sp2; //不能这么写Ship &amp;d = sp2; //也不能这么写 但是如果基类引用和指针可以指向派生类对象呢?12345678void Show(const player &amp; p)&#123; //OK p.Name();&#125;player temp1(&quot;LEX&quot;,0);Ship temp2(1,17&quot;SAG&quot;,0);Show(temp1); //OKShow(temp2); //OK 函数Show的形参为一个基类引用,他可以指向基类对象或者派生类对象,并且该函数使用了基类的一个方法,所以Show可以使用player参数或者Ship参数.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-多态公有继承","date":"2016-12-07T15:35:20.000Z","path":"2016/12/07/C++笔记-多态公有继承/","text":"虚方法:virtual该声明之处方法在派生类版本的行为不同.12345678910111213141516171819class You&#123;public: You(const string&amp; Na)&#123;Name = na;&#125; virtual string Show()&#123;return Name;&#125; ~You()&#123;&#125;private: string Name;&#125;class YouName : public You&#123;public:YouName()&#123;&#125;~YouName()&#123;&#125;virtual void Show()&#123;cout &lt;&lt; &quot;your name is &quot;; Name();&#125;&#125;You A(&quot;YSY&quot;); YouName B(&quot;YES&quot;);A.Name(); //You::Name()B.Name(); //YouNAme::Name(); 基类版本限定名为You::Show(),派生类限定名为YouName::Show()程序会根据使用对象类型来确定使用哪个版本. 需要注意的是如果方法是通过指针或引用调用的呢?程序将使用哪种方法? 如果没有使用关键字virtual,程序将根据引用类型或者指针类型来选择方法,如果使用了关键字virtual,程序将根据引用或指针指向的对象的类型来确定方法~","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"C++笔记-类和动态内存分配","date":"2016-12-07T13:59:20.000Z","path":"2016/12/07/C++笔记-类和动态内存分配/","text":"对于类中的非静态const数据成员,必须在执行到构造函数体前,级创建对象时进行初始化.他叫做成员列表初始化:123456789101112131415161718class FUN&#123; public: struct Node&#123;Item item;struct Node* next;&#125; Node* fornt; Node* rear; int items; const int qsize;&#125;FUN::FUN(int qs) : qsize(qs)&#123; front = rear = nullptr; items = 0;&#125;//然而这种方法不局限于常量 所以也可以这么写FUN::FUN(int qs):qsize(qs),rear(nullptr),front(nullptr),items(0)&#123;...&#125; 注意只有构造函数才可以使用这种方法,另外对于被引用的类成员也必须这么写: 123456class A&#123;...&#125;;class B&#123;private: A &amp; hello;&#125;B::B(A &amp; h) : hello(h)&#123;....&#125; 关于C++11的内存初始化直接这么写就行(那我们为啥要用第一种方法啊魂淡(｡•ˇ‸ˇ•｡)):1234class Classy&#123; int meml = 10; const int mem2 = 20;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"}]},{"title":"QML与C++交互","date":"2016-12-05T14:38:29.000Z","path":"2016/12/05/QT-QML与C++交互/","text":"图片作者为:Bison仓鼠终于搞定了gayhub的博客,以后就在这里写一些自己想写的东西好了 ╰(´︶`)╯ 前几天用QT的QML与C++交互,基于QMediaPlayer类撸了一个baka音乐播放器 因为是第一次用QML撸 再加上我幼儿园水平的代码 写的一团糟..代码请用鼠标♂插 这里 这个坑爹的QML与C++交互折腾了我好久 (╬▔▽▔)凸 以我这辣鸡播放器为例(大神请绕道orz) 那么问题来了如何使用C艹来控制QML?假设我们的qml是酱紫写的 1234567891011121314151617181920212223Rectangle &#123; id: head y: 0 width: parent.width height: 40 color: \"#222225\" opacity: 0.95 Layout.maximumHeight: 45 Layout.fillWidth: true Layout.fillHeight: false Text &#123; id: musicteitle x:5 y:5 width: parent.width height: 30 color: \"#C8C8C8\" font.family: \"microsoft yahei\" font.pixelSize: 23 text:\"正在播放: \" + myTITLE &#125; &#125; 让我们用这段代码来显示正在播放的某音乐的名字,细心的你可能发现了 你写这辣鸡玩意前面的我都能看懂 那个myTITLE是什么鬼?这里让我们隆重介绍一下QQmlContext这个神奇的类 : “QQmlContext类定义了一个QML引擎上下文引擎上下文允许将数据暴露给由QML引擎实例化的QML组件每个QQmlContext包含一组属性，与其QObject属性不同，它允许数据通过名称显式绑定到上下文。上下文属性通过调用QQmlContext :: setContextProperty（）来定义和更新” –power for 谷歌翻译 参照官网 于是我们可以酱紫来控制音乐的名字:123QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* title = view-&gt;rootContext();title-&gt;setContextProperty(\"myTITLE\",QVariant(NowMusicName)); 通过修改NowMusicName的值就可修改myTITLE的值 这俩东西是绑定的于是我们就可以通过C++来修改NowMusicName 从而修改QML中的myTITLE 进而达到显示出当前音乐名字的目的 那么 view是何方神圣? 官方文档: QQmlApplicationEngine QQmlApplicationEngine提供了从单个QML文件加载应用程序的方便方法。这个类结合了QQmlEngine和QQmlComponent来提供一个方便的方式来加载单个QML文件。它还向QML提供了一些中央应用程序功能，C++/QML混合应用程序通常会从C++控制 –power for 谷歌翻译 果冻,能不能给力点啊?(눈_눈) 你说的这么水 没人会看的好吧ಥ_ಥ 既然能从用C艹来艹QML 那自然也能用QML来艹C艹了 如何用QML来艹C艹?假设我们现在有个音乐类Music 我们想通过点击某个按钮来调用Music类的暂停函数 那么如何实现呢?这个就相对的比较简单了123456//main.cpp如下Music A;QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* context = view-&gt;rootContext();context-&gt;setContextProperty(&quot;myPlay&quot;,A); //先创建一个关于Music类的一个上下文 123456789101112131415161718192021222324//fun.qml如下MouseArea &#123; //设置鼠标点击区域 id: sta_pau x: 120 y: 8 width: 45 height: 45 Layout.maximumHeight: 40 Layout.maximumWidth: 70 Layout.fillHeight: true Layout.fillWidth: true onClicked: &#123; myPlay.pausePlay(); &#125; &#125; Image &#123; //把图片放到鼠标点击区域上去 这就是个按钮了 不要在意用没用button那个细节233 id: sta_pau_bg x: 120 y: 8 width: 45 height: 45 source: \"///img/我是一个萌萌的按钮图片.png\" &#125; 这样 一旦我们点击鼠标区域 就会触发与myPlay相之绑定的Music类对象A 从而调用A的暂停播放函数. 果冻,能不能再给力点啊?(눈_눈) 你说的这么水 等着挨喷吧 o(////▽////)q 既然你诚心诚意的发问了~那么,现在让我们结合起用C艹来艹QML与用QML来艹C艹,假设我们要撸一个音乐播放器的进度条.C艹负责处理歌曲总时长,当前播放进度,QML负责用花哨の特♂技显示出来这些. 机智的你一定想到了,这还不简单,QML中使用一个Text控件用于显示,C艹则用QQmlContext建立上下文把总时长与标记绑定,当总时长改变,标记的值也会随之改变,显示出来的总时长也会随之改变. 而当前播放进度则使用QML的进度条显示Slider 控件处理.Slider的value就是当前播放的进度,通过点击事件onPressedChanged来处理进度条的拖动~ 为了更精细的显示出当前播放进度,我们还需要一个用于显示当前播放秒数的Text~同理用C艹获得当前播放秒数,绑定上下文就成.这里只截出一部分 详情还劳烦各位去窝项目上的main.qml与music.cpp上瞅瞅 鬼畜级代码奉上(｡・`ω´･)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*QML*/ RowLayout &#123; id: progress x: 0 y: 20 width: 580 height: 60 spacing: 5 Layout.maximumWidth: 580 Text &#123; /*用于精确显示当前播放秒数*/ id: s_time y: 0 width: 40 height: 20 color: \"#C8C8C8\"; text: mySTIME /*秒数的上下文*/ font.pixelSize: 18 &#125; Slider &#123; id: bar x: 50 width: 450 height: 20 Layout.maximumWidth: 550 Layout.maximumHeight: 20 Layout.fillWidth: true maximumValue:myPlay.getEndtime();/*使用与Music类对象A绑定的上下文来获得当前音乐的总时长*/ value: setNOW /*用当前播放的值来设置进度条的当前进度*/ onPressedChanged: &#123; /*点击事件:当进度条拖动时改变音乐进度*/ myPlay.setNowMusicPos(value); &#125; &#125; Text &#123; id: e_time x: 515 y: 0 width: 40 height: 20 color: \"#C8C8C8\" text: myETIME /*总时长的上下文*/ font.pixelSize: 18 &#125; &#125; 12345678910111213141516/*C艹*/ QObject::connect(now, &amp;QMediaPlayer::positionChanged, [this](qint64 position)&#123; if(nowMusic-&gt;duration() != 0) /*QMediaPlayer* nowMusic */ this-&gt;setEndtime(this-&gt;now-&gt;duration()); //获取当前音乐的总时长 settime(position); /*Music类成员,用于获得当前播放的位置(就是当前播放到哪了 单位:毫秒)*/ QQmlContext* s_time =myView-&gt;rootContext(); //当前播放时长的上下文 s_time-&gt;setContextProperty(\"mySTIME\",QVariant(timeformat(position))); QQmlContext* now_progress = myView-&gt;rootContext();//进度条值的上下文 now_progress-&gt;setContextProperty(\"setNOW\",QVariant(position)); QQmlContext* e_time = myView-&gt;rootContext(); //总时长的上下文 e_time-&gt;setContextProperty(\"myETIME\",QVariant(timeformat(this-&gt;endtime))); &#125;); 在这里我们使用了一个QMediaPlayer类的一个信号,每当音乐播放进度改变时都会发射该信号从而调用与之对应的槽(在这段代码里槽为一个lambda).需要注意的是这个信号发射粒度(周期)为1s,据说可以修改发射粒度,找了半天无果,如果你知道怎么改,请务必联系我~阿里嘎多~每当音乐播放1s,positionchanged信号被发射,C++代码刷新各项数据,通过上下文引擎把数据暴露给QML.当进度条拖动的时候,QML的点击事件将触发改变音乐进度的函数来改变播放进度. 大概就酱 谢谢捧场 谢谢~ 欢迎讨论~欢迎纠错(逃","tags":[{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"QML","slug":"QML","permalink":"http://yoursite.com/tags/QML/"}]}]