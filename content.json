[{"title":"C++笔记-友元类","date":"2017-03-05T15:07:46.000Z","path":"2017/03/05/C++笔记-友元类/","text":"类并非只能拥有友元函数还可以将类作为友元,友元被赋予从类外访问类的私有部分的权限,在这种情况下,友元类的所有方法都可以访问原始类的公有/私有/保护成员,也能指定特定的成员函数为一个类的友元. 什么时候希望一个类成为另一个类的友元? 书上举得一个栗子:完整代码 假设编写一个模拟遥控器和电视机的程序,决定有TV和Remote类表示电视机和遥控器,显然这两个类存在着某种关系(净说废话).但电视机不是遥控器,反之亦然,所以正常的公有继承is-a关系并不适用.遥控器并非电视机的一部分.所以,包含私有和保护集成的has-a关系也不适用.但众所周知遥控器可以改变电视机的状态.这说明遥控器应该是电视机类的一个友元. 友元的声明:友元声明可以位于公有,私有或者保护部分,所在其位置无关紧要.但由于Remote类提到了TV类所以必须先定义Tv类,或者使用前向声明.这样来声明一个友元类:1friend class Remote; 1234567891011121314151617181920212223242526272829303132333435363738394041class Tv&#123;public: friend class Remote; enum&#123;off,on&#125;; enum&#123;MinVal,MaxVal = 20&#125;; enum&#123;Antenna,cable&#125;; enum&#123;tv,dvd&#125;; Tv(int s = off,int mc = 125):state(s),volume(5), maxchannel(mc),channel(2),mode(cable),input(tv)&#123;&#125; void onoff()&#123;state = (state == tv) ? off: on;&#125; bool ison() const &#123;return state == on;&#125; bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode()&#123;mode = (mode = Antenna) ? cable: Antenna;&#125; void set_input()&#123;input = (input = tv) ? dvd : tv;&#125; void settings() const;private: int state; int volume; int maxchannel; int channel; int mode; int input;&#125;;class Remote&#123;private: int mode;public: Remote(int m = Tv::tv):mode(m)&#123;&#125; bool volup(Tv &amp; t)&#123;return t.volup();&#125; bool voldown(Tv &amp;t)&#123;return t.voldown();&#125; void onoff(Tv &amp; t)&#123;t.onoff();&#125; void chanup(Tv &amp;t)&#123;return t.chanup();&#125; void chandown(Tv &amp;t)&#123;return t.chandown();&#125; void set_mode(Tv &amp;t)&#123;return t.set_mode();&#125; void set_input(Tv &amp;t)&#123;return t.set_input();&#125; void set_chan(Tv &amp;t, int c)&#123;t.channel = c;&#125;&#125;; 从上面的从书中摘抄的毫无诚意的代码中可以看出,所有的Remote方法都是Tv类的友元,似乎Remote类除了构造函数都使用了Tv类的公有接口,但是事上唯一直接访问了Tv类成员的Remote类方法是Remote::set_chan(),那么就可以选择仅特定的类成员成为另一个类的友元.但这样就要小心的排列声明和各种定义;让Remote::set_chan()成为Tv类的友元的方法是,在Tv类声明中将其定义为友元: 123class Tv&#123; friend void Remote::set_chan();&#125; 就酱,但是吧……编译器要处理这句话首先得知道Remote的定义,不然编译器不知道Remote是个类,所以这就要把Remote类的声明挪到Tv类声明前面,但Remote类用了Tv对象..这就又得把Tv类定义挪到Remote类定义前面去.咦等等.那Remote咋办他需要在Tv类的前面啊.这..这就很尴尬了,呐,避免这种死循环的方法是使用 前向声明(forward declaration):123class Tv ; //前向声明class Remote&#123;...&#125;class Tv&#123;...&#125;; 那能不能这样?:123class Remote;class Tv&#123;...&#125;;class Remote&#123;...&#125;; 这是不行的,在编译器在Tv类中的声明中看到Remote类的一个方法称为Tv类的友元之前,该先让编译器看到Remote类的声明和Remote::set_chan()函数的声明. 好了,但在Remote类中可以看到,有些方法包含了内联代码,例如: void onoff(Tv &amp; t){t.onoff();}由于它使用了一个Tv的方法,所以在此之前编译器必须看到Tv类声明,但是Tv类在Remote类后面声明..解决方法就是把函数定义放在Tv类之后就成.. 吼,现在只有一个Remote方法是Tv类的友元了; 编译器一开始通过前向类型得知了Tv是个类,在读取声明并编译了这些方法之后,使用lnline关键字仍然可以使Remote类未定义的函数称为内联方法.完整代码 其他友元关系遥控器能影响电视.现在你想通过电视对遥控器产生某种影响,这可以让类彼此成为对方的友元来实现; 需要记住的是对于使用Remote类对象的Tv方法,其 函数原型 可以在Remote类声明之前声明,但必须在Remote类之后定义,这样编译器才有足够的信息来编译该方法.12345678910111213class TV&#123;friend class Remote;public: void buzz(Remote &amp; r); ...&#125;;class Remote&#123; friend class Tv; public: void bool volup(Tv $ r)&#123;t.volup();&#125;&#125;;inline void Tv::buzz(Remote &amp; r)&#123;...&#125; 由于Remote声明在Tv后面,所以可以在类声明中定义volup();buzz()可以再Tv中声明,但必须在Remote后面定义; 共同友元函数需要访问两个类的私有数据,函数可以是一个类的成员,另一个类的友元; 也可以是两个类的友元:12345678910111213class A; //前向声明class B &#123; friend void fun(A &amp; a,const B &amp; b); //编译器发现前向类型A 得知A是一个类型 friend void fun(B &amp; b,const A &amp; a);&#125;class A&#123; friend void fun(A &amp; a,const B &amp; b); friend void fun(B &amp; b,const A &amp; a);&#125;//定义友元函数inline void fun(A &amp; a,const B &amp; b)&#123;...&#125;inline void fun(B &amp; b,const A &amp; a)&#123;...&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-嵌套类","date":"2017-03-04T15:04:38.000Z","path":"2017/03/04/C++笔记-嵌套类/","text":"封面来源 在(quan)神(shi)奇(keng)的C++中,放在另一个类中声明的类被称为嵌套类(nested class),它通过提供新的类型类作用域来避免名称混乱.包含类的成员和函数可以创建和使用被包含类的对象; 仅当嵌套类声明位于包含类的公有部分时,才可以在包含类外通过作用域解析运算符使用嵌套类; 不不不,这个和包含不一样,包含是将一个类的类对象作为另一个类的类成员; 而嵌套类则是定义了一种类型且仅在包含嵌套类声明的类中有效 12345678910//在包含类的私有部分声明了个嵌套类class Queue&#123;private: class Node &#123; public: Node(); &#125;&#125; 使用两次作用域解析运算符就可以定义Node()辣:1Queue::Node::Node()&#123;...&#125; 嵌套类和访问权限如果嵌套类是在另一个类的私有部分声明的,则只有包含他的类知道他的存在,且对于从包含类派生出来的类来讲,因为派生类不能直接访问基类私有部分,所以嵌套类也是不可见的. 如果嵌套类是在另一个类的保护部分声明的,则对于包含他的类来说是可见的,而对于外部来讲嵌套类是不可见的,但后者的派生类可以直接创建这种类对象. 如果嵌套类是在另一个类的公有部分声明的,因为他是公有的,则对于包含他的类,对与包含他的类的派生类以及外部世界都可以使用它. 访问控制在Queue类中声明Node类并没有赋予Queue类任何访问权限,Node也没有赋予Queue任何访问权限,所以Queue只能显示的访问Node成员,所有我将Noede类所有成员声明为公有,不过没关系,虽然Queue的方法可以直接访问Node类,但被Queue声明为私有的Node对于外部来讲是不可见的. 模板类中的嵌套(并不会发生什么奇怪的问题; 完整代码","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-成员模板&将模板用作于参数","date":"2017-01-08T15:43:01.000Z","path":"2017/01/08/C++笔记-成员模板&将模板用作参数/","text":"模板成员:模板类将另一个模板类和模板函数作为其成员1234567891011121314151617181920212223template &lt;typename T&gt;class beta&#123;private: template&lt;typename V&gt; class miao &#123; private: V val; public: miao(V v = 0) : val(v)&#123;&#125; void show() const &#123;cout &lt;&lt; val &lt;&lt; endl;&#125; V value() const &#123;return val;&#125; &#125;; miao&lt;T&gt; q; miao&lt;int&gt; n;public: beta(T t, int i) : q(t),n(i) &#123;&#125; template &lt;typename U&gt; U blab(U u,T t) &#123;return ((n.value() + q.value()) * u/t);&#125; void bshow() const &#123;q.show(); n.show();&#125;&#125;; 12hold&lt;T&gt; q;hold&lt;int&gt; n; n 是基于int 类型的hold 对象,q 的基于T 类型的hold 对象,下述声明使得T表示的是double,因此q 的类型是 hold&lt; double&gt;:1beat&lt;double&gt; guy(10,2.5); blab() 方法的U 类型由该方法被调用时的参数决定,T 类型由对象的实例化决定,下述例子中,guy 的声明将T 类型设置为double,U 的类型则为int.1cout&lt;&lt;guy.blab(10,2.5); 虽然混合类型所引起的自动类型转换导致blab() 函数中的计算以double 类型进行,但返回值的类型为U (即int),因此上述输被截断为28. 如果使用guy.blab()时,使用10.0代替10,那么U 的类型将会设置为double ,使得返回值也为double,因此输出为28.2608. 将模板类用作参数模板类可以包含类型参数(如 typename T )和非类型参数(如 int ),还可以包含本身就是模板的参数. 举个书上的栗子:12345678910111213141516171819202122232425262728293031template&lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;private: Thing&lt;int&gt; s1; Thing&lt;double&gt; s2;public: Crab()&#123;&#125; bool push(int a,double x)&#123; return s1.push(a) &amp;&amp; s2.push(x);&#125; bool pop(int &amp; a,double &amp; x)&#123;return s1.pop(a) &amp;&amp; s2.pop(x);&#125;&#125;;int main()&#123; Crab&lt;Stack&gt; cs; int ni; double nd; cout &lt;&lt; &quot;Enter int double pairs,such as 4 3.5(0 0 to end):&quot; &lt;&lt; endl; while (cin &gt;&gt; ni &gt;&gt;nd &amp;&amp; ni &gt; 0 &amp;&amp; nd &gt; 0) &#123; if(!cs.push(ni,nd)) break; &#125; while(cs.pop(ni,nd)) cout &lt;&lt; ni &lt;&lt; &quot; , &quot; &lt;&lt; nd &lt;&lt; endl; cout &lt;&lt; &quot;DONE&quot; &lt;&lt;endl; return 0;&#125; 12template &lt;template &lt;typename T&gt;class Thing&gt;class Crab&#123;&#125; 如上, 上述模板参数类型为template &lt; typename T&gt; class Thing,其中Thing 为参数. 这意味着为了使 Crab&lt; King&gt; legs 被接受,模板类参数King 必须是个模板类:12template &lt;typename K&gt; class King&#123;...&#125; legs 声明将用King&lt; int&gt; 替换 Thing&lt; int&gt; ,用 King&lt; double&gt; 替换 Thing&lt; double&gt;,但是在下面的代码中就有所不同. 在Crab 类中,有两行代码声明了两个类对象:12Thing&lt;int&gt; s1;Thing&lt;double&gt; s2; 而mian 函数中包含以下声明,因此,Thing&lt; int&gt; 将被实例化为 Stack&lt; int&gt; ,而Thing&lt; double&gt;将被实例化为Stack&lt; double&gt;.总之,模板参数Thing 将被替换为声明Crab 对象时被用作模板参数的模板类型.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-模板的具体化","date":"2017-01-06T11:32:50.000Z","path":"2017/01/06/C++笔记-模板的具体化/","text":"隐式实例化:编译器在需要对象之前,不会生成类的隐式实例化12ArrayTp&lt;int,100&gt; * pt; //不生成实例pt = new ArrayTp&lt;int,100&gt;;//现在生成实例 显式实例化:使用关键字template并指出所需类型来声明类的时候,编译器将生成类声明的显式实例化:1template class ArrayTp&lt;string,100&gt;; 在这种情况下,虽然没有创建类对象,编译器也将生成类,包括方法定义. 显式具体化:(显式具体化==特型)在需要特殊要求的时候对模板进行修改,使其行为不同,这时可以创建显式具体化. 书上举的栗子:假设现在定义一个表示排序后数组的类:1template &lt;typename T&gt; class SortedArray&#123;...&#125; 假设模板使用&gt;运算符来对值进行比较,对于数字来说没毛病,对于类型T,只要定义了T::operator&gt;(),也没毛病,但是T如果是个const char **的字符串就不行了,因为这需要使用strcmp(),而不是&gt;*.这种情况下可以提供一个现实模板具体化.格式如下:1template &lt;&gt; class Classname &lt;specialized-type-name&gt;&#123;...&#125; 当具体化模板和通用模板都与实例化请求匹配时,编译器将使用具体化模板. 所以说要使用const char 类型的SortedArray*模板可以这么写:1template &lt;&gt; class SortedArray&lt;const char *&gt; &#123;...&#125; 这样在使用const char **类型的SortedArray*模板时将使用上述专用定义而不是用通用模板定义. 部分具体化:部分具体化可以给类型参数制定具体的类型:12template &lt;class T1, class T2&gt; class Pair&#123;...&#125;;template &lt;class T1&gt; class Pari&lt;class T1,int&gt;&#123;...&#125;; template后面的是没有被具体化的类型参数.上述T2被具体化为int,但T1不变. 部分具体化特型使得能够设置各种限制,例如:12345678//一般模板template&lt;typename T1,typename T2,typename T3&gt;class Trio&#123;...&#125;//对T3具体化的模板template&lt;typename T1,T2&gt; class Trio&lt;T1,T2,T3&gt;&#123;...&#125;//对T2,T3具体化的模板template&lt;typename T1&gt; class Trio&lt;T1,T2*,T3*&gt;&#123;...&#125; template 后面的是没有被具体化的类型参数 给出上述定义编译器将作出如下选择:123Trio&lt;int,double,string*&gt; T1; //使用一般模板Trio&lt;int,short&gt; T2; //使用对T3具体化的模板Trio&lt;string,string*,char*&gt;;//使用对T2,T3具体化的模板","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-多重继承","date":"2016-12-30T11:31:05.000Z","path":"2016/12/30/C++笔记-多重继承/","text":"必须使用关键字来限定每一个基类,不然编译器会默认成私有派生:1class mylove : public string, valarray&lt;double&gt; //valarray为私有继承 其实你不用看这仨奇葩类的123456789101112131415161718192021222324252627282930313233343536373839404142class Worker&#123;public: Worker() : name(&quot;NULL&quot;),id(0L)&#123;&#125; Worker(const string &amp; s,long n) : name(s),id(n)&#123;&#125; virtual ~Worker() = 0; virtual void Set(); virtual void Show() const;private: string name; long id;&#125;;class Waiter : public Worker&#123;public: Waiter() : Worker(),panache(0)&#123;&#125; Waiter(const string &amp; s, long n, int p = 0) : Worker(s,n),panache(p)&#123;&#125; Waiter(const Worker &amp; w, int p) : Worker(w),panache(p)&#123;&#125; void Set(); void Show() const;private: int panache;&#125;;class Singer : public Worker&#123;public: Singer() : Worker(),voice(other)&#123;&#125; Singer(const string &amp; s, long n, int v = other) : Worker(s,n),voice(v)&#123;&#125; Singer(const Worker &amp; w, int v =other) : Worker(w),voice(v)&#123;&#125; void Set(); void Show() const;protected: enum&#123;other,alto,contralto,soprano,bass,baritone,tenor&#125;; enum&#123;Vtypes = 7&#125;;private: static char* pv[Vtypes]; int voice;&#125;; Worker?从Singer和Waiter共有派生出SingingWaiter:1class SingingWaiter : public Singing, public Waiter&#123;...&#125; 但这将出现二义性,因为Singing和Waiter都继承了一个Worker:12SingingWaiter sw;Worker* pw = sw; //二义性,鬼知道这时候用哪个worker so..应该使用类型转换来指定对象:123Worker* pw = (Singing*) &amp;sw;Worker* pw2 = (Waiter*) &amp;sw;//不过下面还有更简(ma)单(fan)的虚基类可以解决该问题 虚基类虚基类使得从多个类(他们基类相同)派生出的对象只继承一个基类对象.例如:在类声明中使用关键字virtual,可以使Worker被作用Singer和Waiter的虚基类:12class Singer : virtual public Worker&#123;...&#125;class Waiter : public virtual Worker&#123;...&#125; //这么写也行 然后 SingingWaiter可以定义为:1class SingingWaiter : public Singer,public Waiter&#123;...&#125; 现在SingingWaiter类只有一个Worker对象副本了,Singer和worker共享一个Worker对象,所以现在可以使用多态了. 新的构造函数规则使用虚基类时,构造函数需要使用一种新的方法,这是因为C++在基类是虚的时,禁止信息通过中间自动传递给基类,编译器在这时会使用基类的默认构造函数. 12345678910111213//通过中间类自动传递:class A&#123; int a; A(int n = 0) : a(n);&#125;class B :public A&#123; int b; B(int a = 0, int bm = 0) : A(a),b(bm);&#125;class C : public B&#123; int c; C(int a = 0, int b = 0, int cm = 0) : B(a,b),c(cm);&#125; 使用虚基类时我们必须显示调用构造函数:1234567SingingWaiter(const Worker &amp; wk,int p = 0,int v = Singer::other) :Worker(wk),Waiter(wk,p),Singer(wk,v)&#123;&#125; //显示使用worker SingingWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other) :Waiter(wk,p),Singer(wk,v)&#123;&#125; //错误的示范,会调用Worker的默认构造函数 对于非虚基类,显示调用Worker(const Worker&amp;)是非法的 哪个方法?那么问题来了,我们打算在SingingWaiter中重定义Show方法,并用SingingWaiter对象调用继承的Show方法:12345//所以我傻不愣登的写下了如下代码:SingingWaiter aha(&quot;喵喵&quot;,2017,1,soprano);aha.Show(); //二义性,Worker和Singer都有Show() 鬼知道这个是哪个?aha.Singer::Show(); //然而可以用作用域解析运算符来确定 最好是使用模块化:12345678910111213141516171819Woeker::Data() const &#123; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name; cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id;&#125;Waiter::Data() const&#123; cout &lt;&lt; &quot;panache: &quot; &lt;&lt; panache &lt;&lt; endl;&#125;Singer::Data() const&#123; cout &lt;&lt; &quot;rating: &quot; &lt;&lt; pv[voice] &lt;&lt; endl;&#125;SingingWaiter::Data() const&#123; Worker::Data(); Singer::Data();&#125;SingingWaiter::Show() const&#123; Worker::Data(); Data();&#125;//就是.........有点麻烦...","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"Hello World!!","date":"2016-12-27T13:49:34.066Z","path":"2016/12/27/hello-world/","text":"喵喵喵 本人的渣渣博客 以后就在这里撒欢辣 写的比较傻逼~ 大神轻喷呐 如有错误还劳驾指出哦~ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"C++笔记-私有继承","date":"2016-12-23T16:17:20.000Z","path":"2016/12/24/C++笔记-私有继承/","text":"使用私有继承,基类的共有成员以及保护成员都将成为派生类的私有成员派生类不继承基类的接口,但能在派生类的成员函数中使用它们,私有继承特征与包含相同:不继承接口,继承实现.所以它可以用来实现has-a关系. 示例:123456class player : private string,private valarray&lt;double&gt;//使用多个基类:多重继承&#123; public: ...&#125; 在这里新版本的构造函数将使用初始化成员列表,使用类名而不是使用成员名来标识构造函数: 12player::player(const char* str,const double* p,int i) : string(str),valarray&lt;double&gt;(p,i)&#123; &#125; 保护继承1class player : protected string,protected valarray&lt;double&gt;&#123;...&#125; 保护继承时,基类的公有成员和保护成员都将成为派生类的保护成员.使用私有继承时,第三代类将不能使用基类的接口,这是因为基类的公有方法在派生类中将变成私有方法.使用保护继承时,基类的公有方法将在二代类中变成受保护的,所以第三代类可以使用它们. 使用using重定义访问权限使用保护派生或者私有派生时,基类的公有继承将成为保护或者私有成员,如果想让基类方法在类外使用可以定义一个使用该基类方法的派生类方法.1234//派生类player希望使用基类valarray类的sum方法double player::sum() const &#123; return valarry&lt;double&gt;::sum();&#125; 或者可以使用using声明:123456class player : private valarray&lt;double&gt;&#123; public: using valarray&lt;double&gt;::min; using valarray&lt;double&gt;::max;&#125; 他们就像player类的共有方法一样:1cout &lt;&lt; &quot;high score:&quot; &lt;&lt; a[i].max &lt;&lt; endl; 注意 using声明只使用成员名,没有特征标,圆括号,返回类型,例如要在player]类中使用valarray类的operator[]方法,只需包含:1using::valarray::operator[]; 通常使用包含来建立has-a关系;如果新类需要访问原有类的保护成员,或需要重新定义虚函数应使用私有继承","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-包含类对象的成员","date":"2016-12-23T14:19:08.000Z","path":"2016/12/23/C++笔记-包含类对象的成员/","text":"接口和实现 使用公有继承时,类可以继承接口,可能还有实现(基类的纯虚函数提供接口,但不提供实现),获得接口是is-a的关系组成部分.而是用组合,类可以获得实现不继承接口是has-a的关系组成部分. 错误的示范:1234567891011121314class player&#123;private: string name; valarray&lt;double&gt; source; ostream &amp; arr_out(ostream &amp; os) const;public: player():name(&quot;NULL&quot;),source()&#123;&#125; explicit player(const string &amp; s) :name(s),source()&#123;&#125; explicit player(int n) :name(&quot;NULL&quot;),source(n)&#123;&#125; player(const string&amp; na, int n) :name(na),source(n)&#123;&#125;&#125;; 12player mylove(&quot;YSY&quot;,10);mylove = 5; //喵喵喵??重置ArrayD为五个空值的元素? mylove = 5;这里应该是:mylove[5] = 5才对.如果没有写explicit,编译器将调用转换构造函数player(5),name 的默认值将是NULL,并且编译器将会生成一个临时对象,并用临时对象替换mylove原有的值,这并不是我们想要的.如果加了explicit,编译器会报错这对我们debug很有利.毕竟在编译期出错优于在运行期出错.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-类设计总结","date":"2016-12-21T14:57:57.000Z","path":"2016/12/21/C++笔记-类设计总结/","text":"默认构造函数:默认构造函数要么没有参数,要么所有参数都有默认值.在派生类构造函数初始化列表中记得显示调用基类构造函数,否则编译器将会使用基类的默认构造函数,这可能会出现错误. 复制构造函数:1classname(const classname &amp;) 在按值传递,安置返回对象,编译器生产临时对象,将新对象初始化为一个同类对象的时候,将调用复制构造函数. 赋值运算符: 1classname &amp; operator=(const classname &amp;) 用于处理同类对象间的赋值,如果希望处理string类与classname类的赋值可以写成:1classname &amp; operator=(const string &amp;) 析构函数:当对象过期时,析构函数负责清理工作(如释放内存),对于基类应该提供一个虚析构函数,即使他不需要. 转换构造函数:1classname(const schar *) 使用一个参数的构造函数他定义了从参数类型到类类型的转换(话说这个中文名跟转换函数就差了两个字,但不一样容易弄混). 123Star(const char*);Star a = Star(&quot;233&quot;);a = &quot;233&quot;; 第二/三句话将会调用Star::operator(const Star &amp;)并使用Star(const char)生成一个对象,该对象将作用于赋值运算符函数的参数. 使用转换构造函数时候时建议使用explicit禁止隐式转换* 按值传递对象与传递引用通常在编写以对象作为参数的函数时,应该按引用,不应该使用按值传递参数,一是为了效率,二是因为在继承使用虚函数时,基类使用引用参数的函数可以接受派生类. 返回对象与返回引用如果函数返回的是通过引用或指针传递给他的对象,则应该按引用返回对象.返回引用可以节约内存和时间,与按引用传递相似,调用与被调用函数使用同一个对象进行操作.但不总是可以返回引用,比如函数不能返回一个在函数中创建的临时变量的引用,因为当函数结束时临时变量将会消失,这时候应该返回对象. const123456789classname::classname(const char * s) //确保方法不修改参数classname::show() const; //确保方法不修改调用他的对象,这里的const表示const classname * this,this指向调用的对象const classname&amp; classname::fun(const classname &amp; cn) const&#123; if(s.total &gt; total) return s; else return *this;&#125;;//该方法返回cn/this的引用,但因为cn/this是const,所以方法不能对cn/this进行修改,这意味着返回类型也必须为const 共有继承要考虑的因素:is-a关系is-a为”是一个”的意思,如果派生类不是某种特殊的基类则不要使用,比如从大脑类派生出程序员类.is-a关系的标志之一是:无需进行显示转换即可将积累指针或引用指向或引用派生类对象(向上强制类型转换).反之是可能出现错误的. 赋值运算符将派生类赋值给基类对象:123456class ZheXue &#123;...&#125;//基类-哲♂学class GaoBiLi : public ZheXue&#123;...&#125;//派生类-搞♂比♂利ZheXue bili;GaoBiLi fuc;bili = fuc; 1bili = fuc; 这将转化为: bili.operator=(fuc)他将调用 ZheXue::operator=(const ZheXue &amp;); 那如果将基类赋值给派生类对象呢:1fuc = bili; 这将转化为fuc.operator=(bili) ; 他将调用 GaoBiLi::operator=(const GaoBiLi &amp;);然而,派生类引用不能自动引用基类对象.除非我们定义转换构造函数:GaoBiLi(const ZheXue &amp;) ;转换构造函数可以有一个类型为基类的参数和其他参数,但其他参数必须有默认值: 1GaoBiLi(const ZheXue &amp; zx,string &amp; na = &quot;比♂利♂王&quot;,string &amp; ty = &quot;森之♂妖精&quot;); 这样转换构造函数会根据bili来创建一个临时对象,然后把它作为赋值运算符的参数.然而还可以直接写个参数为ZheXue的赋值运算符函数….: 1GaoBiLi::operator=(const ZheXue &amp;)&#123;......&#125;; 私有成员与保护成员对于外界来说,只能用共有成员来访问二者,对于派生类来说,可以直接访问基类的保护成员,而私有成员仍要通过基类的成员函数来访问. 虚方法如果要在派生类中重定义基类的方法则应该使用virtual. 析构函数基类的析构函数应当是虚的.这样在使用指针或者引用删除派生对象时,程序会先调用派生类的析构函数然后调用基类的,而不会只调用基类的析构函数 友元函数友元函数并非类成员因此不能继承,如果希望派生类函数能使用基类的友元函数,可以使派生类指针或引用强制转换为基类的指针或引用,然后使用转换后的指针或引用来调用友元函数. 123456ostream &amp; GaoBiLi::operator&lt;&lt;(ostream &amp; os, GaoBiLi &amp; gbl)&#123; os &lt;&lt; (const ZheXue &amp;)gbl; os &lt;&lt; &quot;name:&quot; &lt;&lt; gbl.name &lt;&lt; endl; return os;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-继承和动态内存分配","date":"2016-12-15T14:01:19.000Z","path":"2016/12/15/C++笔记-继承和动态内存分配/","text":"如果基类使用动态内存分配，派生类不使用1234567891011121314151617class player&#123; privatec: string * name; bool sex; public： player(const string &amp; na = &quot;NULL&quot;,bool a = 0); player(const player &amp; p); virtual ~player(); player &amp; operator=(const player &amp; p);&#125;class ship : public player&#123; private: int age; public: ...&#125; 那么是否要为ship类定义显示析构函数,复制构造函数,重载赋值运算符呢? 不需要. 析构函数: 对于ship类,我们没有对他进行任何特殊的操作,所以默认的析构函数是合适的 复制构造函数:首先我们知道的是,默认复制构造函数是执行成员复制,因为player使用了动态内存分配,所以,默认复制构造函数不适用于player类,但对于ship类是适合的.当复制继承的组件获或者成员时,则使用他的复制构造函数.所以当ship的默认复制构造函数会使用player的默认复制构造函数来复制ship里的player对象.所以默认复制构造函数对于他们来说是合适的. 赋值运算符: ship默认的赋值运算符也会使用player的赋值运算符来对player成员进行赋值,所以是合适的. 如果基类和派生类都使用动态内存分配123456class ship : public player&#123; private: string * type; public: ...&#125; 在这种情况下必须显示定义派生类的显示析构函数,复制构造函数,重载赋值运算符. 析构函数: 派生类的析构函数先释放type所管理的内存,然后基类析构函数释放name所管理的内存. 复制构造函数:派生类的复制构造函数只能访问派生类的数据,所以他必须调用父类的复制构造函数.ship::ship(const ship &amp; p) : player(p) , 因为player类因为复制构造函数有一个player&amp;参数,而基类可以指向派生类型,因此player的复制构造函数将使用ship参数的player部分来构造新对象的player部分. 赋值运算符:因为派生类采用动态内存分配,所以他需要一个显示赋值运算符.ship的赋值运算符只能直接访问ship类的数据,但他却要负责所继承的基类对象的赋值,这个时候可以显示调用基类的赋值运算符方法.然后在处理派生类的赋值.1234567ship &amp; ship::operator=(const player &amp; p)&#123; if(this == p) return *this; player::operator=(p);//显示调用基类赋值运算符 delete type; type = new string; type = p.type;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-抽象基类(Abstract-Base-Class,ABC)","date":"2016-12-14T15:46:31.000Z","path":"2016/12/14/C++笔记-抽象基类(Abstract-Base-Class,ABC)/","text":"啥时候使用抽象基类?在下理解的是:你有一个基类和一个该基类的派生类,但是基类里有一些你派生类根本用不上的方法,使用了派生类就会导致一些信息冗余.然而不继承基类单独写个类你发现效率也不高,而且你发现你的基类和你的派生类之前还是有共同点的..这个时候就要上抽象基类了….把其共同点放到抽象基类里,然后分别从抽象基类派生刚才的”基类”与”派生类”. 啥是抽象基类 就是类里定义了纯虚函数的类………然而定义了纯虚函数就只能作为基类了.23333 纯虚函数纯虚函数:virtual 返回类型 函数名(形参) =0;在虚函数声明后面加个 =0 就是纯虚函数了,当类声明中包含纯虚函数的时候,则不能创建该类对象.所以包含纯虚函数的类只能作为基类,在原型中使用 =0 指出类是一个抽象基类,在类中可以不定义该函数.12345678class player&#123; private: int age; string name; pbulic: ... virtual void show() = 0;&#125; 总之: ABC描述的是至少使用一个纯虚函数的接口,从ABC派生出的类将根据派生类的具体特征使用常规虚函数来实现这种接口.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-访问控制protected","date":"2016-12-13T15:22:36.000Z","path":"2016/12/13/C++笔记-访问控制protected/","text":"protected关键字protected的意思是保护,和private有点相似,在类外只能通过共有类成员来访问protected中的成员.但他与private的区别体现在:在派生类中,派生类的成员可以直接访问基类的protected成员,但不能直接访问基类的private成员.举个栗子:12345678910111213141516class player&#123; ... public: void R18(int a)&#123; if(a&lt;18)cout &lt;&lt; &quot;禁止入内&quot;; else &#123;cout &lt;&lt; &quot;欢♂迎&quot;; &#125; protected: int age;&#125;class ship : public player&#123; ... public: void showshipage(int m)&#123; age = m; cout &lt;&lt; age &lt;&lt; &quot;欢♂迎&quot;;&#125;//通过派生类公有成员直接访问基类protected成员 ...&#125; 但是这样做是有点小问题的age成员被设置为只能通过player::R18()来访问,但是有了ship::showshipage()将会忽略player::R18()的禁止入内措施,这使得age变成了一个公有变量…….然而对于成员函数来,保护控制很有用,他可以让派生类访问一些公众不能访问的内部函数.so..你问我滋补滋磁,我是滋次的.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-静态联编和动态联编","date":"2016-12-11T15:38:53.000Z","path":"2016/12/11/C++笔记-静态联编和动态联编/","text":"一些理解性概念 啥是联编将源代码中的程序调用解释为执行特定的函数代码块被称为函数名联编在编译过程中的联编被称为静态联编在程序运行时的联编被称为静态连编 ##指针和引用类型的兼容性将派生类指针或引用转为基类指针或者引用被称为向上强制转换,如果是共有继承则不需要进行显式类型转换,任何对基类对象做的操作都适合派生类对象.相反,将基类指针或者引用转换为派生类指针或者引用被称为向下强制转换,需要显示类型转换,但是派生类可以新增成员函数,由于基类没有这些函数,这使得使用新增成员函数的类成员函数不能作用于基类.123456789101112131415161718192021222324class player&#123; pubilc: player(string &amp; na)&#123;name = na;&#125; void showname()const &#123;cout &lt;&lt; name;&#125; private: string name;&#125;class ship : pubilc player&#123; public: ... void shouage(int age); private: int age;&#125;player lex(&quot;lexington&quot;); ship * t =(ship*)&amp;lex; //将基类指针转化为派生类指针,必须显示类型转换,向下强制转换ship sar(&quot;saratoga&quot;);player* v = &amp;sar; //将派生类指针转化为基类指针,向上强制转换t-&gt;showage(20); //不安全的操作 showage不是player的成员v-&gt;showname(); //安全的 现在我们有个虚方法1234567891011121314``` void fr(player &amp; r) //r.sizhai(); void fp(player * p) //p-&gt;sizhai(); void fv(player v) //v.sizhai(); fun()&#123; player p(&quot;LEX&quot;); ship s(&quot;sar&quot;); fr(p); // player::sizhai(); fr(s); // ship::sizhai(); fp(p); // player::sizhai(); fp(s); // ship::sizhai(); fv(p); // player::sizhai(); fv(s); // player::sizhai(); &#125; 由于按值传递ship对象的player部分被传递给函数fv().但是引用和指针发生的向上强制转换分别为player对象和ship对象使用了不同的函数(virtual).隐式向上强制类型转换使得基类对象可以指向基类对象或派生类对象,因此需要动态联编. 虚函数和动态联编概念理解:虚函数工作原理通常,编译器处理虚函数的原理是:给每个对象添加一个隐藏成员,这个隐藏成员保存了一个指向函数地址数组的指针.它被称为虚函数表,虚函数表保存了类对象的虚函数地址.列如,基类对象包含一个指针,它指向基类中所有虚函数的地址表.派生类对象将指向一个独立地址表的指针,如果派生类里提供了虚函数的定义,那么这个独立的地址表将会保存新函数的地址,如果没提供,该表将使用原始版本的地址.如果派生类定义了新的虚函数,那么该函数的地址也会被添加到表中. 注意:无论类中有多少个虚函数,都只在对象中添加一个地址成员,只是大小有所差别 虚函数总结: 构造函数不能是虚函数; 析构函数应该是虚函数(除非不作为基类); 友元不能是虚函数,因为友元函数不是类成员; 如果基类声明被重载,则应在派生类中重定义所有的基类重载版本; 重定义不是重载,如果重定义继承的方法,应该确保与原型完全一致;注意:如果原返回类型是指向基类的指针或者引用,可以改成指向派生类的指针和引用,这被成为返回类型协变","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-一个简单的基类","date":"2016-12-08T13:58:54.000Z","path":"2016/12/08/C++笔记-一个简单的基类/","text":"从一个类派生出另一个类,原始类被称为基类,继承类被称为派生类例:1234567891011121314151617181920class player&#123; public: player(const string &amp; na,bool se = 1); void Name() const&#123;cout &lt;&lt; name &lt;&lt; endl;&#125; bool sex &#123;return sex;&#125; privat: string name; bool sex;&#125; class Ship : public player //继承了player类 公有派生&#123; public://派生类需要自己的构造函数并且必须使用基类的构造函数 Ship(bool mw = 0,int ag, const string &amp; na, bool se = 1); Ship(bool mw = 0,int ag,player &amp; p); int ShowAge() &#123;cout &lt;&lt; age; return age;&#125; private: bool myWife; int age;&#125; 冒号说明了Ship的基类是player,public表示了这个基类是公有基类,这被成为公有派生.使用公有基类,基类的公有成员将成为派生类的公有成员,基类的私有成员也将成为派生类的一部分但是不能直接访问,需要通过继承的基类的公有方法来间接访问.创建派生类对象的时候,首先创造基类对象,C艹使用成员列表初始化完成该工作:12345678910//在此声明成员列表初始化只能用于构造函数 Ship::Ship(bool mw, int ag,const string &amp; na,bool se) : player(na,se)&#123; mw = 1; ag = 18; &#125; Ship::Ship(bool mw,int ag,player &amp; p) : player(p)&#123; mw = 0; ag = 14; &#125; 在第二个构造函数中 由于基类类型为 player &amp; ,因此将会调用基类的复制构造函数,由于基类没有该函数,则编译器将会自动生成一个~基类对象首先被创建.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数 派生类和基类之间的特殊关系基类指针或引用可以在不进行显式类型转换的情况下,指向或引用派生类对象或引用.然而基类指针和引用只能用于调用基类方法.所以不能用它们来调用派生类方法,如果将基类对象和地址赋值给派生类引用和指针.因为派生类引用可以为基类对象调用派生类方法,但是基类没有派生类的成员所以这么做是没意义的.可以这么写:123456789Ship sp1(1,17,&quot;Lexington&quot;,0);player *a = &amp;sp1; //OKplayer &amp;b = sp1; //OKa.Name();b-&gt;Name();player sp2(&quot;Saratoga&quot;,0);Ship *c = &amp;sp2; //不能这么写Ship &amp;d = sp2; //也不能这么写 但是如果基类引用和指针可以指向派生类对象呢?12345678void Show(const player &amp; p)&#123; //OK p.Name();&#125;player temp1(&quot;LEX&quot;,0);Ship temp2(1,17&quot;SAG&quot;,0);Show(temp1); //OKShow(temp2); //OK 函数Show的形参为一个基类引用,他可以指向基类对象或者派生类对象,并且该函数使用了基类的一个方法,所以Show可以使用player参数或者Ship参数.","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-多态公有继承","date":"2016-12-07T15:35:20.000Z","path":"2016/12/07/C++笔记-多态公有继承/","text":"虚方法:virtual该声明之处方法在派生类版本的行为不同.12345678910111213141516171819class You&#123;public: You(const string&amp; Na)&#123;Name = na;&#125; virtual string Show()&#123;return Name;&#125; ~You()&#123;&#125;private: string Name;&#125;class YouName : public You&#123;public:YouName()&#123;&#125;~YouName()&#123;&#125;virtual void Show()&#123;cout &lt;&lt; &quot;your name is &quot;; Name();&#125;&#125;You A(&quot;YSY&quot;); YouName B(&quot;YES&quot;);A.Name(); //You::Name()B.Name(); //YouNAme::Name(); 基类版本限定名为You::Show(),派生类限定名为YouName::Show()程序会根据使用对象类型来确定使用哪个版本. 需要注意的是如果方法是通过指针或引用调用的呢?程序将使用哪种方法? 如果没有使用关键字virtual,程序将根据引用类型或者指针类型来选择方法,如果使用了关键字virtual,程序将根据引用或指针指向的对象的类型来确定方法~","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"C++笔记-类和动态内存分配","date":"2016-12-07T13:59:20.000Z","path":"2016/12/07/C++笔记-类和动态内存分配/","text":"对于类中的非静态const数据成员,必须在执行到构造函数体前,级创建对象时进行初始化.他叫做成员列表初始化:123456789101112131415161718class FUN&#123; public: struct Node&#123;Item item;struct Node* next;&#125; Node* fornt; Node* rear; int items; const int qsize;&#125;FUN::FUN(int qs) : qsize(qs)&#123; front = rear = nullptr; items = 0;&#125;//然而这种方法不局限于常量 所以也可以这么写FUN::FUN(int qs):qsize(qs),rear(nullptr),front(nullptr),items(0)&#123;...&#125; 注意只有构造函数才可以使用这种方法,另外对于被引用的类成员也必须这么写: 123456class A&#123;...&#125;;class B&#123;private: A &amp; hello;&#125;B::B(A &amp; h) : hello(h)&#123;....&#125; 关于C++11的内存初始化直接这么写就行(那我们为啥要用第一种方法啊魂淡(｡•ˇ‸ˇ•｡)):1234class Classy&#123; int meml = 10; const int mem2 = 20;&#125;","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"QML与C++交互","date":"2016-12-05T14:38:29.000Z","path":"2016/12/05/QT-QML与C++交互/","text":"图片作者为:Bison仓鼠终于搞定了gayhub的博客,以后就在这里写一些自己想写的东西好了 ╰(´︶`)╯ 前几天用QT的QML与C++交互,基于QMediaPlayer类撸了一个baka音乐播放器 因为是第一次用QML撸 再加上我幼儿园水平的代码 写的一团糟..代码请用鼠标♂插 这里 这个坑爹的QML与C++交互折腾了我好久 (╬▔▽▔)凸 以我这辣鸡播放器为例(大神请绕道orz) 那么问题来了如何使用C艹来控制QML?假设我们的qml是酱紫写的 1234567891011121314151617181920212223Rectangle &#123; id: head y: 0 width: parent.width height: 40 color: \"#222225\" opacity: 0.95 Layout.maximumHeight: 45 Layout.fillWidth: true Layout.fillHeight: false Text &#123; id: musicteitle x:5 y:5 width: parent.width height: 30 color: \"#C8C8C8\" font.family: \"microsoft yahei\" font.pixelSize: 23 text:\"正在播放: \" + myTITLE &#125; &#125; 让我们用这段代码来显示正在播放的某音乐的名字,细心的你可能发现了 你写这辣鸡玩意前面的我都能看懂 那个myTITLE是什么鬼?这里让我们隆重介绍一下QQmlContext这个神奇的类 : “QQmlContext类定义了一个QML引擎上下文引擎上下文允许将数据暴露给由QML引擎实例化的QML组件每个QQmlContext包含一组属性，与其QObject属性不同，它允许数据通过名称显式绑定到上下文。上下文属性通过调用QQmlContext :: setContextProperty（）来定义和更新” –power for 谷歌翻译 参照官网 于是我们可以酱紫来控制音乐的名字:123QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* title = view-&gt;rootContext();title-&gt;setContextProperty(\"myTITLE\",QVariant(NowMusicName)); 通过修改NowMusicName的值就可修改myTITLE的值 这俩东西是绑定的于是我们就可以通过C++来修改NowMusicName 从而修改QML中的myTITLE 进而达到显示出当前音乐名字的目的 那么 view是何方神圣? 官方文档: QQmlApplicationEngine QQmlApplicationEngine提供了从单个QML文件加载应用程序的方便方法。这个类结合了QQmlEngine和QQmlComponent来提供一个方便的方式来加载单个QML文件。它还向QML提供了一些中央应用程序功能，C++/QML混合应用程序通常会从C++控制 –power for 谷歌翻译 果冻,能不能给力点啊?(눈_눈) 你说的这么水 没人会看的好吧ಥ_ಥ 既然能从用C艹来艹QML 那自然也能用QML来艹C艹了 如何用QML来艹C艹?假设我们现在有个音乐类Music 我们想通过点击某个按钮来调用Music类的暂停函数 那么如何实现呢?这个就相对的比较简单了123456//main.cpp如下Music A;QQmlApplicationEngine* view = new QQmlApplicationEngine;QQmlContext* context = view-&gt;rootContext();context-&gt;setContextProperty(&quot;myPlay&quot;,A); //先创建一个关于Music类的一个上下文 123456789101112131415161718192021222324//fun.qml如下MouseArea &#123; //设置鼠标点击区域 id: sta_pau x: 120 y: 8 width: 45 height: 45 Layout.maximumHeight: 40 Layout.maximumWidth: 70 Layout.fillHeight: true Layout.fillWidth: true onClicked: &#123; myPlay.pausePlay(); &#125; &#125; Image &#123; //把图片放到鼠标点击区域上去 这就是个按钮了 不要在意用没用button那个细节233 id: sta_pau_bg x: 120 y: 8 width: 45 height: 45 source: \"///img/我是一个萌萌的按钮图片.png\" &#125; 这样 一旦我们点击鼠标区域 就会触发与myPlay相之绑定的Music类对象A 从而调用A的暂停播放函数. 果冻,能不能再给力点啊?(눈_눈) 你说的这么水 等着挨喷吧 o(////▽////)q 既然你诚心诚意的发问了~那么,现在让我们结合起用C艹来艹QML与用QML来艹C艹,假设我们要撸一个音乐播放器的进度条.C艹负责处理歌曲总时长,当前播放进度,QML负责用花哨の特♂技显示出来这些. 机智的你一定想到了,这还不简单,QML中使用一个Text控件用于显示,C艹则用QQmlContext建立上下文把总时长与标记绑定,当总时长改变,标记的值也会随之改变,显示出来的总时长也会随之改变. 而当前播放进度则使用QML的进度条显示Slider 控件处理.Slider的value就是当前播放的进度,通过点击事件onPressedChanged来处理进度条的拖动~ 为了更精细的显示出当前播放进度,我们还需要一个用于显示当前播放秒数的Text~同理用C艹获得当前播放秒数,绑定上下文就成.这里只截出一部分 详情还劳烦各位去窝项目上的main.qml与music.cpp上瞅瞅 鬼畜级代码奉上(｡・`ω´･)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*QML*/ RowLayout &#123; id: progress x: 0 y: 20 width: 580 height: 60 spacing: 5 Layout.maximumWidth: 580 Text &#123; /*用于精确显示当前播放秒数*/ id: s_time y: 0 width: 40 height: 20 color: \"#C8C8C8\"; text: mySTIME /*秒数的上下文*/ font.pixelSize: 18 &#125; Slider &#123; id: bar x: 50 width: 450 height: 20 Layout.maximumWidth: 550 Layout.maximumHeight: 20 Layout.fillWidth: true maximumValue:myPlay.getEndtime();/*使用与Music类对象A绑定的上下文来获得当前音乐的总时长*/ value: setNOW /*用当前播放的值来设置进度条的当前进度*/ onPressedChanged: &#123; /*点击事件:当进度条拖动时改变音乐进度*/ myPlay.setNowMusicPos(value); &#125; &#125; Text &#123; id: e_time x: 515 y: 0 width: 40 height: 20 color: \"#C8C8C8\" text: myETIME /*总时长的上下文*/ font.pixelSize: 18 &#125; &#125; 12345678910111213141516/*C艹*/ QObject::connect(now, &amp;QMediaPlayer::positionChanged, [this](qint64 position)&#123; if(nowMusic-&gt;duration() != 0) /*QMediaPlayer* nowMusic */ this-&gt;setEndtime(this-&gt;now-&gt;duration()); //获取当前音乐的总时长 settime(position); /*Music类成员,用于获得当前播放的位置(就是当前播放到哪了 单位:毫秒)*/ QQmlContext* s_time =myView-&gt;rootContext(); //当前播放时长的上下文 s_time-&gt;setContextProperty(\"mySTIME\",QVariant(timeformat(position))); QQmlContext* now_progress = myView-&gt;rootContext();//进度条值的上下文 now_progress-&gt;setContextProperty(\"setNOW\",QVariant(position)); QQmlContext* e_time = myView-&gt;rootContext(); //总时长的上下文 e_time-&gt;setContextProperty(\"myETIME\",QVariant(timeformat(this-&gt;endtime))); &#125;); 在这里我们使用了一个QMediaPlayer类的一个信号,每当音乐播放进度改变时都会发射该信号从而调用与之对应的槽(在这段代码里槽为一个lambda).需要注意的是这个信号发射粒度(周期)为1s,据说可以修改发射粒度,找了半天无果,如果你知道怎么改,请务必联系我~阿里嘎多~每当音乐播放1s,positionchanged信号被发射,C++代码刷新各项数据,通过上下文引擎把数据暴露给QML.当进度条拖动的时候,QML的点击事件将触发改变音乐进度的函数来改变播放进度. 大概就酱 谢谢捧场 谢谢~ 欢迎讨论~欢迎纠错(逃","tags":[{"name":"CPP","slug":"CPP","permalink":"http://yoursite.com/tags/CPP/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"QML","slug":"QML","permalink":"http://yoursite.com/tags/QML/"}]}]